[
  {
    "objectID": "slidespage.html",
    "href": "slidespage.html",
    "title": "AE 2023",
    "section": "",
    "text": "Mostrar en una nueva pestaña"
  },
  {
    "objectID": "slidespage.html#slides",
    "href": "slidespage.html#slides",
    "title": "AE 2023",
    "section": "",
    "text": "Mostrar en una nueva pestaña"
  },
  {
    "objectID": "operaciones_geometricas.html",
    "href": "operaciones_geometricas.html",
    "title": "Operaciones geométricas",
    "section": "",
    "text": "library(sf)\nlibrary(terra)\nlibrary(dplyr)\nlibrary(spData)\nlibrary(spDataLarge)"
  },
  {
    "objectID": "operaciones_geometricas.html#introducción",
    "href": "operaciones_geometricas.html#introducción",
    "title": "Operaciones geométricas",
    "section": "Introducción",
    "text": "Introducción\nHasta ahora, hemos visto la estructura de los conjuntos de datos geográficos, y cómo manipularlos basándose en sus atributos no geográficos y relaciones espaciales. Este capítulo se centra en la manipulación de los elementos geográficos de los objetos geográficos, por ejemplo simplificando y convirtiendo geometrías vectoriales, recortando conjuntos de datos ráster y convirtiendo objetos vectoriales en rásteres y rásteres en vectores."
  },
  {
    "objectID": "operaciones_geometricas.html#operaciones-geométricas-sobre-datos-vectoriales",
    "href": "operaciones_geometricas.html#operaciones-geométricas-sobre-datos-vectoriales",
    "title": "Operaciones geométricas",
    "section": "Operaciones geométricas sobre datos vectoriales",
    "text": "Operaciones geométricas sobre datos vectoriales\nEsta sección trata de las operaciones que de alguna manera cambian la geometría de los objetos vectoriales (sf). Es más avanzada que las operaciones con datos espaciales presentadas anteriormente, porque aquí profundizamos en la geometría: las funciones discutidas en esta sección trabajan sobre objetos de clase sfc además de sobre objetos de clase sf.\nSimplificación\nLa simplificación es un proceso de generalización de objetos vectoriales (líneas y polígonos) que suele utilizarse en mapas de menor escala. Otra razón para simplificar objetos es reducir la cantidad de memoria, espacio en disco y ancho de banda de red que consumen: puede ser conveniente simplificar geometrías complejas antes de publicarlas como mapas interactivos. El paquete sf proporciona st_simplify(), que utiliza la implementación GEOS del algoritmo Douglas-Peucker para reducir el número de vértices. st_simplify() utiliza dTolerance para controlar el nivel de generalización en las unidades del mapa. La figura de abajo ilustra la simplificación de una geometría LINESTRING que representa el río Sena y sus afluentes. La geometría simplificada se creó mediante el siguiente comando:\n\nseine_simp = st_simplify(seine, dTolerance = 2000)  # 2000 m\n\n\n\n\n\nComparison of the original and simplified geometry of the seine object.\n\n\n\nEl objeto seine_simp resultante es una copia del seine original pero con menos vértices.\nLa simplificación también es aplicable a los polígonos. Esto se ilustra utilizando us_states, que representa los Estados Unidos contiguos. GEOS asume que los datos están en un CRS proyectado y esto podría llevar a resultados inesperados cuando se utiliza un CRS geográfico. Por lo tanto, el primer paso es proyectar los datos en algún CRS proyectado adecuado, como US National Atlas Equal Area (EPSG = 2163):\n\nus_states2163 = st_transform(us_states, \"EPSG:2163\")\n\nst_simplify() funciona igualmente bien con polígonos proyectados:\n\nus_states_simp1 = st_simplify(us_states2163, dTolerance = 100000)  # 100 km\n\nUna limitación de st_simplify() es que simplifica los objetos por geometría. Esto significa que se pierde la “topología”, lo que da lugar a la superposición y unidades areales con huecos. ms_simplify() de rmapshaper proporciona una alternativa que supera este problema. Por defecto utiliza el algoritmo Visvalingam, que supera algunas limitaciones del algoritmo Douglas-Peucker. El siguiente trozo de código utiliza esta función para simplificar us_states2163. El resultado tiene sólo el 1% de los vértices de la entrada (fijados usando el argumento keep) pero su número de objetos permanece intacto porque fijamos keep_shapes = TRUE:1\n\n# proportion of points to retain (0-1; default 0.05)\nus_states_simp2 = rmapshaper::ms_simplify(us_states2163, keep = 0.01,\n                                          keep_shapes = TRUE)\n\nUna alternativa a la simplificación es el suavizado de los límites de las geometrías poligonales y lineales, que se implementa en el paquete smoothr. El suavizado interpola los bordes de las geometrías y no conduce necesariamente a un menor número de vértices, pero puede ser especialmente útil cuando se trabaja con geometrías que surgen de vectorizar espacialmente un raster. smoothr implementa tres técnicas de suavizado: una regresión kernel gaussiana, el algoritmo de corte de esquinas de Chaikin y la interpolación spline. Los algoritmos de suavizado tampoco conservan la “topología”. La función principal de smoothr es smooth(), donde el argumento method especifica qué técnica de suavizado utilizar. A continuación se muestra un ejemplo de uso de la regresión kernel gaussiana para suavizar las fronteras de los estados de EE.UU. utilizando method=ksmooth. El argumento smoothness controla el ancho de banda de la gaussiana que se utiliza para suavizar la geometría y tiene un valor por defecto de 1.\n\nus_states_simp3 = smoothr::smooth(us_states2163, \n                                  method = \"ksmooth\", smoothness = 6)\n\nLa comparación visual del conjunto de datos original con las versiones simplificada y suavizada se muestra abajo. Pueden observarse diferencias entre los resultados de los algoritmos Douglas-Peucker (st_simplify), Visvalingam (ms_simplify) y regresión kernel gaussiana (smooth(method=ksmooth).\n\n\n\n\nPolygon simplification in action, comparing the original geometry of the contiguous United States with simplified versions, generated with functions from sf (top-right), rmapshaper (bottom-left), and smoothr (bottom-right) packages.\n\n\n\nCentroides\nLas operaciones de centroide identifican el centro de los objetos geográficos. Al igual que las medidas estadísticas de tendencia central, existen muchas formas de definir el centro geográfico de un objeto. Todas ellas crean representaciones de punto único de objetos vectoriales más complejos.\nLa operación de centroide más utilizada es el centroide geográfico. Este tipo de operación centroide representa el centro de masa de un objeto espacial. Los centroides geográficos tienen muchos usos, por ejemplo para crear una representación simple de puntos de geometrías complejas, o para estimar distancias entre polígonos. Pueden calcularse con la función sf st_centroid(), como se demuestra en el código siguiente, que genera los centroides geográficos de regiones de Nueva Zelanda y afluentes del río Sena, ilustrados con puntos negros.\n\nnz_centroid = st_centroid(nz)\nseine_centroid = st_centroid(seine)\n\nA veces, el centroide geográfico cae fuera de los límites de sus objetos padre (piense en un donut). En tales casos, las operaciones punto sobre superficie pueden utilizarse para garantizar que el punto se encuentra en el objeto padre (por ejemplo, para etiquetar objetos multipoligonales irregulares como los estados insulares), como ilustran los puntos rojos de la figura abajo. Observe que estos puntos rojos siempre se encuentran en sus objetos padre. Se crearon con st_point_on_surface() de la siguiente manera:\n\nnz_pos = st_point_on_surface(nz)\nseine_pos = st_point_on_surface(seine)\n\n\n\n\n\nCentroids (black points) and ‘points on surface’ (red points) of New Zealand’s regions (left) and the Seine (right) datasets.\n\n\n\nBuffers\nLos buffers son polígonos que representan el área dentro de una distancia determinada de un elemento geométrico: independientemente de si la entrada es un punto, una línea o un polígono, la salida es un polígono. El buffering suele utilizarse para el análisis de datos geográficos. ¿Cuántos puntos se encuentran a una distancia determinada de esta línea? ¿Qué grupos demográficos se encuentran a una distancia de viaje de esta nueva tienda? Este tipo de preguntas pueden responderse y visualizarse creando buffers alrededor de las entidades geográficas de interés.\nLa próxima figura ilustra los buffers de diferentes tamaños (5 y 50 km) que rodean el río Sena y sus afluentes. Estos buffers se crearon con los comandos que se indican a continuación, que muestran que el comando st_buffer() requiere al menos dos argumentos: una geometría de entrada y una distancia, proporcionada en las unidades del CRS (en este caso metros):\n\nseine_buff_5km = st_buffer(seine, dist = 5000)\nseine_buff_50km = st_buffer(seine, dist = 50000)\n\n\n\n\n\nBuffers around the Seine dataset of 5 km (left) and 50 km (right). Note the colors, which reflect the fact that one buffer is created per geometry feature.\n\n\n\nTransformaciones afines\nUna transformación afín es cualquier transformación que conserva las líneas y el paralelismo. Sin embargo, los ángulos o la longitud no se conservan necesariamente. Las transformaciones afines incluyen, entre otras, el desplazamiento (traslación), la escala y la rotación. Además, es posible utilizar cualquier combinación de ellas. Las transformaciones afines son una parte esencial de la geocomputación. Por ejemplo, el desplazamiento es necesario para la colocación de etiquetas, el escalado se utiliza en cartogramas de áreas no contiguas, y muchas transformaciones afines se aplican al reproyectar o mejorar la geometría que se creó basándose en un mapa distorsionado o mal proyectado. El paquete sf implementa transformaciones afines para objetos de las clases sfg y sfc.\n\nnz_sfc = st_geometry(nz)\n\nEl desplazamiento mueve cada punto la misma distancia en unidades de mapa. Puede hacerse añadiendo un vector numérico a un objeto vectorial. Por ejemplo, el código siguiente desplaza todas las coordenadas y 100.000 metros hacia el norte, pero deja intactas las coordenadas x.\n\nnz_shift = nz_sfc + c(0, 100000)\n\nLa escala amplía o reduce los objetos en un factor dado. Puede aplicarse global o localmente. El escalado global aumenta o disminuye todos los valores de las coordenadas en relación con las coordenadas de origen, manteniendo intactas todas las relaciones topológicas de las geometrías. Puede realizarse por sustracción o multiplicación de un objeto sfg o sfc.\nEl escalado local trata las geometrías de forma independiente y requiere puntos alrededor de los cuales se van a escalar las geometrías, por ejemplo, los centroides. En el ejemplo siguiente, cada geometría se reduce en un factor de dos alrededor de los centroides. Para ello, primero se desplaza cada objeto de modo que su centro tenga coordenadas 0, 0 ((nz_sfc - nz_centroid_sfc)). A continuación, los tamaños de las geometrías se reducen a la mitad (* 0,5). Por último, el centroide de cada objeto se desplaza a las coordenadas de los datos de entrada (+ nz_centroid_sfc).\n\nnz_centroid_sfc = st_centroid(nz_sfc)\nnz_scale = (nz_sfc - nz_centroid_sfc) * 0.5 + nz_centroid_sfc\n\nLa rotación de coordenadas bidimensionales requiere una matriz de rotación:\n\\[\nR =\n\\begin{bmatrix}\n\\cos \\theta & -\\sin \\theta \\\\  \n\\sin \\theta & \\cos \\theta \\\\\n\\end{bmatrix}\n\\]\nÉsta gira los puntos en el sentido de las agujas del reloj. La matriz de rotación se puede implementar en R como:\n\nrotation = function(a){\n  r = a * pi / 180 #degrees to radians\n  matrix(c(cos(r), sin(r), -sin(r), cos(r)), nrow = 2, ncol = 2)\n} \n\nLa función rotation acepta un argumento a - un ángulo de rotación en grados. La rotación puede realizarse alrededor de puntos seleccionados, como los centroides.\n\nnz_rotate = (nz_sfc - nz_centroid_sfc) * rotation(30) + nz_centroid_sfc\n\n\n\n\n\nIllustrations of affine transformations: shift, scale and rotate.\n\n\n\nPor último, las geometrías recién creadas pueden sustituir a las antiguas con la función st_set_geometry():\n\nnz_scale_sf = st_set_geometry(nz, nz_scale)\n\nClipping\nEl recorte espacial es una forma de subset espacial que implica cambios en las columnas geometry de al menos algunas de las características afectadas.\nEl recorte sólo puede aplicarse a características más complejas que los puntos: líneas, polígonos y sus equivalentes “multi”. Para ilustrar el concepto, empezaremos con un ejemplo sencillo: dos círculos superpuestos con un punto central a una unidad de distancia el uno del otro y un radio de uno.\n\nb = st_sfc(st_point(c(0, 1)), st_point(c(1, 1))) # create 2 points\nb = st_buffer(b, dist = 1) # convert points to circles\nplot(b, border = \"grey\")\ntext(x = c(-0.5, 1.5), y = 1, labels = c(\"x\", \"y\"), cex = 3) # add text\n\n\n\nOverlapping circles.\n\n\n\nImagina que quieres seleccionar no un círculo u otro, sino el espacio cubierto por x y y. Para ello se utiliza la función st_intersection(), ilustrada con objetos denominados x e y, que representan los círculos izquierdo y derecho.\n\nx = b[1]\ny = b[2]\nx_and_y = st_intersection(x, y)\nplot(b, border = \"grey\")\nplot(x_and_y, col = \"lightgrey\", border = \"grey\", add = TRUE) # intersecting area\n\n\n\nOverlapping circles with a gray color indicating intersection between them.\n\n\n\nEl siguiente fragmento de código demuestra cómo funciona esto para todas las combinaciones del diagrama de Venn que representan x e y, inspirado en la Figura 5.1 del libro R for Data Science.\n\n\n\n\nSpatial equivalents of logical operators.\n\n\n\nSubsetting y clipping\nRecortar objetos puede cambiar su geometría, pero también puede subdividir objetos, devolviendo sólo las características que se cruzan (o se cruzan parcialmente) con un objeto de recorte/subconjunto. Para ilustrar este punto, vamos a subdividir puntos que cubren el cuadro delimitador de los círculos x e y en la figura anterior. Algunos puntos estarán dentro de un solo círculo, otros dentro de los dos y otros dentro de ninguno. A continuación se utiliza st_sample() para generar una distribución aleatoria de puntos dentro de la extensión de los círculos x e y, planteando la siguiente pregunta: ¿cómo subconjuntar los puntos para devolver sólo el punto que se cruza con ambos x e y?\n\nbb = st_bbox(st_union(x, y))\nbox = st_as_sfc(bb)\nset.seed(2017)\np = st_sample(x = box, size = 10)\np_xy1 = p[x_and_y]\nplot(box, border = \"grey\", lty = 2)\nplot(x, add = TRUE, border = \"grey\")\nplot(y, add = TRUE, border = \"grey\")\nplot(p, add = TRUE)\nplot(p_xy1, cex = 3, col = \"red\", add = TRUE)\ntext(x = c(-0.5, 1.5), y = 1, labels = c(\"x\", \"y\"), cex = 2)\n\n\n\nRandomly distributed points within the bounding box enclosing circles x and y. The point that intersects with both objects x and y is highlighted.\n\n\n\n\nbb = st_bbox(st_union(x, y))\nbox = st_as_sfc(bb)\nset.seed(2017)\np = st_sample(x = box, size = 10)\nx_and_y = st_intersection(x, y)\n\nEl siguiente fragmento de código muestra tres formas de conseguir el mismo resultado. Podemos utilizar la intersección de x y y (representados por x_and_y en el fragmento de código anterior) como un objeto de subconjunto directamente, como se muestra en la primera línea en el fragmento de código a continuación. También podemos encontrar la intersección entre los puntos de entrada representados por p y el objeto de subconjunto/recorte x_and_y, como se muestra en la segunda línea del fragmento de código siguiente. Este segundo enfoque devolverá características que se intersecan parcialmente con x_and_y pero con geometrías modificadas para características espacialmente extensas que cruzan la frontera del objeto de subconjunto. El tercer enfoque consiste en crear un objeto de subconjunto utilizando el predicado espacial binario st_intersects(). Los resultados son idénticos (salvo diferencias superficiales en los nombres de los atributos), pero la implementación difiere sustancialmente:\n\np_xy1 = p[x_and_y] # way #1\np_xy2 = st_intersection(p, x_and_y) # way #2\nsel_p_xy = st_intersects(p, x, sparse = FALSE)[, 1] & \n  st_intersects(p, y, sparse = FALSE)[, 1] # way #3\np_xy3 = p[sel_p_xy]\n\nUniones geométricas\nLa agregación espacial puede disolver silenciosamente las geometrías de los polígonos que se tocan en el mismo grupo. Esto se demuestra en el fragmento de código siguiente, en el que 49 us_states se agregan en cuatro regiones utilizando las funciones base y dplyr:\n\nregions = aggregate(x = us_states[, \"total_pop_15\"], by = list(us_states$REGION),\n                    FUN = sum, na.rm = TRUE)\nregions2 = us_states |&gt; \n  group_by(REGION) |&gt;\n  summarize(pop = sum(total_pop_15, na.rm = TRUE))\n\n\n\n\n\nSpatial aggregation on contiguous polygons, illustrated by aggregating the population of US states into regions, with population represented by color. Note the operation automatically dissolves boundaries between states.\n\n\n\n¿Qué ocurre con las geometrías? Entre bastidores, tanto aggregate() como summarize() combinan las geometrías y disuelven los límites entre ellas utilizando st_union(). Esto se demuestra en el fragmento de código siguiente, que crea un oeste de EE.UU. unido:\n\nus_west = us_states[us_states$REGION == \"West\", ]\nus_west_union = st_union(us_west)\n\nLa función puede tomar dos geometrías y unirlas, como se demuestra en el siguiente fragmento de código que crea un bloque occidental unido que incorpora Texas:\n\ntexas = us_states[us_states$NAME == \"Texas\", ]\ntexas_union = st_union(us_west_union, texas)\n\nTransformaciones de tipo\nGeometry casting es una potente operación que permite transformar el tipo de geometría. Está implementada en la función st_cast() del paquete sf. Es importante destacar que st_cast() se comporta de forma diferente en objetos de geometría simple (sfg) y objetos de geometría simple en columna (sfc).\nVamos a crear un multipunto para ilustrar cómo funciona el cambio de geometría en objetos de geometría simple (sfg):\n\nmultipoint = st_multipoint(matrix(c(1, 3, 5, 1, 3, 1), ncol = 2))\n\nEn este caso, st_cast() puede ser útil para transformar el nuevo objeto en una cadena de líneas o un polígono:\n\nlinestring = st_cast(multipoint, \"LINESTRING\")\npolyg = st_cast(multipoint, \"POLYGON\")\n\n\n\n\n\nExamples of a linestring and a polygon casted from a multipoint geometry.\n\n\n\nLa conversión de multipunto a cadena de líneas es una operación habitual que crea un objeto de línea a partir de observaciones de puntos ordenados, como mediciones GPS o medios geoetiquetados. Esto, a su vez, permite realizar operaciones espaciales como el cálculo de la longitud del camino recorrido. La conversión de multipunto o cadena de líneas a polígono se utiliza a menudo para calcular un área, por ejemplo a partir del conjunto de mediciones GPS tomadas alrededor de un lago o de las esquinas de un solar.\nEl proceso de transformación también puede invertirse utilizando st_cast():\n\nmultipoint_2 = st_cast(linestring, \"MULTIPOINT\")\nmultipoint_3 = st_cast(polyg, \"MULTIPOINT\")\nall.equal(multipoint, multipoint_2)\nall.equal(multipoint, multipoint_3)\n## [1] TRUE\n## [1] TRUE\n\n\n\n\n\n\n\nNota\n\n\n\nPara geometrías simples (sfg), st_cast() también permite pasar geometrías de no multitipos a multitipos (por ejemplo, de POINT a MULTIPOINT) y de multitipos a no multitipos. Sin embargo, al pasar de multitipos a no multitipos, sólo el primer elemento del objeto antiguo permanecerá en el objeto de salida.\n\n\nLa conversión geométrica de la columna geométrica de características simples (sfc) y los objetos de características simples funciona igual que para sfg en la mayoría de los casos. Una diferencia importante es la conversión de multitipos a no multitipos. Como resultado de este proceso, los objetos múltiples de sfc o sf se dividen en muchos objetos no múltiples.\nLa tabla de abajo muestra las posibles transformaciones del tipo de geometría en objetos sf. Las geometrías de sf (representadas por la primera columna de la tabla) pueden transformarse en múltiples tipos de geometría, representados por las columnas de la tabla abajo. Algunas transformaciones no son posibles: no se puede convertir un único punto en una multilínea o un polígono, por ejemplo, lo que explica por qué las celdas [1, 4:5] de la tabla contienen NA. Algunas transformaciones dividen la entrada de una única característica en múltiples subcaracterísticas, “expandiendo” objetos sf (añadiendo nuevas filas con valores de atributos duplicados). Cuando una geometría multipunto que consta de cinco pares de coordenadas se transforma en una geometría “PUNTO”, por ejemplo, la salida contendrá cinco características.\n\n\n\nGeometry casting on simple feature geometries (see Section 2.1) with input type by row and output type by column\n\n\nPOI\nMPOI\nLIN\nMLIN\nPOL\nMPOL\nGC\n\n\n\nPOI(1)\n1\n1\n1\nNA\nNA\nNA\nNA\n\n\nMPOI(1)\n4\n1\n1\n1\n1\nNA\nNA\n\n\nLIN(1)\n5\n1\n1\n1\n1\nNA\nNA\n\n\nMLIN(1)\n7\n2\n2\n1\nNA\nNA\nNA\n\n\nPOL(1)\n5\n1\n1\n1\n1\n1\nNA\n\n\nMPOL(1)\n10\n1\nNA\n1\n2\n1\n1\n\n\nGC(1)\n9\n1\nNA\nNA\nNA\nNA\n1\n\n\n\n\n Note: Values like (1) represent the number of features; NA means the operation is not possible. Abbreviations: POI, LIN, POL and GC refer to POINT, LINESTRING, POLYGON and GEOMETRYCOLLECTION. The MULTI version of these geometry types is indicated by a preceding M, e.g., MPOI is the acronym for MULTIPOINT.\n\n\n\n\n\n\n\n\n\n\n\nIntentemos aplicar transformaciones de tipo geométrico sobre un nuevo objeto, multilinestring_sf, como ejemplo :\n\nmultilinestring_list = list(matrix(c(1, 4, 5, 3), ncol = 2), \n                            matrix(c(4, 4, 4, 1), ncol = 2),\n                            matrix(c(2, 4, 2, 2), ncol = 2))\nmultilinestring = st_multilinestring(multilinestring_list)\nmultilinestring_sf = st_sf(geom = st_sfc(multilinestring))\nmultilinestring_sf\n\n\n\n\n\n\ngeom\n\n\n\n\nMULTILINESTRING ((1 5, 4 3)…\n\n\n\n\n\n\nPuede imaginárselo como una red de carreteras o ríos. El nuevo objeto sólo tiene una fila que define todas las líneas. Esto restringe el número de operaciones que se pueden realizar, por ejemplo impide añadir nombres a cada segmento de línea o calcular longitudes de líneas individuales. La función st_cast() puede utilizarse en esta situación, ya que separa una mutlilínea en tres líneas:\n\nlinestring_sf2 = st_cast(multilinestring_sf, \"LINESTRING\")\nlinestring_sf2\n\n\n\n\n\n\ngeom\n\n\n\n\n\nLINESTRING (1 5, 4 3)\n\n\n\n\nLINESTRING (4 4, 4 1)\n\n\n\n\nLINESTRING (2 2, 4 2)\n\n\n\n\n\n\n\n\n\n\n\nExamples of type casting between MULTILINESTRING (left) and LINESTRING (right).\n\n\n\nEl objeto recién creado permite la creación de atributos y mediciones de longitud:\n\nlinestring_sf2$name = c(\"Riddle Rd\", \"Marshall Ave\", \"Foulke St\")\nlinestring_sf2$length = st_length(linestring_sf2)\nlinestring_sf2\n\n\n\n\n\n\ngeom\n\n\nname\n\n\nlength\n\n\n\n\n\nLINESTRING (1 5, 4 3)\n\n\nRiddle Rd\n\n\n3.605551\n\n\n\n\nLINESTRING (4 4, 4 1)\n\n\nMarshall Ave\n\n\n3.000000\n\n\n\n\nLINESTRING (2 2, 4 2)\n\n\nFoulke St\n\n\n2.000000"
  },
  {
    "objectID": "operaciones_geometricas.html#operaciones-geométricas-sobre-datos-raster",
    "href": "operaciones_geometricas.html#operaciones-geométricas-sobre-datos-raster",
    "title": "Operaciones geométricas",
    "section": "Operaciones geométricas sobre datos raster",
    "text": "Operaciones geométricas sobre datos raster\nLas operaciones geométricas ráster incluyen el desplazamiento, la inversión, el reflejo, la escala, la rotación o la deformación de imágenes. Estas operaciones son necesarias para diversas aplicaciones, como la georreferenciación, que permite superponer imágenes en un mapa con un CRS conocido. Existen diversas técnicas de georreferenciación, entre las que se incluyen:\n\nGeorrectificación basada en puntos de control terrestre conocidos\n\nOrtorectificación, que también tiene en cuenta la topografía local\nEl co-registro de imágenes se utiliza para combinar imágenes del mismo objeto pero tomadas con sensores diferentes, alineando una imagen con otra (en términos de sistema de coordenadas y resolución).\n\nR es bastante inadecuado para los dos primeros puntos, ya que a menudo requieren una intervención manual, por lo que suelen realizarse con la ayuda de software SIG específico. Por otro lado, alinear varias imágenes es posible en R y esta sección muestra, entre otras cosas, cómo hacerlo. Esto incluye a menudo cambiar la extensión, la resolución y el origen de una imagen. Por supuesto, también se requiere una proyección que coincida.\nIntersecciones geométricas\nHemos mostrado cómo extraer valores de un ráster superpuesto por otros objetos espaciales. Para recuperar una salida espacial, podemos utilizar casi la misma sintaxis de subset. La única diferencia es que tenemos que dejar claro que queremos mantener la estructura matricial estableciendo el argumento drop en FALSE. Esto devolverá un objeto raster que contiene las celdas cuyos puntos medios se solapan con clip.\n\nelev = rast(system.file(\"raster/elev.tif\", package = \"spData\"))\nclip = rast(xmin = 0.9, xmax = 1.8, ymin = -0.45, ymax = 0.45,\n            resolution = 0.3, vals = rep(1, 9))\nelev[clip, drop = FALSE]\n## class       : SpatRaster \n## dimensions  : 2, 1, 1  (nrow, ncol, nlyr)\n## resolution  : 0.5, 0.5  (x, y)\n## extent      : 1, 1.5, -0.5, 0.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## varname     : elev \n## name        : elev \n## min value   :   18 \n## max value   :   24\n\nPara la misma operación también podemos utilizar el comando intersect() y crop().\nExtensión y origen\nCuando fusionamos o realizamos álgebra de mapas sobre rásters, su resolución, proyección, origen y/o extensión tienen que coincidir. De lo contrario, ¿cómo podríamos sumar los valores de un ráster con una resolución de 0.2 grados decimales a un segundo ráster con una resolución de 1 grado decimal? El mismo problema se plantea cuando queremos fusionar imágenes de satélite procedentes de distintos sensores con proyecciones y resoluciones diferentes. Los desajustes pueden resolverse alineando los rásters.\nEn el caso más sencillo, dos imágenes sólo difieren en su extensión. El código siguiente añade una fila y dos columnas a cada lado del ráster y establece todos los valores nuevos en NA.\n\nelev = rast(system.file(\"raster/elev.tif\", package = \"spData\"))\nelev_2 = extend(elev, c(1, 2))\n\n\n\n\n\nOriginal raster (left) and the same raster (right) extended by one row on the top and bottom and two columns on the left and right.\n\n\n\nAl realizar una operación algebraica sobre dos objetos con extensiones diferentes en R, el paquete terra devuelve un error.\n\nelev_3 = elev + elev_2\n## Error: [+] extents do not match\n\nSin embargo, podemos alinear la extensión de dos rásters con extend(). En lugar de decirle a la función cuántas filas o columnas deben añadirse (como se ha hecho antes), le permitimos que lo averigüe utilizando otro objeto raster. En este caso, ampliamos el objeto elev hasta la extensión elev_2. Los valores de las filas y columnas recién añadidas se fijan en NA.\n\nelev_4 = extend(elev, elev_2)\n\nEl origen de un raster es la esquina de la celda más cercana a las coordenadas (0, 0). La función origin() devuelve las coordenadas del origen. En el siguiente ejemplo existe una esquina de celda con coordenadas (0, 0), pero no es necesariamente el caso.\n\norigin(elev_4)\n## [1] 0 0\n\nSi dos rásters tienen orígenes diferentes, sus celdas no se solapan completamente, lo que haría imposible el álgebra de mapas. Para cambiar el origen, utilice origin().2 La próxima figura muestra el efecto de cambiar el origen de esta forma.\n\n# change the origin\norigin(elev_4) = c(0.25, 0.25)\n\n\n\n\n\nRasters with identical values but different origins.\n\n\n\nTenga en cuenta que al cambiar la resolución (apartado siguiente) también cambia con frecuencia el origen.\nAgregación y desagregación\nLos conjuntos de datos ráster también pueden diferir en cuanto a su resolución. Para igualar las resoluciones, se puede disminuir (aggregate()) o aumentar (disagg()) la resolución de un raster.3 Como ejemplo, aquí cambiamos la resolución espacial de dem (que se encuentra en el paquete spDataLarge) por un factor de 5. Además, el valor de la celda de salida debe corresponder a la media de las celdas de entrada (tenga en cuenta que también se podrían utilizar otras funciones, como median(), sum(), etc.):\n\ndem = rast(system.file(\"raster/dem.tif\", package = \"spDataLarge\"))\ndem_agg = aggregate(dem, fact = 5, fun = mean)\n\n\n\n\n\nOriginal raster (left). Aggregated raster (right).\n\n\n\nLa función disagg() aumenta la resolución de los objetos raster. Dispone de dos métodos para calcular los valores de las celdas recién creadas: el método por defecto (method = \"near\") simplemente da a todas las celdas de salida el valor de la celda de entrada y, por tanto, duplica los valores, lo que se traduce en una salida “en bloque”. El método bilineal utiliza los cuatro centros de píxel más cercanos de la imagen de entrada para calcular un promedio ponderado por la distancia. El valor de la celda de salida está representado por un cuadrado en la esquina superior izquierda.\n\ndem_disagg = disagg(dem_agg, fact = 5, method = \"bilinear\")\nidentical(dem, dem_disagg)\n## [1] FALSE\n\n\n\n\n\nThe distance-weighted average of the four closest input cells determine the output when using the bilinear method for disaggregation.\n\n\n\nLa comparación de los valores de dem y dem_disagg nos indica que no son idénticos (también puede utilizar compareGeom() o all.equal()). Sin embargo, esto no era de esperar, ya que la desagregación es una simple técnica de interpolación. Es importante tener en cuenta que la desagregación da como resultado una resolución más fina; los valores correspondientes, sin embargo, sólo son tan precisos como su fuente de menor resolución.\nRemuestreo\nLos métodos anteriores de agregación y desagregación sólo son adecuados cuando queremos cambiar la resolución de nuestro ráster mediante el factor de agregación/desagregación. Sin embargo, ¿qué hacer cuando tenemos dos o más rásters con resoluciones y orígenes diferentes? Esta es la función del remuestreo, un proceso de cálculo de valores para las nuevas ubicaciones de los píxeles. En resumen, este proceso toma los valores de nuestro ráster original y recalcula nuevos valores para un ráster de destino con resolución y origen personalizados.\n\n\n\n\nResampling of an original (input) raster into a target raster with custom resolution and origin.\n\n\n\nExisten varios métodos para estimar los valores de un ráster con diferentes resoluciones/orígenes. Los principales métodos de remuestreo son\n\nVecino más cercano: asigna el valor de la celda más cercana del ráster original a la celda del objetivo. Se trata de una técnica rápida y sencilla que suele ser adecuada para el remuestreo de rásters categóricos.\nInterpolación bilineal: asigna una media ponderada de las cuatro celdas más cercanas del raster original a la celda del raster de destino. Es el método más rápido y apropiado para rásters continuos.\nInterpolación cúbica: utiliza los valores de las 16 celdas más cercanas del ráster original para determinar el valor de la celda de salida, aplicando funciones polinómicas de tercer orden. Se utiliza para rásters continuos y da como resultado una superficie más suave en comparación con la interpolación bilineal, pero es computacionalmente más exigente.\nInterpolación spline cúbica: también utiliza los valores de las 16 celdas más cercanas del ráster original para determinar el valor de la celda de salida, pero aplica splines cúbicos (funciones polinómicas de tercer orden a trozos). Se utiliza para raster continuos.\nRemuestreo sinc con ventana de Lanczos: utiliza los valores de las 36 celdas más cercanas del raster original para determinar el valor de la celda de salida. Se utiliza para los raster continuos.\n\nLa explicación anterior pone de relieve que sólo el remuestreo de vecino más próximo es adecuado para los rásteres categóricos, mientras que todos los métodos pueden utilizarse (con diferentes resultados) para los rásteres continuos. Tenga en cuenta también que los métodos ganan en complejidad y tiempo de procesamiento de arriba a abajo.\nPara aplicar el remuestreo, el paquete terra proporciona una función resample(). Acepta un ráster de entrada (x), un ráster objetivo (y) y un método de remuestreo (method).\nNecesitamos un ráster objetivo para ver cómo funciona la función resample(). Para este ejemplo, creamos target_rast, pero a menudo se utiliza un objeto raster ya existente.\n\ntarget_rast = rast(xmin = 794650, xmax = 798250, \n                   ymin = 8931750, ymax = 8935350,\n                   resolution = 300, crs = \"EPSG:32717\")\n\nA continuación, tenemos que proporcionar nuestros dos objetos raster como los dos primeros argumentos y uno de los métodos de remuestreo descritos anteriormente.\n\ndem_resampl = resample(dem, y = target_rast, method = \"bilinear\")\n\nLa próxima figura muestra una comparación de diferentes métodos de remuestreo en el objeto dem.\n\n\n\n\nVisual comparison of the original raster and five different resampling methods.\n\n\n\nLa función resample() también tiene algunos métodos de remuestreo adicionales, como sum, min, q1, med, q3, max, average, mode y rms. Todos ellos calculan una estadística determinada basándose en los valores de todas las celdas de la cuadrícula que no son NA. Por ejemplo, sum es útil cuando cada celda raster representa una variable espacialmente extensa (por ejemplo, el número de personas). Como consecuencia del uso de sum, el ráster remuestreado debería tener el mismo número total de personas que el original.\nLa reproyección de raster es un caso especial de remuestreo cuando nuestro raster de destino tiene un CRS diferente al del raster original."
  },
  {
    "objectID": "operaciones_geometricas.html#footnotes",
    "href": "operaciones_geometricas.html#footnotes",
    "title": "Operaciones geométricas",
    "section": "Notas",
    "text": "Notas\n\n La simplificación de objetos multipoligonales puede eliminar pequeños polígonos internos, incluso si el argumento keep_shapes está ajustado a TRUE. Para evitar esto, es necesario establecer explode = TRUE. Esta opción convierte todos los mutlipolígonos en polígonos separados antes de su simplificación.↩︎\n Si los orígenes de dos conjuntos de datos ráster están sólo marginalmente separados, a veces es suficiente simplemente aumentar el argumento tolerance de terra::terraOptions().↩︎\n Aquí nos referimos a la resolución espacial. En teledetección también son importantes la resolución espectral (bandas espectrales), temporal (observaciones a lo largo del tiempo de la misma zona) y radiométrica (profundidad de color). Consulte el ejemplo tapp() de la documentación para hacerse una idea de cómo realizar la agregación temporal de rásters.↩︎"
  },
  {
    "objectID": "operaciones_con_atributos.html",
    "href": "operaciones_con_atributos.html",
    "title": "Operaciones con atributos",
    "section": "",
    "text": "Los atributos son la información no espacial asociada a la información geográfica o geometría."
  },
  {
    "objectID": "operaciones_con_atributos.html#vectores",
    "href": "operaciones_con_atributos.html#vectores",
    "title": "Operaciones con atributos",
    "section": "Vectores",
    "text": "Vectores\n\nmethods(class = \"sf\") # methods for sf objects\n##   [1] $&lt;-                          [                           \n##   [3] [[&lt;-                         aggregate                   \n##   [5] anti_join                    arrange                     \n##   [7] as.data.frame                cbind                       \n##   [9] coerce                       crs                         \n##  [11] dbDataType                   dbWriteTable                \n##  [13] distance                     distinct                    \n##  [15] dplyr_reconstruct            duplicated                  \n##  [17] ext                          extract                     \n##  [19] filter                       full_join                   \n##  [21] group_by                     group_split                 \n##  [23] identify                     initialize                  \n##  [25] inner_join                   left_join                   \n##  [27] lines                        mask                        \n##  [29] merge                        mutate                      \n##  [31] plot                         points                      \n##  [33] polys                        print                       \n##  [35] rasterize                    rbind                       \n##  [37] rename                       rename_with                 \n##  [39] right_join                   rowwise                     \n##  [41] sample_frac                  sample_n                    \n##  [43] select                       semi_join                   \n##  [45] show                         slice                       \n##  [47] slotsFromS3                  st_agr                      \n##  [49] st_agr&lt;-                     st_area                     \n##  [51] st_as_s2                     st_as_sf                    \n##  [53] st_as_sfc                    st_bbox                     \n##  [55] st_boundary                  st_break_antimeridian       \n##  [57] st_buffer                    st_cast                     \n##  [59] st_centroid                  st_collection_extract       \n##  [61] st_concave_hull              st_convex_hull              \n##  [63] st_coordinates               st_crop                     \n##  [65] st_crs                       st_crs&lt;-                    \n##  [67] st_difference                st_drop_geometry            \n##  [69] st_filter                    st_geometry                 \n##  [71] st_geometry&lt;-                st_inscribed_circle         \n##  [73] st_interpolate_aw            st_intersection             \n##  [75] st_intersects                st_is                       \n##  [77] st_is_valid                  st_join                     \n##  [79] st_line_merge                st_m_range                  \n##  [81] st_make_valid                st_minimum_rotated_rectangle\n##  [83] st_nearest_points            st_node                     \n##  [85] st_normalize                 st_point_on_surface         \n##  [87] st_polygonize                st_precision                \n##  [89] st_reverse                   st_sample                   \n##  [91] st_segmentize                st_set_precision            \n##  [93] st_shift_longitude           st_simplify                 \n##  [95] st_snap                      st_sym_difference           \n##  [97] st_transform                 st_triangulate              \n##  [99] st_triangulate_constrained   st_union                    \n## [101] st_voronoi                   st_wrap_dateline            \n## [103] st_write                     st_z_range                  \n## [105] st_zm                        summarise                   \n## [107] svc                          tmapGetShapeMeta1           \n## [109] tmapGetShapeMeta2            tmapShape                   \n## [111] tmapSubsetShp                transform                   \n## [113] transmute                    ungroup                     \n## [115] vect                        \n## see '?methods' for accessing help and source code\n\nCon los objetos sf también se pueden utilizar los métodos de tidyverse para data.frame, tbl_df y tbl. De este modo, sf permite explotar las capacidades de análisis de datos de R en los datos geográficos, tanto si se utilizan las funciones básicas de R como las de tidyverse para el análisis de datos.\n\nclass(world) \ndim(world)\n## [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n## [1] 177  11\n\nLa función st_drop_geometry() conserva únicamente los atributos de un objeto sf, es decir, elimina su geometría.\n\nworld_df = st_drop_geometry(world)\nclass(world_df)\nncol(world_df)\n## [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n## [1] 10\n\nPara muchas aplicaciones, el paquete tidyverse dplyr ofrece un enfoque eficaz para trabajar con los data frames. La compatibilidad con tidyverse es una ventaja de sf.\nSubdivisión de vectores vía sus atributos\nLos métodos de subdivisión básicos de R incluyen el operador [ y la función subset(), mientras que en el paquete dplyr, éstas son son filter() y slice() para filas, y select() para columnas. Ambos métodos conservan los componentes espaciales de los datos en los objetos sf, mientras que si se utiliza el operador $ o la función dplyr pull() para devolver una única columna de atributos como vector, se perderán los datos geométricos.\n\nworld[1:6, ]    # subset rows by position\nworld[, 1:3]    # subset columns by position\nworld[1:6, 1:3] # subset rows and columns by position\nworld[, c(\"name_long\", \"pop\")] # columns by name\nworld[, c(T, T, F, F, F, F, F, T, T, F, F)] # by logical indices\nworld[, 888] # an index representing a non-existent column\n\nPodemos usar vectores lógicos para seleccionar subconjuntos de datos:\n\ni_small = world$area_km2 &lt; 10000\nsummary(i_small) # a logical vector\nsmall_countries = world[i_small, ]\n##    Mode   FALSE    TRUE \n## logical     170       7\n\no más sencillamente:\n\nsmall_countries = world[world$area_km2 &lt; 10000, ]\n\nLa función subset() nos permite realizar la misma operación:\n\nsmall_countries = subset(world, area_km2 &lt; 10000)\n\nLas funciones de R base son maduras, estables y ampliamente utilizadas, lo que las convierte en una opción sólida, especialmente en contextos en los que la reproducibilidad y la fiabilidad son fundamentales. Las funciones de dplyr por su parte permiten flujos de trabajo “ordenados” o tidy que algunas personas consideran intuitivos y productivos para el análisis interactivo de datos. A continuación se muestran las funciones clave para hacer subset de data.frames con funciones dplyr.\n\nselect()\n\n\nworld1 = select(world, name_long, pop)\nnames(world1)\n## [1] \"name_long\" \"pop\"       \"geom\"\n\n\n# all columns between name_long and pop (inclusive)\nworld2 = select(world, name_long:pop)\n\n\n\n- operator\n\n\n# all columns except subregion and area_km2 (inclusive)\nworld3 = select(world, -subregion, -area_km2)\n\n\n\nselect(): subset and rename\n\n\nworld4 = select(world, name_long, population = pop)\n\nselect() también funciona con “funciones de ayuda” para operaciones de subset más avanzadas, como contains(), starts_with() y num_range().\nLa mayoría de los verbos dplyr devuelven un data.frame, pero también se puede extraer una sola columna como un vector con pull(). Se puede obtener el mismo resultado en R base con los operadores $ y [[, los tres comandos siguientes devuelven el mismo vector numérico:\n\npull(world, pop)\nworld$pop\nworld[[\"pop\"]]\n\n\n\nslice() es el equivalente en filas de select(). El siguiente fragmento de código, por ejemplo, selecciona las filas 1 a 6:\n\n\nslice(world, 1:6)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\niso_a2\nname_long\ncontinent\nregion_un\nsubregion\ntype\narea_km2\npop\nlifeExp\ngdpPercap\ngeom\n\n\n\nFJ\nFiji\nOceania\nOceania\nMelanesia\nSovereign country\n19289.97\n885806\n69.96000\n8222.254\nMULTIPOLYGON (((-180 -16.55…\n\n\nTZ\nTanzania\nAfrica\nAfrica\nEastern Africa\nSovereign country\n932745.79\n52234869\n64.16300\n2402.099\nMULTIPOLYGON (((33.90371 -0…\n\n\nEH\nWestern Sahara\nAfrica\nAfrica\nNorthern Africa\nIndeterminate\n96270.60\nNA\nNA\nNA\nMULTIPOLYGON (((-8.66559 27…\n\n\nCA\nCanada\nNorth America\nAmericas\nNorthern America\nSovereign country\n10036042.98\n35535348\n81.95305\n43079.143\nMULTIPOLYGON (((-132.71 54….\n\n\nUS\nUnited States\nNorth America\nAmericas\nNorthern America\nCountry\n9510743.74\n318622525\n78.84146\n51921.985\nMULTIPOLYGON (((-171.7317 6…\n\n\nKZ\nKazakhstan\nAsia\nAsia\nCentral Asia\nSovereign country\n2729810.51\n17288285\n71.62000\n23587.338\nMULTIPOLYGON (((87.35997 49…\n\n\n\n\n\n\n\n\nfilter() es el equivalente de dplyr a la función subset() de R base. Mantiene sólo las filas que coinciden con los criterios dados, por ejemplo, sólo los países con un área por debajo de un cierto umbral, o con un alto promedio de esperanza de vida:\n\n\nworld7 = filter(world, area_km2 &lt; 10000)  # countries with a small area\nworld7 = filter(world, lifeExp &gt; 82)      # with high life expectancy\n\nLa clave de los flujos de trabajo que utilizan funciones dplyr es el operador ‘pipe’ %&gt;% (o desde R 4.1.0 la tubería nativa |&gt;), que toma su nombre del pipe de Unix |. Los pipes permiten un código expresivo: la salida de una función se convierte en el primer argumento de la siguiente función, permitiendo el encadenamiento. Esto se ilustra a continuación donde sólo se filtran los países de Asia del conjunto de datos world, a continuación el objeto se subdivide por columnas (nombre_largo y continente) y se extraen las cinco primeras filas.\n\nworld7 = world |&gt;\n  filter(continent == \"Asia\") |&gt;\n  select(name_long, continent) |&gt;\n  slice(1:5)\n\nLo de arriba puede también expresarse como funciones anidadas, aunque es más difícil de leer:\n\nworld8 = slice(\n  select(\n    filter(world, continent == \"Asia\"),\n    name_long, continent),\n  1:5)\n\nAgregación de atributos vectoriales\nLa agregación consiste en resumir los datos con una o varias “variables de agrupación”, normalmente a partir de columnas de la tabla de datos que se desea agregar. Un ejemplo de agregación de atributos es calcular el número de personas por continente a partir de datos a nivel de país (una fila por país). El conjunto de datos world contiene los ingredientes necesarios: las columnas pop y continent, la población y la variable de agrupación, respectivamente. El objetivo es hallar la sum() de las poblaciones de los países para cada continente, lo que da como resultado un data.frame más pequeño. Esto se puede hacer con la función base de R aggregate() de la siguiente manera:\n\nworld_agg1 = aggregate(pop ~ continent, FUN = sum, data = world, na.rm = TRUE)\nclass(world_agg1)\nhead(world_agg1)\n## [1] \"data.frame\"\n\n\n\n\ncontinent\npop\n\n\n\nAfrica\n1154946633\n\n\nAsia\n4311408059\n\n\nEurope\n669036256\n\n\nNorth America\n565028684\n\n\nOceania\n37757833\n\n\nSouth America\n412060811\n\n\n\n\n\n\naggregate() es una función genérica lo que significa que se comporta de forma diferente dependiendo de sus entradas. sf proporciona el método aggregate.sf() que se activa automáticamente cuando x es un objeto sf y se proporciona un argumento by:\n\nworld_agg2 = aggregate(world[\"pop\"], list(world$continent), \n                       FUN = sum, \n                       na.rm = TRUE)\nclass(world_agg2)\nnrow(world_agg2)\n## [1] \"sf\"         \"data.frame\"\n## [1] 8\n\nEl objeto resultante world_agg2 es un objeto espacial que contiene 8 características que representan los continentes del mundo.\nLa función group_by() |&gt; summarize() es el equivalente dplyr de aggregate(), con el nombre de la variable proporcionada en la función group_by() especificando la variable de agrupación y la información sobre lo que se va a resumir pasada a la función summarize(), como se muestra a continuación:\n\nworld_agg3 = world |&gt;\n  group_by(continent) |&gt;\n  summarize(pop = sum(pop, na.rm = TRUE))\n\nEste enfoque puede parecer más complejo, pero tiene ventajas: flexibilidad, legibilidad y control sobre los nuevos nombres de las columnas. Esta flexibilidad se ilustra en el comando siguiente, que calcula no sólo la población, sino también la superficie y el número de países de cada continente:\n\nworld_agg4  = world |&gt; \n  group_by(continent) |&gt; \n  summarize(Pop = sum(pop, na.rm = TRUE), Area = sum(area_km2), N = n())\n\nEn el trozo de código anterior Pop, Area y N son nombres de columnas en el resultado, y sum() y n() las funciones de agregación. Estas funciones de agregación devuelven objetos sf con filas que representan continentes y geometrías que contienen los múltiples polígonos que representan cada masa de tierra y las islas asociadas (esto funciona gracias a la operación geométrica union, como se explica más abajo.\nCombinemos lo que hemos aprendido hasta ahora sobre las funciones dplyr, encadenando múltiples comandos para resumir datos de atributos sobre países de todo el mundo por continentes. El siguiente comando calcula la densidad de población (con mutate()), ordena los continentes por el número de países que contienen (con dplyr::arrange()), y mantiene sólo los 3 continentes más poblados (con dplyr::slice_max()):\n\nworld_agg5 = world |&gt; \n  st_drop_geometry() |&gt;                      # drop the geometry for speed\n  select(pop, continent, area_km2) |&gt; # subset the columns of interest  \n  group_by(continent) |&gt;                     # group by continent and summarize:\n  summarize(Pop = sum(pop, na.rm = TRUE), Area = sum(area_km2), N = n()) |&gt;\n  mutate(Density = round(Pop / Area)) |&gt;     # calculate population density\n  slice_max(Pop, n = 3) |&gt;                   # keep only the top 3\n  arrange(desc(N))                           # arrange in order of n. countries\n\n\noptions(scipen = 999)\nknitr::kable(\n  world_agg5,\n  caption = \"The top 3 most populous continents ordered by number of countries.\",\n  caption.short = \"Top 3 most populous continents.\",\n  booktabs = TRUE\n)\n\n\nThe top 3 most populous continents ordered by number of countries.\n\ncontinent\nPop\nArea\nN\nDensity\n\n\n\nAfrica\n1154946633\n29946198\n51\n39\n\n\nAsia\n4311408059\n31252459\n47\n138\n\n\nEurope\n669036256\n23065219\n39\n29\n\n\n\n\n\nUnión de atributos vectoriales\nCombinar datos de distintas fuentes es una tarea habitual en la preparación de datos. Las uniones lo hacen combinando tablas basadas en una variable “clave” o key compartida. dplyr tiene múltiples funciones de unión, incluyendo left_join() y inner_join() — ver vignette(\"two-table\") para una lista completa. Los nombres de estas funciones siguen las convenciones utilizadas en el lenguaje de bases de datos SQL; su uso para unir conjuntos de datos no espaciales a objetos sf es el objetivo de esta sección. Las funciones join de dplyr funcionan igual en data.frames y objetos sf, la única diferencia importante es la columna geometry. El resultado de las uniones de datos puede ser un objeto sf o un data.frame. El tipo más común de unión de atributos en datos espaciales toma un objeto sf como primer argumento y le añade columnas de un data.frame especificado como segundo argumento.\nPara demostrar las uniones, combinaremos datos sobre la producción de café con el conjunto de datos world. Los datos sobre el café se encuentran en un data.frame denominado coffee_data del paquete spData. Tiene 3 columnas: name_long nombra las principales naciones productoras de café y coffee_production_2016 y coffee_production_2017 contienen valores estimados para la producción de café en bolsas de 60 kg en cada año. Un “left join”, que conserva el primer conjunto de datos, combina “world” con “coffee_data”:\n\nworld_coffee = left_join(world, coffee_data)\nclass(world_coffee)\n## [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n\nDado que los conjuntos de datos de entrada comparten una “key” (name_long), la unión funcionó sin utilizar el argumento by (véase ?left_join para más detalles). El resultado es un objeto sf idéntico al objeto world original, pero con dos nuevas variables (con índices de columna 11 y 12) sobre la producción de café. Esto puede representarse como un mapa, tal y como se ilustra en la Figura (fig:coffeemap), generada con la función plot() que se muestra a continuación:\n\nnames(world_coffee)\nplot(world_coffee[\"coffee_production_2017\"])\n\n\n\nWorld coffee production (thousand 60-kg bags) by country, 2017. Source: International Coffee Organization.\n\n\n##  [1] \"iso_a2\"                 \"name_long\"              \"continent\"             \n##  [4] \"region_un\"              \"subregion\"              \"type\"                  \n##  [7] \"area_km2\"               \"pop\"                    \"lifeExp\"               \n## [10] \"gdpPercap\"              \"geom\"                   \"coffee_production_2016\"\n## [13] \"coffee_production_2017\"\n\nPara que la unión funcione, se debe proporcionar una columna “key” en ambos conjuntos de datos. Por defecto, dplyr utiliza todas las variables con nombres coincidentes. En este caso, los objetos world_coffee y world contienen una variable llamada name_long, lo que explica el mensaje Joining withby = join_by(name_long)``. En la mayoría de los casos en los que los nombres de las variables no coinciden, hay dos opciones:\n\nCambiar el nombre de la variable clave en uno de los objetos para que coincidan.\nUtilizar el argumento by para especificar las variables de unión.\n\nEste último enfoque se demuestra a continuación en una versión renombrada de coffee_data:\n\ncoffee_renamed = rename(coffee_data, nm = name_long)\nworld_coffee2 = left_join(world, coffee_renamed, by = join_by(name_long == nm))\n\nObserve que se mantiene el nombre en el objeto original, lo que significa que world_coffee y el nuevo objeto world_coffee2 son idénticos. Otra característica del resultado es que tiene el mismo número de filas que el conjunto de datos original. Aunque sólo hay 47 filas de datos en coffee_data, los 177 registros de países se mantienen intactos en world_coffee y world_coffee2: A las filas del conjunto de datos original que no coinciden se les asignan valores NA para las nuevas variables de producción de café. ¿Qué ocurre si sólo queremos conservar los países que tienen una coincidencia en la variable key?\nEn ese caso, se puede utilizar una unión interna:\n\nworld_coffee_inner = inner_join(world, coffee_data)\nnrow(world_coffee_inner)\n## [1] 45\n\nObserve que el resultado de inner_join() sólo tiene 45 filas frente a las 47 de coffee_data. ¿Qué ha pasado con las filas restantes? Podemos identificar las filas que no coinciden utilizando la función setdiff() de la siguiente manera:\n\nsetdiff(coffee_data$name_long, world$name_long)\n## [1] \"Congo, Dem. Rep. of\" \"Others\"\n\nEl resultado muestra que Otros representa una fila que no está presente en el conjunto de datos world y que el nombre de la Democratic Republic of the Congo representa la otra: se ha abreviado, lo que hace que la unión no lo encuentre. El siguiente comando utiliza una función de concordancia de cadenas (regex) del paquete stringr para confirmar cuál debería ser Congo, Rep. Dem. of debería ser:\n\ndrc = stringr::str_subset(world$name_long, \"Dem*.+Congo\")\ndrc\n## [1] \"Democratic Republic of the Congo\"\n\n\n# aim: test names in coffee_data and world objects\nstringr::str_subset(coffee_data$name_long, \"Ivo|Congo,\")\n.Last.value %in% stringr::str_subset(world$name_long, \"Ivo|Dem*.+Congo\")\n## [1] \"Congo, Dem. Rep. of\" \"Côte d'Ivoire\"      \n## logical(0)\n\nPara solucionar este problema, crearemos una nueva versión de coffee_data y actualizaremos el nombre. Si unimos el data.frame actualizado con inner_join(), obtendremos un resultado con las 46 naciones productoras de café:\n\ncoffee_data$name_long[grepl(\"Congo,\", coffee_data$name_long)] = drc\nworld_coffee_match = inner_join(world, coffee_data)\nnrow(world_coffee_match)\n## [1] 46\n\nTambién es posible unir en la otra dirección: empezar con un conjunto de datos no espaciales y añadir variables de un objeto sf. Esto se demuestra a continuación, se comienza con el objeto coffee_data y se añaden variables del conjunto de datos world. En contraste con las uniones anteriores, el resultado no es un sf, sino un data.frame en forma de tidyverse tibble: el resultado de una unión tiende a coincidir con su primer argumento:\n\ncoffee_world = left_join(coffee_data, world)\nclass(coffee_world)\n## [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\n\n\n\n\n\nNota\n\n\n\nEn la mayoría de los casos, la columna de geometría sólo es útil en un objeto sf. La columna de geometría sólo se puede utilizar para crear mapas y operaciones espaciales si R “sabe” que es un objeto espacial, definido por un paquete espacial como sf. Afortunadamente, los marcos de datos no espaciales con una columna de lista de geometría (como coffee_world) pueden coaccionarse en un objeto sf de la siguiente manera: st_as_sf(coffee_world).\n\n\nCreación de atributos y eliminación de información espacial\nA menudo, nos gustaría crear una nueva columna basada en columnas ya existentes. Por ejemplo, queremos calcular la densidad de población de cada país. Para ello necesitamos dividir una columna de población, aquí pop, por una columna de área, aquí area_km2 con unidad de área en kilómetros cuadrados. Usando R base, podemos escribir:\n\nworld_new = world # do not overwrite our original data\nworld_new$pop_dens = world_new$pop / world_new$area_km2\n\nAlternativamente, podemos utilizar una de las funciones de dplyr - mutate() o transmute(). La función mutate() añade nuevas columnas en la penúltima posición del objeto sf (la última se reserva para la geometría):\n\nworld_new2 = world |&gt; \n  mutate(pop_dens = pop / area_km2)\n\nLa diferencia entre mutate() y transmute() es que esta última elimina todas las demás columnas existentes (excepto la columna de geometría).\nLa función unite() del paquete tidyr (que proporciona muchas funciones útiles para remodelar conjuntos de datos, incluida pivot_longer()) pega las columnas existentes. Por ejemplo, queremos combinar las columnas continent y region_un en una nueva columna llamada con_reg. Además, podemos definir un separador (aquí: dos puntos :) que define cómo deben unirse los valores de las columnas de entrada, y si deben eliminarse las columnas originales (aquí: TRUE):\n\nworld_unite = world |&gt;\n  tidyr::unite(\"con_reg\", continent:region_un, sep = \":\", remove = TRUE)\n\nEl objeto sf resultante tiene una nueva columna llamada con_reg que representa el continente y la región de cada país, por ejemplo South America:Americas para Argentina y otros países de Sudamérica.\nLa función separate() de tidyr hace lo contrario que unite(): divide una columna en varias columnas utilizando una expresión regular o posiciones de caracteres.\n\nworld_separate = world_unite |&gt;\n  tidyr::separate(con_reg, c(\"continent\", \"region_un\"), sep = \":\")\n\nCada una de estas operaciones de datos de atributos conserva la geometría de las características simples. A veces tiene sentido eliminar la geometría, por ejemplo para acelerar la agregación. Hágalo con st_drop_geometry(), no manualmente con comandos como select(world, -geom), como se muestra a continuación.1\n\nworld_data = world |&gt; st_drop_geometry()\nclass(world_data)\n## [1] \"tbl_df\"     \"tbl\"        \"data.frame\""
  },
  {
    "objectID": "operaciones_con_atributos.html#raster",
    "href": "operaciones_con_atributos.html#raster",
    "title": "Operaciones con atributos",
    "section": "Raster",
    "text": "Raster\nA diferencia del modelo de datos vectoriales subyacente a sf (que representa puntos, líneas y polígonos como entidades discretas en el espacio), los datos ráster representan superficies continuas. Esta sección muestra cómo funcionan los objetos ráster creándolos desde cero con el paquete terra. Debido a su estructura única, la subdivisión o subset y otras operaciones en conjuntos de datos ráster funcionan de una manera diferente.\nEl siguiente código recrea el conjunto de datos ráster utilizado en el apartado anterior. Esto demuestra cómo funciona la función rast() para crear un raster de ejemplo llamado elev.\n\nelev = rast(nrows = 6, ncols = 6,\n            xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n            vals = 1:36)\n\nEl resultado es un objeto raster con 6 filas y 6 columnas (especificadas por los argumentos nrow y ncol), y una extensión espacial mínima y máxima en dirección x e y (xmin, xmax, ymin, ymax). El argumento vals establece los valores que contiene cada celda.\nLos objetos raster también pueden contener valores categóricos de la clase logical o variables factor:\n\ngrain_order = c(\"clay\", \"silt\", \"sand\")\ngrain_char = sample(grain_order, 36, replace = TRUE)\ngrain_fact = factor(grain_char, levels = grain_order)\ngrain = rast(nrows = 6, ncols = 6, \n             xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n             vals = grain_fact)\n\nEl objeto ráster almacena la correspondiente tabla de consulta o “Raster Attribute Table” (RAT) como una lista de data.frames, que pueden visualizarse con cats(grain) (véase ?cats() para más información). Cada elemento de esta lista es una capa del raster. También es posible utilizar la función levels() para recuperar y añadir nuevos niveles de factor o sustituir los existentes:\n\nlevels(grain) = data.frame(value = c(0, 1, 2), wetness = c(\"wet\", \"moist\", \"dry\"))\nlevels(grain)\n## [[1]]\n##   value wetness\n## 1     0     wet\n## 2     1   moist\n## 3     2     dry\n\n\n\n\n\nRaster datasets with numeric (left) and categorical values (right).\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nLos objetos ráster categóricos también pueden almacenar información sobre los colores asociados a cada valor utilizando una tabla de colores. La tabla de colores es un marco de datos con tres (rojo, verde, azul) o cuatro (alfa) columnas, donde cada fila se refiere a un valor. Las tablas de color en terra pueden verse o establecerse con la función coltab() (ver ?coltab). Es importante destacar que, al guardar un objeto ráster con una tabla de colores en un archivo (por ejemplo, GeoTIFF), también se guardará la información de color.\n\n\nRaster subsetting\nEl subconjunto raster se realiza con el operador base de R [, que acepta una variedad de entradas:\n\nIndexación fila-columna\nID de celda\nCoordenadas\nOtro objeto espacial\n\nAquí sólo mostramos las dos primeras opciones, ya que pueden considerarse operaciones no espaciales. Si necesitamos un objeto espacial para subdividir otro o la salida es un objeto espacial, nos referiremos a esto como subset espacial. Por lo tanto, estas dos últimas opciones se mostrarán en el próximo capítulo.\nLas dos primeras opciones de subconjunto se muestran en los siguientes comandos — ambos devuelven el valor del píxel superior izquierdo en el objeto ráster elev:\n\n# row 1, column 1\nelev[1, 1]\n# cell ID 1\nelev[1]\n\nSubdividir objetos ráster multicapa devolverá los valores de las celdas de cada capa. Por ejemplo, two_layers = c(grain, elev); two_layers[1] devuelve un marco de datos con una fila y dos columnas — una para cada capa. Para extraer todos los valores o filas completas, también puede utilizar values().\nLos valores de las celdas pueden modificarse sobrescribiendo los valores existentes junto con una operación de subconjunto. El siguiente fragmento de código, por ejemplo, establece la celda superior izquierda de elev a 0:\n\nelev[1, 1] = 0\nelev[]\n\nDejar los corchetes vacíos es una versión abreviada de values() para recuperar todos los valores de una capa. También se pueden modificar múltiples celdas de esta forma:\n\nelev[1, c(1, 2)] = 0\n\nResumen de objetos raster\nterra contiene funciones para extraer estadísticas descriptivas de rásters enteros. Al imprimir un objeto raster en la consola escribiendo su nombre, se obtienen los valores mínimo y máximo de un raster.\nsummary() proporciona estadísticas descriptivas comunesindex{statistics} – mínimo, máximo, cuartiles y número de NAs para rásters continuos y un número de celdas de cada clase para rásters categóricos.\nOtras operaciones de resumen, como la desviación estándar (véase más adelante) o estadísticas de resumen personalizadas, pueden calcularse con global().\n\nglobal(elev, sd)\n\n\n\n\n\n\n\nNota\n\n\n\nIf you provide the summary() and global() functions with a multi-layered raster object, they will summarize each layer separately, as can be illustrated by running: summary(c(elev, grain)).\n\n\nAdemás, la función freq() permite obtener la tabla de frecuencias de valores categóricos.\nLas estadísticas de valores raster pueden visualizarse de varias formas. Funciones específicas como boxplot(), density(), hist() y pairs() funcionan también con objetos raster, como se demuestra en el histograma creado con el comando siguiente (no mostrado):\n\nhist(elev, breaks=2)"
  },
  {
    "objectID": "operaciones_con_atributos.html#footnotes",
    "href": "operaciones_con_atributos.html#footnotes",
    "title": "Operaciones con atributos",
    "section": "Notas",
    "text": "Notas\n\n st_geometry(world_st) = NULL también funciona para eliminar la geometría de world, pero sobrescribe el objeto original.↩︎"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Análisis Espacial",
    "section": "",
    "text": "Presentación\n\nEl material que se presenta a continuacoión fue traducido y recortado del libro “Geocomputation with R” de Robin Lovelace, Jakub Nowosad y Jannes Muenchow.\n\nDatos espaciales en R\nOperaciones con atributos\nOperaciones espaciales\nOperaciones con geometrías\nInteracción raster-vector\nReproyección de datos espaciales\nEntrada y salida de datos espaciales\nHaciendo mapas en R"
  },
  {
    "objectID": "geo_input_output.html",
    "href": "geo_input_output.html",
    "title": "Entrada y salida de geo-datos",
    "section": "",
    "text": "library(sf)\nlibrary(terra)\nlibrary(dplyr)\nlibrary(spData)"
  },
  {
    "objectID": "geo_input_output.html#introducción",
    "href": "geo_input_output.html#introducción",
    "title": "Entrada y salida de geo-datos",
    "section": "Introducción",
    "text": "Introducción\nEste capítulo trata sobre la lectura y escritura de datos geográficos. La entrada de datos geográficos es esencial para la geocomputación: las aplicaciones del mundo real son imposibles sin datos. La salida de datos también es vital, ya que permite a otros utilizar valiosos conjuntos de datos nuevos o mejorados resultantes de su trabajo. En conjunto, estos procesos de entrada/salida pueden denominarse E/S de datos (I/O en Inglés).\nLa E/S de datos geográficos suele realizarse con unas pocas líneas de código al principio y al final de los proyectos. A menudo se pasa por alto como un simple proceso de un solo paso. Sin embargo, los errores cometidos al principio de los proyectos (por ejemplo, utilizar un conjunto de datos obsoleto o defectuoso de alguna manera) pueden dar lugar a grandes problemas más adelante, por lo que vale la pena dedicar un tiempo considerable a identificar qué conjuntos de datos están disponibles, dónde se pueden encontrar y cómo recuperarlos. Por otra parte, existen muchos formatos de archivos geográficos, cada uno de los cuales tiene sus pros y sus contras, como así también diferentes formas de lectura y escritura eficiente."
  },
  {
    "objectID": "geo_input_output.html#recuperación-de-datos-abiertos",
    "href": "geo_input_output.html#recuperación-de-datos-abiertos",
    "title": "Entrada y salida de geo-datos",
    "section": "Recuperación de datos abiertos",
    "text": "Recuperación de datos abiertos\nCada vez hay más datos geográficos disponibles en Internet, muchos de los cuales son de acceso y uso gratuitos (siempre que se dé el crédito correspondiente a sus proveedores)1. En cierto modo, ahora hay demasiados datos, en el sentido de que a menudo hay varios sitios donde acceder al mismo conjunto de datos. Algunos conjuntos de datos son de mala calidad. En este contexto, es vital saber dónde buscar. Varios “geoportales” (servicios web que proporcionan conjuntos de datos geoespaciales, como Data.gov) son un buen punto de partida, ya que ofrecen una amplia gama de datos, pero a menudo sólo para lugares concretos (como se ilustra en la página actualizada de Wikipedia sobre el tema).\nAlgunos geoportales globales superan este problema. El portal GEOSS y el Copernicus Open Access Hub, por ejemplo, contienen muchos conjuntos de datos ráster con cobertura mundial. En el portal SEDAC, gestionado por la Administración Nacional de Aeronáutica y del Espacio (NASA), y en el geoportal INSPIRE de la Unión Europea, con cobertura mundial y regional, se puede acceder a una gran cantidad de conjuntos de datos vectoriales.\nLa mayoría de los geoportales ofrecen una interfaz gráfica que permite consultar los conjuntos de datos en función de características como la extensión espacial y temporal, siendo el EarthExplorer del Servicio Geológico de Estados Unidos un buen ejemplo. Explorar los conjuntos de datos de forma interactiva en un navegador es una forma eficaz de comprender las capas disponibles. Sin embargo, desde el punto de vista de la reproducibilidad y la eficiencia, es mejor descargar los datos mediante código. Las descargas pueden iniciarse desde la línea de comandos mediante diversas técnicas, principalmente a través de URL y API (véase Sentinel API, por ejemplo). Los archivos alojados en URL estáticas pueden descargarse con download.file(), como se ilustra en el fragmento de código siguiente que accede a PeRL: Permafrost Region Pond and Lake Database de doi.pangaea.de:\n\ndownload.file(url = \"https://hs.pangaea.de/Maps/PeRL/PeRL_permafrost_landscapes.zip\",\n              destfile = \"PeRL_permafrost_landscapes.zip\", \n              mode = \"wb\")\nunzip(\"PeRL_permafrost_landscapes.zip\")\ncanada_perma_land = read_sf(\"PeRL_permafrost_landscapes/canada_perma_land.shp\")"
  },
  {
    "objectID": "geo_input_output.html#paquetes-de-datos-geográficos",
    "href": "geo_input_output.html#paquetes-de-datos-geográficos",
    "title": "Entrada y salida de geo-datos",
    "section": "Paquetes de datos geográficos",
    "text": "Paquetes de datos geográficos\nSe han desarrollado muchos paquetes de R para acceder a datos geográficos, algunos de los cuales se presentan a continuación. Éstos proporcionan interfaces a una o más bibliotecas espaciales o geoportales y tienen como objetivo hacer que el acceso a los datos sea aún más rápido desde la línea de comandos.\n\n\n\nSelected R packages for geographic data retrieval.\n\nPackage\nDescription\n\n\n\nFedData\nDatasets maintained by the US Federal government, including elevation and land cover.\n\n\ngeodata\nDownload and import imports administrative, elevation, WorldClim data.\n\n\nosmdata\nDownload and import small OpenStreetMap datasets.\n\n\nosmextract\nDownload and import large OpenStreetMap datasets.\n\n\nrnaturalearth\nAccess to Natural Earth vector and raster data.\n\n\nrnoaa\nImports National Oceanic and Atmospheric Administration (NOAA) climate data.\n\n\n\n\n\nCabe destacar que la tabla representa sólo un pequeño número de paquetes de datos geográficos disponibles. Por ejemplo, existe un gran número de paquetes R para obtener diversos datos sociodemográficos, como tidycensus y tigris (EE.UU.), cancensus (Canadá), eurostat y giscoR (Unión Europea), o idbr (bases de datos internacionales) – lea Analyzing US Census Data para encontrar algunos ejemplos de cómo analizar dichos datos. Del mismo modo, existen varios paquetes de R que dan acceso a datos espaciales de diversas regiones y países, como bcdata (provincia de Columbia Británica), geobr (Brasil), RCzechia (Chequia) o rgugik (Polonia). Otro paquete destacable es GSODR, que proporciona un resumen global de datos meteorológicos diarios en R (consulte el README del paquete para obtener una visión general de las fuentes de datos meteorológicos).\nCada paquete de datos tiene su propia sintaxis para acceder a los datos. Esta diversidad se demuestra en los siguientes trozos de código, que muestran cómo obtener datos utilizando tres paquetes de la tabla anterior.2. Las fronteras de los países suelen ser útiles y se puede acceder a ellas con la función ne_countries() del paquete rnaturalearth de la siguiente manera:\n\nlibrary(rnaturalearth)\nusa = ne_countries(country = \"United States of America\") # United States borders\nclass(usa)\n# alternative way of accessing the data, with geodata\n# geodata::gadm(\"USA\", level = 0, path = tempdir())\n## [1] \"SpatialPolygonsDataFrame\"\n## attr(,\"package\")\n## [1] \"sp\"\n\nPor defecto rnaturalearth devuelve objetos de la clase Spatial*. El resultado se puede convertir en un objeto sf con st_as_sf() de la siguiente manera:\n\nusa_sf = st_as_sf(usa)\n\nUn segundo ejemplo descarga una serie de rásters que contienen sumas mensuales globales de precipitación con una resolución espacial de diez minutos (~18,5 km en el ecuador) utilizando el paquete geodata. El resultado es un objeto multicapa de la clase SpatRaster.\n\nlibrary(geodata)\nworldclim_prec = worldclim_global(\"prec\", res = 10, path = tempdir())\nclass(worldclim_prec)\n\nUn tercer ejemplo utiliza el paquete osmdata para buscar parques en la base de datos OpenStreetMap (OSM). Como se ilustra en el fragmento de código siguiente, las consultas comienzan con la función opq() (abreviatura de OpenStreetMap query), cuyo primer argumento es bounding box, o cadena de texto que representa un bounding box (la ciudad de Leeds en este caso). El resultado se pasa a una función para seleccionar los elementos OSM que nos interesan (parques en este caso), representados por pares clave-valor. A continuación, se pasan a la función osmdata_sf() que hace el trabajo de descargar los datos y convertirlos en una lista de objetos sf (ver vignette('osmdata') para más detalles):\n\nlibrary(osmdata)\nparks = opq(bbox = \"leeds uk\") |&gt; \n  add_osm_feature(key = \"leisure\", value = \"park\") |&gt; \n  osmdata_sf()\n\nUna limitación del paquete osmdata es que no puede descargar grandes conjuntos de datos OSM (por ejemplo, todos los datos OSM de una gran ciudad). Para superar esta limitación, se desarrolló el paquete osmextract, que se puede utilizar para descargar e importar archivos binarios .pbf que contienen versiones comprimidas de la base de datos OSM para regiones predefinidas.\nOpenStreetMap es una vasta base de datos mundial de origen colectivo que crece día a día y cuenta con un amplio ecosistema de herramientas que facilitan el acceso a los datos, desde el servicio web Overpass turbo para desarrollar y probar rápidamente consultas OSM hasta osm2pgsql para importar los datos a una base de datos PostGIS. Aunque la calidad de los conjuntos de datos derivados de OSM varía, la fuente de datos y los ecosistemas OSM más amplios tienen muchas ventajas: proporcionan conjuntos de datos disponibles a nivel mundial, gratuitos y en constante mejora gracias a un ejército de voluntarios. El uso de OSM fomenta la “ciencia ciudadana” y las contribuciones al patrimonio digital (puedes empezar a editar datos que representen una parte del mundo que conozcas bien en www.openstreetmap.org).\nA veces, los paquetes vienen con conjuntos de datos incorporados. Se puede acceder a ellos de cuatro maneras: adjuntando el paquete (si el paquete utiliza “carga lenta” como spData), con data(dataset, package = mypackage), haciendo referencia al conjunto de datos con mypackage::dataset, o con system.file(filepath, package = mypackage) para acceder a los archivos de datos sin procesar. El siguiente fragmento de código ilustra las dos últimas opciones utilizando el conjunto de datos world (ya cargado adjuntando su paquete padre con library(spData)):\n\nworld2 = spData::world\nworld3 = read_sf(system.file(\"shapes/world.gpkg\", package = \"spData\"))\n\nEl último ejemplo, system.file(\"shapes/world.gpkg\", package = \"spData\"), devuelve una ruta al archivo world.gpkg, que se almacena dentro de la carpeta \"shapes/\" del paquete spData.\nOtra forma de obtener información espacial es realizar la geocodificación: transformar la descripción de una ubicación, normalmente una dirección, en sus coordenadas. Esto suele hacerse enviando una consulta a un servicio en línea y obteniendo la ubicación como resultado. Existen muchos servicios de este tipo que difieren en el método de geocodificación utilizado, las limitaciones de uso, los costes o los requisitos de clave API. R dispone de varios paquetes para geocodificación; sin embargo, tidygeocoder parece permitir conectar con el mayor número de servicios de geocodificación con una interfaz consistente. La función principal de tidygeocoder es geocode, que toma un marco de datos con direcciones y añade coordenadas como \"lat\" y \"long\". Esta función también permite seleccionar un servicio de geocodificación con el argumento method y tiene muchos parámetros adicionales.\nEl siguiente ejemplo busca las coordenadas de la placa azul de John Snow situada en un edificio del barrio londinense del Soho.\n\nlibrary(tidygeocoder)\ngeo_df = data.frame(address = \"54 Frith St, London W1D 4SJ, UK\")\ngeo_df = geocode(geo_df, address, method = \"osm\")\ngeo_df\n\nEl data.frame resultante puede convertirse en un objeto sf con st_as_sf().\n\ngeo_sf = st_as_sf(geo_df, coords = c(\"long\", \"lat\"), crs = \"EPSG:4326\")\n\nEste paquete también permite realizar el proceso inverso denominado geocodificación inversa utilizado para obtener un conjunto de información (nombre, dirección, etc.) a partir de un par de coordenadas."
  },
  {
    "objectID": "geo_input_output.html#servicios-web-geográficos",
    "href": "geo_input_output.html#servicios-web-geográficos",
    "title": "Entrada y salida de geo-datos",
    "section": "Servicios web geográficos",
    "text": "Servicios web geográficos\nEn un esfuerzo por estandarizar las API web para acceder a los datos espaciales, el Open Geospatial Consortium (OGC) ha creado una serie de especificaciones para los servicios web (conocidos colectivamente como OWS, que es la abreviatura de OGC Web Services). Estas especificaciones incluyen el Web Feature Service (WFS), el Web Map Service (WMS), el Web Map Tile Service (WMTS), el Web Coverage Service (WCS) e incluso un Web Processing Service (WPS). Servidores de mapas como PostGIS han adoptado estos protocolos, lo que ha llevado a la estandarización de las consultas. Al igual que otras API web, las API OWS utilizan una “URL base”, un “endpoint” y “argumentos de consulta URL” seguidos de un ? para solicitar datos (véase la viñeta best-practices-api-packages en el paquete httr).\nHay muchas peticiones que se pueden hacer a un servicio OWS. Una de las más fundamentales es getCapabilities, demostrada con las funciones httr GET() y modify_url() a continuación.\nEl fragmento de código muestra cómo pueden construirse y enviarse consultas API, en este caso para descubrir las capacidades de un servicio gestionado por la Organización de las Naciones Unidas para la Agricultura y la Alimentación (FAO):\n\nlibrary(httr)\nbase_url = \"http://www.fao.org\"\nendpoint = \"/figis/geoserver/wfs\"\nq = list(request = \"GetCapabilities\")\nres = GET(url = modify_url(base_url, path = endpoint), query = q)\nres$url\n## [1] \"https://www.fao.org/figis/geoserver/wfs?request=GetCapabilities\"\n\nEl fragmento de código anterior demuestra cómo se pueden construir programáticamente las peticiones API con la función GET(), que toma una URL base y una lista de parámetros de consulta que pueden ampliarse fácilmente. El resultado de la petición se guarda en res, un objeto de la clase response definido en el paquete httr, que es una lista que contiene información de la petición, incluyendo la URL. Como puede verse ejecutando browseURL(res$url), los resultados también pueden leerse directamente en un navegador. Una forma de extraer el contenido de la petición es la siguiente:\n\ntxt = content(res, \"text\")\nxml = xml2::read_xml(txt)\n\n\nxml\n#&gt; {xml_document} ...\n#&gt; [1] &lt;ows:ServiceIdentification&gt;\\n  &lt;ows:Title&gt;GeoServer WFS...\n#&gt; [2] &lt;ows:ServiceProvider&gt;\\n  &lt;ows:ProviderName&gt;UN-FAO Fishe...\n#&gt; ...\n\nLos datos pueden descargarse de los servicios WFS con la petición GetFeature y un typeName específico (como se ilustra en el fragmento de código siguiente).\nLos nombres disponibles varían en función del servicio de características web al que se acceda. Se pueden extraer mediante programación utilizando tecnologías web o desplazándose manualmente por el contenido de la salida GetCapabilities en un navegador.\n\nqf = list(request = \"GetFeature\", typeName = \"area:FAO_AREAS\")\nfile = tempfile(fileext = \".gml\")\nGET(url = base_url, path = endpoint, query = qf, write_disk(file))\nfao_areas = read_sf(file)\n\nNótese el uso de write_disk() para asegurar que los resultados se escriben en disco en lugar de cargarse en memoria, lo que permite importarlos con sf. Este ejemplo muestra cómo obtener acceso de bajo nivel a servicios web utilizando httr, que puede ser útil para entender cómo funcionan los servicios web. Para muchas tareas cotidianas, sin embargo, puede ser más apropiada una interfaz de más alto nivel, y se han desarrollado una serie de paquetes de R, y tutoriales, precisamente con este propósito. El paquete ows4R fue desarrollado para trabajar con servicios OWS."
  },
  {
    "objectID": "geo_input_output.html#formatos-de-archivo",
    "href": "geo_input_output.html#formatos-de-archivo",
    "title": "Entrada y salida de geo-datos",
    "section": "Formatos de archivo",
    "text": "Formatos de archivo\nLos conjuntos de datos geográficos suelen almacenarse como archivos o en bases de datos espaciales. Los formatos de archivo pueden almacenar datos vectoriales o ráster, mientras que las bases de datos espaciales como PostGIS pueden almacenar ambos. Hoy en día, la variedad de formatos de archivo puede parecer desconcertante, pero se ha producido una gran consolidación y estandarización desde los inicios del software SIG en la década de 1960, cuando se creó el primer programa de amplia distribución (SYMAP) para el análisis espacial en la Universidad de Harvard.\nGDAL (que debería pronunciarse “goo-dal”, con la doble “o” en referencia a la orientación a objetos), la Biblioteca de Abstracción de Datos Geoespaciales, ha resuelto muchos problemas relacionados con la incompatibilidad entre formatos de archivos geográficos desde su lanzamiento en 2000. GDAL proporciona una interfaz unificada y de alto rendimiento para la lectura y escritura de muchos formatos de datos ráster y vectoriales.3. Muchos programas SIG abiertos y propietarios, incluidos GRASS GIS, ArcGIS y QGIS, utilizan GDAL detrás de sus interfaces gráficas de usuario para realizar el trabajo de ingesta y escupir los datos geográficos en los formatos adecuados.\nGDAL proporciona acceso a más de 200 formatos de datos vectoriales y ráster. La siguiente tabla presenta información básica sobre los formatos de archivos espaciales seleccionados y utilizados con frecuencia.\n\n\n\nSelected spatial file formats.\n\nName\nExtension\nInfo\nType\nModel\n\n\n\nESRI Shapefile\n.shp (the main file)\nPopular format consisting of at least three files. No support for: files &gt; 2GB; mixed types; names &gt; 10 chars; cols &gt; 255.\nVector\nPartially open\n\n\nGeoJSON\n.geojson\nExtends the JSON exchange format by including a subset of the simple feature representation; mostly used for storing coordinates in longitude and latitude; it is extended by the TopoJSON format\nVector\nOpen\n\n\nKML\n.kml\nXML-based format for spatial visualization, developed for use with Google Earth. Zipped KML file forms the KMZ format.\nVector\nOpen\n\n\nGPX\n.gpx\nXML schema created for exchange of GPS data.\nVector\nOpen\n\n\nFlatGeobuf\n.fgb\nSingle file format allowing for quick reading and writing of vector data. Has streaming capabilities.\nVector\nOpen\n\n\nGeoTIFF\n.tif/.tiff\nPopular raster format. A TIFF file containing additional spatial metadata.\nRaster\nOpen\n\n\nArc ASCII\n.asc\nText format where the first six lines represent the raster header, followed by the raster cell values arranged in rows and columns.\nRaster\nOpen\n\n\nSQLite/SpatiaLite\n.sqlite\nStandalone relational database, SpatiaLite is the spatial extension of SQLite.\nVector and raster\nOpen\n\n\nESRI FileGDB\n.gdb\nSpatial and nonspatial objects created by ArcGIS. Allows: multiple feature classes; topology. Limited support from GDAL.\nVector and raster\nProprietary\n\n\nGeoPackage\n.gpkg\nLightweight database container based on SQLite allowing an easy and platform-independent exchange of geodata\nVector and (very limited) raster\nOpen\n\n\n\n\n\nLa fundación del Open Geospatial Consortium (OGC) en 1994 supuso un avance importante en la normalización y la apertura de los formatos de archivo. Además de definir el modelo de datos de características simples o simple features, el OGC también coordina el desarrollo de normas abiertas, por ejemplo, las utilizadas en formatos de archivo como KML y GeoPackage. Los formatos de archivo abiertos del tipo respaldado por el OGC tienen varias ventajas sobre los formatos propietarios: los estándares se publican, garantizan la transparencia y abren la posibilidad de que los usuarios sigan desarrollando y ajustando los formatos de archivo a sus necesidades específicas.\nESRI Shapefile es el formato de intercambio de datos vectoriales más popular; sin embargo, no es un formato abierto (aunque su especificación sí lo es). Se desarrolló a principios de la década de 1990 y tiene una serie de limitaciones. En primer lugar, es un formato multiarchivo, que consta de al menos tres archivos. Sólo admite 255 columnas, los nombres de las columnas están restringidos a diez caracteres y el límite de tamaño de los archivos es de 2 GB. Además, ESRI Shapefile no admite todos los tipos de geometría posibles, por ejemplo, no es capaz de distinguir entre un polígono y un multipolígono.4 A pesar de estas limitaciones, hacía tiempo que se echaba en falta una alternativa viable. Mientras tanto, surgió GeoPackage, y parece ser un candidato más que adecuado para sustituir a ESRI Shapefile. Geopackage es un formato de intercambio de información geoespacial y una norma OGC. La norma GeoPackage describe las reglas para almacenar información geoespacial en un pequeño contenedor SQLite. Por lo tanto, GeoPackage es un contenedor de base de datos espacial ligero, que permite almacenar datos vectoriales y ráster, pero también datos no espaciales y extensiones. Aparte de GeoPackage, hay otros formatos de intercambio de datos geoespaciales que merece la pena consultar.\nEl formato GeoTIFF parece ser el formato de datos ráster más destacado. Permite incrustar información espacial, como CRS, en un archivo TIFF. Al igual que ESRI Shapefile, este formato se desarrolló por primera vez en los años 90, pero como formato abierto. Además, GeoTIFF sigue ampliándose y mejorándose. Una de las recientes incorporaciones más significativas al formato GeoTIFF es su variante denominada COG (Cloud Optimized GeoTIFF). Los objetos ráster guardados como COG pueden alojarse en servidores HTTP, de modo que otras personas puedan leer sólo partes del archivo sin descargarlo entero.\nAdemás, se están desarrollando nuevos formatos de datos espaciales (por ejemplo, GeoParquet y Zarr) y se están mejorando los existentes. Si necesita más información sobre otros formatos, le recomendamos que lea la documentación de GDAL sobre los controladores vector y raster. Además, algunos formatos de datos espaciales pueden almacenar otros modelos (tipos) de datos que no sean vectoriales o ráster. Entre ellos se incluyen los formatos LAS y LAZ para almacenar nubes de puntos lidar, y NetCDF y HDF para almacenar matrices multidimensionales.\nLos datos espaciales también suelen almacenarse en formatos de texto tabulares (no espaciales), como archivos CSV u hojas de cálculo Excel. Por ejemplo, esto puede ser conveniente para compartir muestras espaciales con personas que no utilizan herramientas SIG o intercambiar datos con otro software que no acepte formatos de datos espaciales. Sin embargo, este enfoque tiene varios posibles problemas: es bastante complicado para almacenar geometrías más complejas que los POINT y no almacena directamente información sobre los CRS."
  },
  {
    "objectID": "geo_input_output.html#entrada-de-datos-i",
    "href": "geo_input_output.html#entrada-de-datos-i",
    "title": "Entrada y salida de geo-datos",
    "section": "Entrada de datos (I)",
    "text": "Entrada de datos (I)\nLa ejecución de comandos como sf::read_sf() (la función principal que utilizamos para cargar datos vectoriales) o terra::rast() (la función principal utilizada para cargar datos raster) desencadena silenciosamente una cadena de eventos que lee datos de archivos. Además, existen muchos paquetes de R que contienen una amplia gama de datos geográficos o que proporcionan un acceso sencillo a distintas fuentes de datos. Todos ellos cargan los datos en R o, más exactamente, asignan objetos a su espacio de trabajo, almacenados en RAM accesible desde el .GlobalEnv de la sesión de R.\nVector data\nLos datos vectoriales espaciales vienen en una amplia variedad de formatos de archivo. Las representaciones más populares, como los archivos .geojson y .gpkg se pueden importar directamente en R con la función sf read_sf() (o la equivalente st_read()), que utiliza los controladores vectoriales de GDAL entre bastidores. st_drivers() devuelve un marco de datos que contiene name y long_name en las dos primeras columnas, y las características de cada controlador disponible para GDAL (y por lo tanto sf), incluyendo la capacidad de escribir datos y almacenar datos raster en las columnas siguientes, como se ilustra para los formatos de archivo clave en la Tabla (tab:drivers).\nLos siguientes comandos muestran los tres primeros controladores de los que informa la instalación de GDAL del ordenador (los resultados pueden variar en función de la versión de GDAL instalada) y un resumen de sus características. Nótese que la mayoría de los drivers pueden escribir datos (51 de 87) mientras que sólo 16 formatos pueden representar eficientemente datos raster además de datos vectoriales (ver ?st_drivers() para más detalles):\n\nsf_drivers = st_drivers()\nhead(sf_drivers, n = 3)\nsummary(sf_drivers[-c(1:2)])\n\n\n\n\nPopular drivers/formats for reading/writing vector data.\n\nname\nlong_name\nwrite\ncopy\nis_raster\nis_vector\nvsi\n\n\n\nESRI Shapefile\nESRI Shapefile\nTRUE\nFALSE\nFALSE\nTRUE\nTRUE\n\n\nGPX\nGPX\nTRUE\nFALSE\nFALSE\nTRUE\nTRUE\n\n\nKML\nKeyhole Markup Language (KML)\nTRUE\nFALSE\nFALSE\nTRUE\nTRUE\n\n\nGeoJSON\nGeoJSON\nTRUE\nFALSE\nFALSE\nTRUE\nTRUE\n\n\nGPKG\nGeoPackage\nTRUE\nTRUE\nTRUE\nTRUE\nTRUE\n\n\nFlatGeobuf\nFlatGeobuf\nTRUE\nFALSE\nFALSE\nTRUE\nTRUE\n\n\n\n\n\nEl primer argumento de read_sf() es dsn, que debe ser una cadena de texto o un objeto que contenga una única cadena de texto. El contenido de una cadena de texto puede variar entre diferentes controladores. En la mayoría de los casos, como con el ESRI Shapefile (.shp) o el formato GeoPackageindex{GeoPackage} (.gpkg), el dsn sería un nombre de archivo. read_sf() adivina el controlador basado en la extensión del archivo, como se ilustra para un archivo .gpkg a continuación:\n\nf = system.file(\"shapes/world.gpkg\", package = \"spData\")\nworld = read_sf(f, quiet = TRUE)\n\nPara algunos controladores, dsn podría proporcionarse como un nombre de carpeta, credenciales de acceso a una base de datos, o una representación de cadena GeoJSON (ver los ejemplos de la página de ayuda read_sf() para más detalles).\nAlgunos formatos de controladores vectoriales pueden almacenar múltiples capas de datos. Por defecto, read_sf() lee automáticamente la primera capa del archivo especificado en dsn; sin embargo, utilizando el argumento layer se puede especificar cualquier otra capa.\nLa función read_sf() también permite leer sólo partes del fichero en la RAM con dos mecanismos posibles. El primero está relacionado con el argumento query, que permite especificar qué parte de los datos leer con el texto de consulta OGR SQL. En el ejemplo siguiente se extraen los datos de Tanzania únicamente. Se hace especificando que queremos obtener todas las columnas (SELECT *) de la capa \"world\" para las que el name_long es igual a \"Tanzania\":\n\ntanzania = read_sf(f, query = 'SELECT * FROM world WHERE name_long = \"Tanzania\"')\n\nSi no conoce los nombres de las columnas disponibles, un buen método consiste en leer simplemente una fila de los datos con 'SELECT * FROM world WHERE FID = 1'. El FID representa un ID de característica – la mayoría de las veces, es un número de fila; sin embargo, sus valores dependen del formato de fichero utilizado. Por ejemplo, FID empieza por 0 en ESRI Shapefile, por 1 en algunos otros formatos de archivo, o incluso puede ser arbitrario.\nEl segundo mecanismo utiliza el argumento wkt_filter. Este argumento espera un texto conocido que representa el área de estudio de la que queremos extraer los datos. Intentémoslo con un pequeño ejemplo: queremos leer los polígonos de nuestro archivo que se cruzan con el buffer de 50.000 metros de las fronteras de Tanzania. Para ello, tenemos que preparar nuestro “filtro” (a) creando el buffer, (b) convirtiendo el objeto buffer sf en un objeto geométrico sfc con st_geometry(), y (c) traduciendo las geometrías a su conocida representación de texto con st_as_text():\n\ntanzania_buf = st_buffer(tanzania, 50000)\ntanzania_buf_geom = st_geometry(tanzania_buf)\ntanzania_buf_wkt = st_as_text(tanzania_buf_geom)\n\nAhora, podemos aplicar este “filtro” usando el argumento wkt_filter.\n\ntanzania_neigh = read_sf(f, wkt_filter = tanzania_buf_wkt)\n\nNuestro resultado contiene Tanzania y todos los países que se encuentran dentro de su buffer de 50 km.\n\n\n\n\nReading a subset of the vector data using a query (A) and a wkt filter (B).\n\n\n\nNaturalmente, algunas opciones son específicas de determinados controladores.5 Por ejemplo, pensemos en coordenadas almacenadas en un formato de hoja de cálculo (.csv). Para leer estos archivos como objetos espaciales, naturalmente tenemos que especificar los nombres de las columnas (X y Y en nuestro ejemplo de abajo) que representan las coordenadas. Podemos hacerlo con la ayuda del parámetro options. Para conocer las posibles opciones, consulte la sección Opciones abiertas de la descripción del controlador GDAL correspondiente. Para el formato de valores separados por comas (csv), visite http://www.gdal.org/drv_csv.html.\n\ncycle_hire_txt = system.file(\"misc/cycle_hire_xy.csv\", package = \"spData\")\ncycle_hire_xy = read_sf(cycle_hire_txt,\n  options = c(\"X_POSSIBLE_NAMES=X\", \"Y_POSSIBLE_NAMES=Y\"))\n\nEn lugar de columnas que describan las coordenadas “XY”, una sola columna puede contener también la información geométrica. Los formatos de texto conocido (WKT), binario conocido (WKB) y GeoJSON son ejemplos de ello. Por ejemplo, el archivo world_wkt.csv tiene una columna llamada WKT que representa polígonos de los países del mundo. Una vez más, utilizaremos el parámetro options para indicarlo.\n\nworld_txt = system.file(\"misc/world_wkt.csv\", package = \"spData\")\nworld_wkt = read_sf(world_txt, options = \"GEOM_POSSIBLE_NAMES=WKT\")\n# the same as\nworld_wkt2 = st_read(world_txt, options = \"GEOM_POSSIBLE_NAMES=WKT\", \n                    quiet = TRUE, stringsAsFactors = FALSE, as_tibble = TRUE)\n\n\n\n\n\n\n\nNota\n\n\n\nNo todos los formatos de ficheros vectoriales soportados almacenan información sobre su sistema de referencia de coordenadas. En estas situaciones, es posible añadir la información que falta utilizando la función st_set_crs().\n\n\nComo ejemplo final, mostraremos cómo read_sf() también lee archivos KML. Un archivo KML almacena información geográfica en formato XML, un formato de datos para la creación de páginas web y la transferencia de datos de forma independiente de la aplicación. Aquí, accedemos a un archivo KML desde la web. Este archivo contiene más de una capa. st_layers() lista todas las capas disponibles. Elegimos la primera capa Placemarks y lo decimos con la ayuda del parámetro layer en read_sf().\n\nu = \"https://developers.google.com/kml/documentation/KML_Samples.kml\"\ndownload.file(u, \"KML_Samples.kml\")\nst_layers(\"KML_Samples.kml\")\nkml = read_sf(\"KML_Samples.kml\", layer = \"Placemarks\")\n## Driver: KML \n## Available layers:\n##              layer_name  geometry_type features fields crs_name\n## 1            Placemarks       3D Point        3      2   WGS 84\n## 2      Highlighted Icon       3D Point        1      2   WGS 84\n## 3                 Paths 3D Line String        6      2   WGS 84\n## 4         Google Campus     3D Polygon        4      2   WGS 84\n## 5      Extruded Polygon     3D Polygon        1      2   WGS 84\n## 6 Absolute and Relative     3D Polygon        4      2   WGS 84\n\nTodos los ejemplos presentados hasta ahora en esta sección han utilizado el paquete sf para la importación de datos geográficos. Es rápido y flexible, pero puede merecer la pena buscar otros paquetes para formatos de archivo específicos. Un ejemplo es el paquete geojsonsf. Un benchmark sugiere que es unas 10 veces más rápido que el paquete sf para leer .geojson.\nDatos raster\nAl igual que los datos vectoriales, los datos raster vienen en muchos formatos de archivo, algunos de los cuales soportan archivos multicapa. El comando rast() de terra lee una sola capa cuando se proporciona un archivo con una sola capa.\n\nraster_filepath = system.file(\"raster/srtm.tif\", package = \"spDataLarge\")\nsingle_layer = rast(raster_filepath)\n\nTambién funciona en caso de que quieras leer un fichero multicapa.\n\nmultilayer_filepath = system.file(\"raster/landsat.tif\", package = \"spDataLarge\")\nmultilayer_rast = rast(multilayer_filepath)\n\nTodos los ejemplos anteriores leen información espacial de archivos almacenados en su disco duro. Sin embargo, GDAL también permite leer datos directamente de recursos en línea, como recursos web HTTP/HTTPS/FTP. Lo único que tenemos que hacer es añadir un prefijo /vsicurl/ antes de la ruta al fichero. Vamos a probarlo conectándonos a la probabilidad de nieve mensual global a 500 m de resolución para el periodo 2000-2012. La probabilidad de nieve para diciembre se almacena como archivo COG (Cloud Optimized GeoTIFF) en . Para leer un archivo en línea, basta con proporcionar su URL junto con el prefijo /vsicurl/.\n\nmyurl = \"/vsicurl/https://zenodo.org/record/5774954/files/clm_snow.prob_esacci.dec_p.90_500m_s0..0cm_2000..2012_v2.0.tif\"\nsnow = rast(myurl)\nsnow\n## class       : SpatRaster \n## dimensions  : 35849, 86400, 1  (nrow, ncol, nlyr)\n## resolution  : 0.004166667, 0.004166667  (x, y)\n## extent      : -180, 180, -62.00083, 87.37  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source      : clm_snow.prob_esacci.dec_p.90_500m_s0..0cm_2000..2012_v2.0.tif \n## name        : clm_snow.prob_esacci.dec_p.90_500m_s0..0cm_2000..2012_v2.0\n\nDebido a que los datos de entrada son COG, en realidad no estamos leyendo este fichero en nuestra RAM, sino creando una conexión con él sin obtener ningún valor. Sus valores serán leídos si aplicamos cualquier operación basada en valores (por ejemplo, crop() o extract()). Esto nos permite también leer sólo una pequeña porción de los datos sin descargar todo el fichero. Por ejemplo, podemos obtener la probabilidad de nieve para diciembre en Reikiavik (70%) especificando sus coordenadas y aplicando la función extract():\n\nrey = data.frame(lon = -21.94, lat = 64.15)\nsnow_rey = extract(snow, rey)\nsnow_rey\n\n\n\n\n\n\nID\n\n\nclm_snow.prob_esacci.dec_p.90_500m_s0..0cm_2000..2012_v2.0\n\n\n\n\n1\n\n\n70\n\n\n\n\n\n\nDe esta forma, sólo descargamos un único valor en lugar de todo el archivo GeoTIFF de gran tamaño.\nEl ejemplo anterior sólo muestra un caso sencillo (pero útil), pero hay más por explorar. El prefijo /vsicurl/ también funciona no sólo para los formatos de archivo raster, sino también para los vectoriales. Permite leer vectores directamente desde el almacenamiento en línea con read_sf() simplemente añadiendo el prefijo antes de la URL del archivo vectorial.\nEs importante destacar que /vsicurl/ no es el único prefijo proporcionado por GDAL; existen muchos más, como /vsizip/ para leer archivos espaciales de archivos ZIP sin descomprimirlos previamente o /vsis3/ para leer sobre la marcha archivos disponibles en cubos S3 de AWS. Puede obtener más información en https://gdal.org/user/virtual_file_systems.html."
  },
  {
    "objectID": "geo_input_output.html#salida-de-datos-o",
    "href": "geo_input_output.html#salida-de-datos-o",
    "title": "Entrada y salida de geo-datos",
    "section": "Salida de datos (O)",
    "text": "Salida de datos (O)\nLa escritura de datos geográficos permite convertir de un formato a otro y guardar objetos recién creados. Dependiendo del tipo de datos (vector o raster), clase de objeto (por ejemplo, sf o SpatRaster), y tipo y cantidad de información almacenada (por ejemplo, tamaño del objeto, rango de valores), es importante saber cómo almacenar archivos espaciales de la manera más eficiente. En las dos secciones siguientes se muestra cómo hacerlo.\nVector data\nLa contrapartida de read_sf() es write_sf(). Permite escribir objetos sf en una amplia gama de formatos de archivos vectoriales geográficos, incluidos los más comunes como .geojson, .shp y .gpkg. Basándose en el nombre del archivo, write_sf() decide automáticamente qué controlador utilizar. La velocidad del proceso de escritura depende también del controlador.\n\nwrite_sf(obj = world, dsn = \"world.gpkg\")\n\nNota: si intentas escribir de nuevo en la misma fuente de datos, la función sobrescribirá el fichero:\n\nwrite_sf(obj = world, dsn = \"world.gpkg\")\n\nEn lugar de sobrescribir el archivo, podríamos añadir una nueva capa al archivo con append = TRUE, que es soportado por varios formatos espaciales, incluyendo GeoPackage.\n\nwrite_sf(obj = world, dsn = \"world_many_layers.gpkg\", append = TRUE)\n\nAlternativamente, puede usar st_write() ya que es equivalente a write_sf(). Sin embargo, tiene diferentes valores por defecto – no sobrescribe archivos (devuelve un error cuando intenta hacerlo) y muestra un breve resumen del formato del archivo escrito y el objeto.\n\nst_write(obj = world, dsn = \"world2.gpkg\")\n## Writing layer `world2' to data source `world2.gpkg' using driver `GPKG'\n## Writing 177 features with 10 fields and geometry type Multi Polygon.\n\nEl argumento layer_options también se puede utilizar para muchos propósitos diferentes. Uno de ellos es escribir datos espaciales en un fichero de texto. Esto puede hacerse especificando GEOMETRY dentro de layer_options. Puede ser AS_XY para conjuntos de datos de puntos simples (crea dos nuevas columnas para las coordenadas) o AS_WKT para datos espaciales más complejos (se crea una nueva columna que contiene la conocida representación textual de los objetos espaciales).\n\nwrite_sf(cycle_hire_xy, \"cycle_hire_xy.csv\", layer_options = \"GEOMETRY=AS_XY\")\nwrite_sf(world_wkt, \"world_wkt.csv\", layer_options = \"GEOMETRY=AS_WKT\")\n\nDatos Raster\nLa función writeRaster() guarda objetos SpatRaster en archivos de disco. La función espera información sobre el tipo de datos de salida y el formato de archivo, pero también acepta opciones de GDAL específicas para el formato de archivo seleccionado (véase ?writeRaster para más detalles).\nEl paquete terra ofrece siete tipos de datos a la hora de guardar una trama: INT1U, INT2S, INT2U, INT4S, INT4U, FLT4S, y FLT8S.6 El tipo de datos determina la representación en bits del objeto ráster escrito en el disco. El tipo de datos a utilizar depende del rango de valores del objeto raster. Cuantos más valores pueda representar un tipo de datos, más grande será el archivo en disco. Los enteros sin signo (INT1U, INT2U, INT4U) son adecuados para datos categóricos, mientras que los números flotantes (FLT4S y FLT8S) suelen representar datos continuos. writeRaster() utiliza FLT4S por defecto. Aunque esto funciona en la mayoría de los casos, el tamaño del fichero de salida será innecesariamente grande si guarda datos binarios o categóricos. Por lo tanto, recomendamos utilizar el tipo de datos que necesite menos espacio de almacenamiento, pero que sea capaz de representar todos los valores (compruebe el rango de valores con la función summary()).\n\n\n\nData types supported by the terra package.\n\nData type\nMinimum value\nMaximum value\n\n\n\nINT1U\n0\n255\n\n\nINT2S\n-32,767\n32,767\n\n\nINT2U\n0\n65,534\n\n\nINT4S\n-2,147,483,647\n2,147,483,647\n\n\nINT4U\n0\n4,294,967,296\n\n\nFLT4S\n-3.4e+38\n3.4e+38\n\n\nFLT8S\n-1.7e+308\n1.7e+308\n\n\n\n\n\nPor defecto, el formato del archivo de salida se deriva del nombre del archivo. Al nombrar un archivo *.tif se creará un archivo GeoTIFF, como se muestra a continuación:\n\nwriteRaster(single_layer, filename = \"my_raster.tif\", datatype = \"INT2U\")\n\nAlgunos formatos de archivo ráster tienen opciones adicionales, que pueden establecerse proporcionando parámetros GDAL al argumento options de writeRaster(). Los archivos GeoTIFF se escriben en terra, por defecto, con la compresión LZW gdal = c(\"COMPRESS=LZW\"). Para cambiar o desactivar la compresión, necesitamos modificar este argumento.\n\nwriteRaster(x = single_layer, filename = \"my_raster.tif\",\n            gdal = c(\"COMPRESS=NONE\"), overwrite = TRUE)\n\nAdemás, podemos guardar nuestro objeto raster como COG (Cloud Optimized GeoTIFF) con las opciones filetype = \"COG\".\n\nwriteRaster(x = single_layer, filename = \"my_raster.tif\",\n            filetype = \"COG\", overwrite = TRUE)"
  },
  {
    "objectID": "geo_input_output.html#resultados-visuales",
    "href": "geo_input_output.html#resultados-visuales",
    "title": "Entrada y salida de geo-datos",
    "section": "Resultados visuales",
    "text": "Resultados visuales\nR soporta muchos formatos diferentes de gráficos estáticos e interactivos. El método más general para guardar un gráfico estático es abrir un dispositivo gráfico, crear un gráfico y cerrarlo, por ejemplo:\n\npng(filename = \"lifeExp.png\", width = 500, height = 350)\nplot( world[\"lifeExp\"])\ndev.off()\n\nOtros dispositivos gráficos disponibles son pdf(), bmp(), jpeg() y tiff(). Puede especificar varias propiedades del gráfico de salida, como la anchura, la altura y la resolución.\nAdemás, varios paquetes gráficos proporcionan sus propias funciones para guardar una salida gráfica. Por ejemplo, el paquete tmap tiene la función tmap_save(). Puede guardar un objeto tmap en diferentes formatos gráficos o en un archivo HTML especificando el nombre del objeto y una ruta a un nuevo archivo.\n\nlibrary(tmap)\ntmap_obj = tm_shape(world) + tm_polygons(col = \"lifeExp\")\ntmap_save(tmap_obj, filename = \"lifeExp_tmap.png\")\n\nPor otra parte, puede guardar los mapas interactivos creados en el paquete mapview como un archivo HTML o una imagen utilizando la función mapshot():\n\nlibrary(mapview)\nmapview_obj = mapview(world, zcol = \"lifeExp\", legend = TRUE)\nmapshot(mapview_obj, file = \"my_interactive_map.html\")"
  },
  {
    "objectID": "geo_input_output.html#footnotes",
    "href": "geo_input_output.html#footnotes",
    "title": "Entrada y salida de geo-datos",
    "section": "Notas",
    "text": "Notas\n\nPor ejemplo, visite https://freegisdata.rtwilson.com/ para consultar una lista de sitios web con conjuntos de datos geográficos de libre acceso↩︎\nEn https://rspatialdata.github.io/ se pueden encontrar más ejemplos de descarga de datos utilizando paquetes R dedicados↩︎\nGDAL también contiene un conjunto de funciones de utilidad que permiten la creación de mosaicos ráster, el remuestreo, el recorte y la reproyección, etc.↩︎\nPara obtener más información sobre las limitaciones de ESRI Shapefile y posibles formatos de archivo alternativos, visite http://switchfromshapefile.org/.↩︎\n Puede encontrar una lista de los formatos vectoriales y opciones compatibles en http://gdal.org/ogr_formats.html.↩︎\n No se recomienda usar INT4U ya que R no soporta enteros sin signo de 32 bits.↩︎"
  },
  {
    "objectID": "datos_espaciales_en_R.html",
    "href": "datos_espaciales_en_R.html",
    "title": "Datos espaciales en R",
    "section": "",
    "text": "Para esta fugaz intro a los datos espaciales en R, vamos a usar el libro “Geocomputation with R” que puede consultarse online aquí: https://r.geocompx.org/. Vamos a ir siguiendo algunos ejemplos del libro y quien desee conocer más detalles, puede consultarlos directamente allí o en los materiales que los autores mencionan.\nEn esta clase vamos a ver los conceptos básicos sobre los tipos fundamentales de datos geográficos: vector y raster. Veremos cómo están implementados en R, y ejemplificaremos algunas de las tareas más comunes que podemos realizar con cada uno de ellos.\nEl modelo de datos vectoriales representa el mundo mediante puntos, líneas y polígonos. Éstos tienen bordes discretos y bien definidos, lo que significa que los conjuntos de datos vectoriales suelen ser muy precisos (aunque no necesariamente exactos). El modelo de datos ráster divide la superficie en celdas de tamaño constante, generalmente. Los datos ráster agregan características a una resolución determinada, lo que significa que son coherentes en el espacio y escalables.\n\n\n\n\n\n\nNota\n\n\n\n¿Cuál utilizar? La respuesta depende probablemente de su ámbito de aplicación:\n\nLos datos vectoriales tienden a dominar las ciencias sociales porque los asentamientos humanos tienden a tener fronteras discretas\nLos datos rasterizados predominan en muchas ciencias medioambientales por su dependencia de los datos de teledetección.\n\n\n\n\nEl modelo de datos vectoriales geográficos se basa en puntos situados dentro de un sistema de referencia de coordenadas (CRS). Los puntos pueden representar características autónomas (por ejemplo, la ubicación de una parada de autobús) o pueden unirse para formar geometrías más complejas, como líneas y polígonos.\n\nEl paquete sf nos permite trabajar con datos vectoriales en R. Simple Features es un estándar abierto desarrollado y aprobado por el Open Geospatial Consortium (OGC). Simple Features es un modelo de datos jerárquico que representa una amplia gama de tipos de geometría. sf puede representar todos los tipos de geometría vectorial habituales (sf no admite clases de datos ráster): puntos, líneas, polígonos y sus respectivas versiones “multi” (que agrupan características del mismo tipo en una única característica). sf también admite colecciones de geometría, que pueden contener múltiples tipos de geometría en un único objeto. Simple features es un modelo de datos ampliamente soportado que subyace en las estructuras de datos de muchas aplicaciones SIG, incluyendo QGIS y PostGIS.\nLa funcionalidad de sf está bien documentada en su sitio web https://r-spatial.github.io/sf/, que contiene 7 viñetas. Estas se pueden ver de la siguiente manera:\n\n#vignette(package = \"sf\") # see which vignettes are available\n#vignette(\"sf1\")          # an introduction to the package\n\n\nLos objetos feature simples en R se almacenan en un data.frame (tabla de datos), con los datos geográficos ocupando una columna especial, normalmente llamada ‘geom’ o ‘geometry’. Utilizaremos el conjunto de datos world proporcionado por spData para mostrar qué son los objetos sf y cómo funcionan.\n\nclass(world)\nnames(world)\nhead(world)\n## [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n##  [1] \"iso_a2\"    \"name_long\" \"continent\" \"region_un\" \"subregion\" \"type\"     \n##  [7] \"area_km2\"  \"pop\"       \"lifeExp\"   \"gdpPercap\" \"geom\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\niso_a2\nname_long\ncontinent\nregion_un\nsubregion\ntype\narea_km2\npop\nlifeExp\ngdpPercap\ngeom\n\n\n\nFJ\nFiji\nOceania\nOceania\nMelanesia\nSovereign country\n19289.97\n885806\n69.96000\n8222.254\nMULTIPOLYGON (((-180 -16.55…\n\n\nTZ\nTanzania\nAfrica\nAfrica\nEastern Africa\nSovereign country\n932745.79\n52234869\n64.16300\n2402.099\nMULTIPOLYGON (((33.90371 -0…\n\n\nEH\nWestern Sahara\nAfrica\nAfrica\nNorthern Africa\nIndeterminate\n96270.60\nNA\nNA\nNA\nMULTIPOLYGON (((-8.66559 27…\n\n\nCA\nCanada\nNorth America\nAmericas\nNorthern America\nSovereign country\n10036042.98\n35535348\n81.95305\n43079.143\nMULTIPOLYGON (((-132.71 54….\n\n\nUS\nUnited States\nNorth America\nAmericas\nNorthern America\nCountry\n9510743.74\n318622525\n78.84146\n51921.985\nMULTIPOLYGON (((-171.7317 6…\n\n\nKZ\nKazakhstan\nAsia\nAsia\nCentral Asia\nSovereign country\n2729810.51\n17288285\n71.62000\n23587.338\nMULTIPOLYGON (((87.35997 49…\n\n\n\n\n\n\nEl contenido de esta columna geom es la que confiere a los objetos sf sus poderes espaciales: world$geom es una “columna lista” de la clase sfc que contiene todas las coordenadas de los polígonos de los países. Los objetos sf pueden visualizarse rápidamente con la función plot()\n\nplot(world)\n\n\n\n\nPodemos obtener info de los atributos (columnas) de los objetos sf, como se hace con cualquier data.frame:\n\nsummary(world[\"lifeExp\"])\n##     lifeExp                 geom    \n##  Min.   :50.62   MULTIPOLYGON :177  \n##  1st Qu.:64.96   epsg:4326    :  0  \n##  Median :72.87   +proj=long...:  0  \n##  Mean   :70.85                      \n##  3rd Qu.:76.78                      \n##  Max.   :83.59                      \n##  NA's   :10\n\nLos objetos sf son fáciles de subdividir. Por ejemplo, podemos recortar sólo las dos primeras filas y las tres primeras columnas del objeto world.\n\nworld_mini = world[1:2, 1:3]\nplot(world_mini)\n\n\n\n\nTambién podemos subdividir por columnas únicamente, ya sea con su índice o el nombre\n\nplot(world[3:6])\n\n\n\nplot(world[\"pop\"])\n\n\n\n\nPodemos hacer selecciones\n\nworld_asia = world[world$continent == \"Asia\", ]\nasia = st_union(world_asia)\n\ny añadir capas a las imágenes existentes estableciendo add = TRUE\n\nplot(world[\"pop\"], reset = FALSE)\nplot(asia, col = \"red\", add = TRUE)\n\n\n\n\nHay varias formas de modificar los mapas con el método plot() de sf. Por ejemplo, se pueden superponer círculos, cuyos diámetros (fijados con cex =) representan poblaciones de países, en un mapa del mundo.\n\nplot(world[\"continent\"], reset = FALSE)\ncex = sqrt(world$pop) / 10000\nworld_cents = st_centroid(world, of_largest = TRUE)\nplot(st_geometry(world_cents), add = TRUE, cex = cex)\n\n\n\n\n\nLas geometrías son los componentes básicos de los objetos sf y pueden adoptar uno de los 18 tipos de geometría que admite el paquete sf. Los siete tipos más utilizados son: PUNTO, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON y GEOMETRYCOLLECTION.\nPor lo general, el usuario se ahorra la tediosa tarea de crear geometrías por su cuenta, ya que puede simplemente importar un archivo espacial ya existente. Sin embargo, existe un conjunto de funciones para crear objetos geométricos de características simples (sfg) desde cero si es necesario. Los nombres de estas funciones son sencillos, todas comienzan con el prefijo st_ y terminan con el nombre del tipo de geometría:\n\nUn punto: st_point()\n\nUna cadena de líneas: st_linestring()\n\nUn polígono: st_polygon()\n\nUn multipunto: st_multipoint()\n\nUna multilínea: st_multilínea()\n\nUn multipolígono: st_multipolygon()\n\nUna colección de geometrías: st_geometrycollection()\n\n\nLos objetos sfg pueden crearse a partir de tres tipos de datos R básicos:\n\nUn vector numérico: un único punto\nUna matriz: un conjunto de puntos, donde cada fila representa un punto, un multipunto o una cadena de líneas\nUna lista: una colección de objetos como matrices, multilíneas o colecciones de geometría.\n\nEl modelo de datos espaciales ráster representa el mundo con la cuadrícula continua de celdas (a menudo también llamadas píxeles). Este modelo de datos se refiere a menudo a las denominadas cuadrículas regulares, en las que cada celda tiene el mismo tamaño constante.\nEl modelo de datos ráster suele constar de una cabecera ráster y una matriz (con filas y columnas) que representa celdas equidistantes (a menudo también denominadas píxeles). La cabecera ráster define el sistema de referencia de coordenadas, la extensión y el origen. El origen (o punto de partida) suele ser la coordenada de la esquina inferior izquierda de la matriz (el paquete terra, sin embargo, utiliza por defecto la esquina superior izquierda). La cabecera define la extensión mediante el número de columnas, el número de filas y la resolución del tamaño de las celdas. De este modo, partiendo del origen, podemos acceder fácilmente a cada celda y modificarla, ya sea utilizando el ID de una celda o especificando explícitamente las filas y columnas. Esta representación matricial evita almacenar explícitamente las coordenadas de los cuatro puntos de esquina (de hecho, sólo almacena una coordenada, el origen) de cada esquina de celda, como ocurriría en el caso de los polígonos vectoriales rectangulares. Sin embargo, a diferencia de los datos vectoriales, la celda de una capa raster sólo puede contener un único valor. El valor puede ser numérico o categórico.\n\nLos mapas raster suelen representar fenómenos continuos como la elevación, la temperatura, la densidad de población o datos espectrales. En el modelo de datos raster también pueden representarse características discretas, como clases de suelo o de cubierta terrestre.\n\n\nEn las dos últimas décadas, se han desarrollado varios paquetes para leer y procesar conjuntos de datos raster. El principal de ellos fue raster, que supuso un cambio radical en las capacidades raster de R cuando se lanzó en 2010 y se convirtió en el principal paquete en este ámbito hasta el desarrollo de terra y stars. Estos últimos, desarrollados más recientemente, ofrecen funciones potentes y eficaces para trabajar con conjuntos de datos ráster, y existe un solapamiento sustancial entre sus posibles casos de uso. Aquí nos vamos a centrar en el paquete terra.\n\nEl paquete terra soporta objetos raster en R. Al igual que su predecesor raster (creado por el mismo desarrollador, Robert Hijmans), proporciona un amplio conjunto de funciones para crear, leer, exportar, manipular y procesar conjuntos de datos raster. La funcionalidad de terra es en gran medida la misma que la del paquete raster, pero hay algunas diferencias: las funciones de terra suelen ser más eficientes computacionalmente. Puede traducir sin problemas entre los dos tipos de objetos para garantizar la compatibilidad con scripts y paquetes más antiguos, por ejemplo, con las funciones raster(), stack() y brick() en el paquete raster.\nAdemás de las funciones para la manipulación de datos ráster, terra proporciona muchas funciones de bajo nivel que pueden constituir una base para el desarrollo de nuevas herramientas para trabajar con conjuntos de datos ráster. terra también le permite trabajar con grandes conjuntos de datos ráster que son demasiado grandes para caber en la memoria principal. En este caso, terra ofrece la posibilidad de dividir el raster en trozos más pequeños, y procesarlos iterativamente en lugar de cargar todo el archivo raster en la RAM.\n\nraster_filepath = system.file(\"raster/srtm.tif\", package = \"spDataLarge\")\nmy_rast = rast(raster_filepath)\nclass(my_rast)\n## [1] \"SpatRaster\"\n## attr(,\"package\")\n## [1] \"terra\"\n\n\nmy_rast\n## class       : SpatRaster \n## dimensions  : 457, 465, 1  (nrow, ncol, nlyr)\n## resolution  : 0.0008333333, 0.0008333333  (x, y)\n## extent      : -113.2396, -112.8521, 37.13208, 37.51292  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source      : srtm.tif \n## name        : srtm \n## min value   : 1024 \n## max value   : 2892\n\n\nplot(my_rast)\n\n\n\n\nClases de datos raster\nEl paquete terra soporta numerosos controladores con la ayuda de la biblioteca GDAL. Por lo general, los rásters de los archivos no se leen completamente en la RAM, a excepción de su cabecera y un puntero al archivo.\n\nsingle_raster_file = system.file(\"raster/srtm.tif\", package = \"spDataLarge\")\nsingle_rast = rast(raster_filepath)\nsingle_rast\n## class       : SpatRaster \n## dimensions  : 457, 465, 1  (nrow, ncol, nlyr)\n## resolution  : 0.0008333333, 0.0008333333  (x, y)\n## extent      : -113.2396, -112.8521, 37.13208, 37.51292  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source      : srtm.tif \n## name        : srtm \n## min value   : 1024 \n## max value   : 2892\n\nLos rásters también pueden crearse desde cero utilizando la misma función rast().\n\nnew_raster = rast(nrows = 6, ncols = 6, \n                  xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n                  vals = 1:36)\nplot(new_raster)\n\n\n\n\nLa clase SpatRaster también puede manejar múltiples capas, por ejemplo, las bandas de un satélite multiespectral o una serie temporal de rásters.\n\nmulti_raster_file = system.file(\"raster/landsat.tif\", package = \"spDataLarge\")\nmulti_rast = rast(multi_raster_file)\nmulti_rast\n## class       : SpatRaster \n## dimensions  : 1428, 1128, 4  (nrow, ncol, nlyr)\n## resolution  : 30, 30  (x, y)\n## extent      : 301905, 335745, 4111245, 4154085  (xmin, xmax, ymin, ymax)\n## coord. ref. : WGS 84 / UTM zone 12N (EPSG:32612) \n## source      : landsat.tif \n## names       : landsat_1, landsat_2, landsat_3, landsat_4 \n## min values  :      7550,      6404,      5678,      5252 \n## max values  :     19071,     22051,     25780,     31961\n\n\nnlyr(multi_rast)\n## [1] 4\n\nLos rásters multicapa se pueden subdividir con el índice o el nombre de las capas deseadas:\n\nmulti_rast3 = subset(multi_rast, 3)\nmulti_rast4 = subset(multi_rast, \"landsat_4\")\n\nSe pueden combinar o concatenar con la función c():\n\nmulti_rast34 = c(multi_rast3, multi_rast4)\nplot(multi_rast34)"
  },
  {
    "objectID": "datos_espaciales_en_R.html#datos-vectoriales",
    "href": "datos_espaciales_en_R.html#datos-vectoriales",
    "title": "Datos espaciales en R",
    "section": "",
    "text": "El modelo de datos vectoriales geográficos se basa en puntos situados dentro de un sistema de referencia de coordenadas (CRS). Los puntos pueden representar características autónomas (por ejemplo, la ubicación de una parada de autobús) o pueden unirse para formar geometrías más complejas, como líneas y polígonos.\n\nEl paquete sf nos permite trabajar con datos vectoriales en R. Simple Features es un estándar abierto desarrollado y aprobado por el Open Geospatial Consortium (OGC). Simple Features es un modelo de datos jerárquico que representa una amplia gama de tipos de geometría. sf puede representar todos los tipos de geometría vectorial habituales (sf no admite clases de datos ráster): puntos, líneas, polígonos y sus respectivas versiones “multi” (que agrupan características del mismo tipo en una única característica). sf también admite colecciones de geometría, que pueden contener múltiples tipos de geometría en un único objeto. Simple features es un modelo de datos ampliamente soportado que subyace en las estructuras de datos de muchas aplicaciones SIG, incluyendo QGIS y PostGIS.\nLa funcionalidad de sf está bien documentada en su sitio web https://r-spatial.github.io/sf/, que contiene 7 viñetas. Estas se pueden ver de la siguiente manera:\n\n#vignette(package = \"sf\") # see which vignettes are available\n#vignette(\"sf1\")          # an introduction to the package\n\n\nLos objetos feature simples en R se almacenan en un data.frame (tabla de datos), con los datos geográficos ocupando una columna especial, normalmente llamada ‘geom’ o ‘geometry’. Utilizaremos el conjunto de datos world proporcionado por spData para mostrar qué son los objetos sf y cómo funcionan.\n\nclass(world)\nnames(world)\nhead(world)\n## [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n##  [1] \"iso_a2\"    \"name_long\" \"continent\" \"region_un\" \"subregion\" \"type\"     \n##  [7] \"area_km2\"  \"pop\"       \"lifeExp\"   \"gdpPercap\" \"geom\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\niso_a2\nname_long\ncontinent\nregion_un\nsubregion\ntype\narea_km2\npop\nlifeExp\ngdpPercap\ngeom\n\n\n\nFJ\nFiji\nOceania\nOceania\nMelanesia\nSovereign country\n19289.97\n885806\n69.96000\n8222.254\nMULTIPOLYGON (((-180 -16.55…\n\n\nTZ\nTanzania\nAfrica\nAfrica\nEastern Africa\nSovereign country\n932745.79\n52234869\n64.16300\n2402.099\nMULTIPOLYGON (((33.90371 -0…\n\n\nEH\nWestern Sahara\nAfrica\nAfrica\nNorthern Africa\nIndeterminate\n96270.60\nNA\nNA\nNA\nMULTIPOLYGON (((-8.66559 27…\n\n\nCA\nCanada\nNorth America\nAmericas\nNorthern America\nSovereign country\n10036042.98\n35535348\n81.95305\n43079.143\nMULTIPOLYGON (((-132.71 54….\n\n\nUS\nUnited States\nNorth America\nAmericas\nNorthern America\nCountry\n9510743.74\n318622525\n78.84146\n51921.985\nMULTIPOLYGON (((-171.7317 6…\n\n\nKZ\nKazakhstan\nAsia\nAsia\nCentral Asia\nSovereign country\n2729810.51\n17288285\n71.62000\n23587.338\nMULTIPOLYGON (((87.35997 49…\n\n\n\n\n\n\nEl contenido de esta columna geom es la que confiere a los objetos sf sus poderes espaciales: world$geom es una “columna lista” de la clase sfc que contiene todas las coordenadas de los polígonos de los países. Los objetos sf pueden visualizarse rápidamente con la función plot()\n\nplot(world)\n\n\n\n\nPodemos obtener info de los atributos (columnas) de los objetos sf, como se hace con cualquier data.frame:\n\nsummary(world[\"lifeExp\"])\n##     lifeExp                 geom    \n##  Min.   :50.62   MULTIPOLYGON :177  \n##  1st Qu.:64.96   epsg:4326    :  0  \n##  Median :72.87   +proj=long...:  0  \n##  Mean   :70.85                      \n##  3rd Qu.:76.78                      \n##  Max.   :83.59                      \n##  NA's   :10\n\nLos objetos sf son fáciles de subdividir. Por ejemplo, podemos recortar sólo las dos primeras filas y las tres primeras columnas del objeto world.\n\nworld_mini = world[1:2, 1:3]\nplot(world_mini)\n\n\n\n\nTambién podemos subdividir por columnas únicamente, ya sea con su índice o el nombre\n\nplot(world[3:6])\n\n\n\nplot(world[\"pop\"])\n\n\n\n\nPodemos hacer selecciones\n\nworld_asia = world[world$continent == \"Asia\", ]\nasia = st_union(world_asia)\n\ny añadir capas a las imágenes existentes estableciendo add = TRUE\n\nplot(world[\"pop\"], reset = FALSE)\nplot(asia, col = \"red\", add = TRUE)\n\n\n\n\nHay varias formas de modificar los mapas con el método plot() de sf. Por ejemplo, se pueden superponer círculos, cuyos diámetros (fijados con cex =) representan poblaciones de países, en un mapa del mundo.\n\nplot(world[\"continent\"], reset = FALSE)\ncex = sqrt(world$pop) / 10000\nworld_cents = st_centroid(world, of_largest = TRUE)\nplot(st_geometry(world_cents), add = TRUE, cex = cex)\n\n\n\n\n\nLas geometrías son los componentes básicos de los objetos sf y pueden adoptar uno de los 18 tipos de geometría que admite el paquete sf. Los siete tipos más utilizados son: PUNTO, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON y GEOMETRYCOLLECTION.\nPor lo general, el usuario se ahorra la tediosa tarea de crear geometrías por su cuenta, ya que puede simplemente importar un archivo espacial ya existente. Sin embargo, existe un conjunto de funciones para crear objetos geométricos de características simples (sfg) desde cero si es necesario. Los nombres de estas funciones son sencillos, todas comienzan con el prefijo st_ y terminan con el nombre del tipo de geometría:\n\nUn punto: st_point()\n\nUna cadena de líneas: st_linestring()\n\nUn polígono: st_polygon()\n\nUn multipunto: st_multipoint()\n\nUna multilínea: st_multilínea()\n\nUn multipolígono: st_multipolygon()\n\nUna colección de geometrías: st_geometrycollection()\n\n\nLos objetos sfg pueden crearse a partir de tres tipos de datos R básicos:\n\nUn vector numérico: un único punto\nUna matriz: un conjunto de puntos, donde cada fila representa un punto, un multipunto o una cadena de líneas\nUna lista: una colección de objetos como matrices, multilíneas o colecciones de geometría."
  },
  {
    "objectID": "datos_espaciales_en_R.html#datos-raster",
    "href": "datos_espaciales_en_R.html#datos-raster",
    "title": "Datos espaciales en R",
    "section": "",
    "text": "El modelo de datos espaciales ráster representa el mundo con la cuadrícula continua de celdas (a menudo también llamadas píxeles). Este modelo de datos se refiere a menudo a las denominadas cuadrículas regulares, en las que cada celda tiene el mismo tamaño constante.\nEl modelo de datos ráster suele constar de una cabecera ráster y una matriz (con filas y columnas) que representa celdas equidistantes (a menudo también denominadas píxeles). La cabecera ráster define el sistema de referencia de coordenadas, la extensión y el origen. El origen (o punto de partida) suele ser la coordenada de la esquina inferior izquierda de la matriz (el paquete terra, sin embargo, utiliza por defecto la esquina superior izquierda). La cabecera define la extensión mediante el número de columnas, el número de filas y la resolución del tamaño de las celdas. De este modo, partiendo del origen, podemos acceder fácilmente a cada celda y modificarla, ya sea utilizando el ID de una celda o especificando explícitamente las filas y columnas. Esta representación matricial evita almacenar explícitamente las coordenadas de los cuatro puntos de esquina (de hecho, sólo almacena una coordenada, el origen) de cada esquina de celda, como ocurriría en el caso de los polígonos vectoriales rectangulares. Sin embargo, a diferencia de los datos vectoriales, la celda de una capa raster sólo puede contener un único valor. El valor puede ser numérico o categórico.\n\nLos mapas raster suelen representar fenómenos continuos como la elevación, la temperatura, la densidad de población o datos espectrales. En el modelo de datos raster también pueden representarse características discretas, como clases de suelo o de cubierta terrestre.\n\n\nEn las dos últimas décadas, se han desarrollado varios paquetes para leer y procesar conjuntos de datos raster. El principal de ellos fue raster, que supuso un cambio radical en las capacidades raster de R cuando se lanzó en 2010 y se convirtió en el principal paquete en este ámbito hasta el desarrollo de terra y stars. Estos últimos, desarrollados más recientemente, ofrecen funciones potentes y eficaces para trabajar con conjuntos de datos ráster, y existe un solapamiento sustancial entre sus posibles casos de uso. Aquí nos vamos a centrar en el paquete terra.\n\nEl paquete terra soporta objetos raster en R. Al igual que su predecesor raster (creado por el mismo desarrollador, Robert Hijmans), proporciona un amplio conjunto de funciones para crear, leer, exportar, manipular y procesar conjuntos de datos raster. La funcionalidad de terra es en gran medida la misma que la del paquete raster, pero hay algunas diferencias: las funciones de terra suelen ser más eficientes computacionalmente. Puede traducir sin problemas entre los dos tipos de objetos para garantizar la compatibilidad con scripts y paquetes más antiguos, por ejemplo, con las funciones raster(), stack() y brick() en el paquete raster.\nAdemás de las funciones para la manipulación de datos ráster, terra proporciona muchas funciones de bajo nivel que pueden constituir una base para el desarrollo de nuevas herramientas para trabajar con conjuntos de datos ráster. terra también le permite trabajar con grandes conjuntos de datos ráster que son demasiado grandes para caber en la memoria principal. En este caso, terra ofrece la posibilidad de dividir el raster en trozos más pequeños, y procesarlos iterativamente en lugar de cargar todo el archivo raster en la RAM.\n\nraster_filepath = system.file(\"raster/srtm.tif\", package = \"spDataLarge\")\nmy_rast = rast(raster_filepath)\nclass(my_rast)\n## [1] \"SpatRaster\"\n## attr(,\"package\")\n## [1] \"terra\"\n\n\nmy_rast\n## class       : SpatRaster \n## dimensions  : 457, 465, 1  (nrow, ncol, nlyr)\n## resolution  : 0.0008333333, 0.0008333333  (x, y)\n## extent      : -113.2396, -112.8521, 37.13208, 37.51292  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source      : srtm.tif \n## name        : srtm \n## min value   : 1024 \n## max value   : 2892\n\n\nplot(my_rast)\n\n\n\n\nClases de datos raster\nEl paquete terra soporta numerosos controladores con la ayuda de la biblioteca GDAL. Por lo general, los rásters de los archivos no se leen completamente en la RAM, a excepción de su cabecera y un puntero al archivo.\n\nsingle_raster_file = system.file(\"raster/srtm.tif\", package = \"spDataLarge\")\nsingle_rast = rast(raster_filepath)\nsingle_rast\n## class       : SpatRaster \n## dimensions  : 457, 465, 1  (nrow, ncol, nlyr)\n## resolution  : 0.0008333333, 0.0008333333  (x, y)\n## extent      : -113.2396, -112.8521, 37.13208, 37.51292  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source      : srtm.tif \n## name        : srtm \n## min value   : 1024 \n## max value   : 2892\n\nLos rásters también pueden crearse desde cero utilizando la misma función rast().\n\nnew_raster = rast(nrows = 6, ncols = 6, \n                  xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n                  vals = 1:36)\nplot(new_raster)\n\n\n\n\nLa clase SpatRaster también puede manejar múltiples capas, por ejemplo, las bandas de un satélite multiespectral o una serie temporal de rásters.\n\nmulti_raster_file = system.file(\"raster/landsat.tif\", package = \"spDataLarge\")\nmulti_rast = rast(multi_raster_file)\nmulti_rast\n## class       : SpatRaster \n## dimensions  : 1428, 1128, 4  (nrow, ncol, nlyr)\n## resolution  : 30, 30  (x, y)\n## extent      : 301905, 335745, 4111245, 4154085  (xmin, xmax, ymin, ymax)\n## coord. ref. : WGS 84 / UTM zone 12N (EPSG:32612) \n## source      : landsat.tif \n## names       : landsat_1, landsat_2, landsat_3, landsat_4 \n## min values  :      7550,      6404,      5678,      5252 \n## max values  :     19071,     22051,     25780,     31961\n\n\nnlyr(multi_rast)\n## [1] 4\n\nLos rásters multicapa se pueden subdividir con el índice o el nombre de las capas deseadas:\n\nmulti_rast3 = subset(multi_rast, 3)\nmulti_rast4 = subset(multi_rast, \"landsat_4\")\n\nSe pueden combinar o concatenar con la función c():\n\nmulti_rast34 = c(multi_rast3, multi_rast4)\nplot(multi_rast34)"
  },
  {
    "objectID": "haciendo_mapas_en_r.html",
    "href": "haciendo_mapas_en_r.html",
    "title": "Haciendo mapas en R",
    "section": "",
    "text": "Este capítulo requiere los siguientes paquetes que ya hemos estado utilizando:\nlibrary(sf)\nlibrary(terra)\nlibrary(dplyr)\nlibrary(spData)\nlibrary(spDataLarge)\n#remotes::install_github(\"r-tmap/tmap\")\nlibrary(tmap)    # for static and interactive maps\nlibrary(leaflet) # for interactive maps\nlibrary(ggplot2) # tidyverse data visualization package\nnz_elev = rast(system.file(\"raster/nz_elev.tif\", package = \"spDataLarge\"))"
  },
  {
    "objectID": "haciendo_mapas_en_r.html#introducción",
    "href": "haciendo_mapas_en_r.html#introducción",
    "title": "Haciendo mapas en R",
    "section": "Introducción",
    "text": "Introducción\nUn aspecto importante y satisfactorio de la investigación geográfica es la comunicación de los resultados. La elaboración de mapas, el arte de la cartografía, es una habilidad antigua que implica comunicación, atención al detalle y un elemento de creatividad. La creación de mapas estáticos en R es sencilla con la función plot(). Sin embargo, este capítulo se centra en la cartografía con paquetes dedicados a la creación de mapas. Específicamente, en este capítulo veremos en profundidad el paquete (tmap).\nAdemás de ser divertida y creativa, la cartografía también tiene importantes aplicaciones prácticas. Un mapa cuidadosamente elaborado puede ser la mejor forma de comunicar los resultados de su trabajo, pero los mapas mal diseñados pueden dejar una mala impresión. Entre los problemas de diseño más comunes se encuentran la mala colocación, tamaño y legibilidad del texto y la selección descuidada de colores, como se indica en la guía de estilo del Journal of Maps. Además, un mal diseño de los mapas puede dificultar la comunicación de los resultados:\n\nLos mapas de aspecto amateur pueden mermar la capacidad de su público para comprender información importante y debilitar la presentación de una investigación de datos profesional. Los mapas se utilizan desde hace miles de años con fines muy diversos. Algunos ejemplos históricos son los mapas de edificios y propiedad de la tierra de la antigua dinastía babilónica, hace más de 3.000 años, y el mapamundi de Ptolomeo en su obra maestra Geografía, hace casi 2.000 años.\n\nHistóricamente, la elaboración de mapas ha sido una actividad realizada únicamente por la élite o en su nombre. Esto ha cambiado con la aparición de software cartográfico de código abierto, como tmap en R y el “diseño de impresión” de QGIS, que permiten a cualquiera elaborar mapas de alta calidad. Los mapas suelen ser también la mejor manera de presentar los resultados de la investigación geocomputacional de forma accesible. La elaboración de mapas es, por tanto, una parte fundamental de la geocomputación y su énfasis no sólo en describir, sino también en cambiar el mundo.\nEste capítulo muestra cómo hacer una amplia gama de mapas."
  },
  {
    "objectID": "haciendo_mapas_en_r.html#mapas-estáticos",
    "href": "haciendo_mapas_en_r.html#mapas-estáticos",
    "title": "Haciendo mapas en R",
    "section": "Mapas estáticos",
    "text": "Mapas estáticos\nLos mapas estáticos son el tipo más común de salida visual de la geocomputación. Suelen almacenarse en formatos estándar como .png y .pdf para salidas gráficas raster y vectoriales, respectivamente.\nLa función genérica plot() suele ser la forma más rápida de crear mapas estáticos a partir de objetos espaciales vectoriales y ráster. A veces, la simplicidad y la velocidad son prioritarias, especialmente durante la fase de desarrollo de un proyecto, y aquí es donde destaca plot(). El enfoque base de R es también extensible, con plot() ofreciendo docenas de argumentos. Otro enfoque es el paquete grid que permite un control de bajo nivel de los mapas estáticos.\ntmap es un paquete de creación de mapas potente y flexible con valores predeterminados sensibles. Tiene una sintaxis concisa que permite la creación de mapas atractivos con un código mínimo que será familiar a los usuarios de ggplot2. También tiene la capacidad única de generar mapas estáticos e interactivos utilizando el mismo código a través de tmap_mode(). Por último, acepta una gama más amplia de clases espaciales (incluidos los objetos sf y terra) que otras alternativas como ggplot2.\nFundamentos de tmap\nAl igual que ggplot2, tmap se basa en la idea de una “gramática de los gráficos”. Esto implica una separación entre los datos de entrada y la estética (cómo se visualizan los datos): cada conjunto de datos de entrada puede ser “mapeado” de diferentes maneras, incluyendo la ubicación en el mapa (definida por la “geometría” de los datos), el color y otras variables visuales. El elemento básico es tm_shape() (que define los datos de entrada: un objeto vectorial o ráster), seguido de uno o más elementos de capa como tm_fill() y tm_dots(). Esta estratificación se muestra en el siguiente fragmento:\n\n# Add fill layer to nz shape\ntm_shape(nz) +\n  tm_fill() \n# Add border layer to nz shape\ntm_shape(nz) +\n  tm_borders() \n# Add fill and border layers to nz shape\ntm_shape(nz) +\n  tm_fill() +\n  tm_borders() \n\nEn este caso, el objeto que se pasa a tm_shape() es nz, un objeto sf que representa las regiones de Nueva Zelanda. Se añaden capas para representar nz visualmente, con tm_fill() y tm_borders() creando áreas sombreadas y contornos de bordes, respectivamente.\nSe trata de un enfoque intuitivo para la creación de mapas: la tarea habitual de añadir nuevas capas se realiza mediante el operador de suma +, seguido de tm_*(). El asterisco (*) se refiere a una amplia gama de tipos de capas que tienen nombres autoexplicativos, entre los que se incluyen:\n\n\ntm_fill(): áreas sombreadas para (mutli)polígonos\n\ntm_borders(): contornos de bordes para (mutli)polígonos\n\ntm_polygons(): ambos, áreas sombreadas y contornos de bordes para (mutli)polígonos\n\ntm_lines(): líneas para (mutli)linestrings\n\ntm_symbols(): símbolos para (mutli)puntos, (mutli)líneas y (mutli)polígonos\n\ntm_raster(): celdas coloreadas de datos ráster (también existe tm_rgb() para rásters con tres capas)\n\ntm_text(): información de texto para (mutli)puntos, (mutli)líneas y (mutli)polígonos\nObjetos de mapa\nUna característica útil de tmap es su capacidad para almacenar objetos que representan mapas. El siguiente fragmento de código lo demuestra guardando el último gráfico como un objeto de la clase tmap (nótese el uso de tm_polygons() que condensa tm_fill() + tm_borders() en una única función):\n\nmap_nz = tm_shape(nz) + tm_polygons()\nclass(map_nz)\n## [1] \"tmap\"\n\nEl objeto map_nz puede graficarse posteriormente, por ejemplo añadiendo capas adicionales (como se muestra a continuación) o simplemente ejecutando map_nz en la consola, lo que equivale a print(map_nz).\nSe pueden añadir nuevas shapes con + tm_shape(new_obj). En este caso, nuevo_obj representa un nuevo objeto espacial que se trazará sobre las capas precedentes. Cuando se añade una nueva forma de este modo, todas las funciones estéticas posteriores hacen referencia a ella, hasta que se añada otra nueva forma. Esta sintaxis permite la creación de mapas con múltiples formas y capas, como se ilustra en el siguiente fragmento de código que utiliza la función tm_raster() para trazar una capa raster (con col_alpha configurado para hacer la capa semitransparente):\n\nmap_nz1 = map_nz +\n  tm_shape(nz_elev) + tm_raster(col_alpha = 0.7)\n\nA partir del objeto map_nz creado previamente, el código anterior crea un nuevo objeto cartográfico map_nz1 que contiene otra forma (nz_elev) que representa la elevación media de Nueva Zelanda. Pueden añadirse más formas y capas, como se ilustra en el fragmento de código siguiente, que crea nz_water, que representa las aguas territoriales de Nueva Zelanda, y añade las líneas resultantes a un objeto cartográfico existente.\n\nnz_water = st_union(nz) |&gt;\n  st_buffer(22200) |&gt; \n  st_cast(to = \"LINESTRING\")\nmap_nz2 = map_nz1 +\n  tm_shape(nz_water) + tm_lines()\n\nNo hay límite en el número de capas o formas que pueden añadirse a los objetos tmap, e incluso puede utilizarse la misma forma varias veces. El mapa final se crea añadiendo una capa que representa los puntos altos (almacenados en el objeto nz_height) al objeto map_nz2 creado previamente con tm_symbols() (véase ?tm_symbols para más detalles sobre las funciones de trazado de puntos de tmap). El mapa resultante, que tiene cuatro capas, se ilustra en el panel derecho de la Figura @ref(fig:tmlayers):\n\nmap_nz3 = map_nz2 +\n  tm_shape(nz_height) + tm_symbols()\n\nUna característica útil y poco conocida de tmap es que se pueden organizar varios objetos de mapa en un único “meta-plot” con tmap_arrange(). Esto se demuestra en el siguiente fragmento de código, que traza del map_nz1 al map_nz3, dando como resultado la siguiente figura.\n\ntmap_arrange(map_nz1, map_nz2, map_nz3)\n\n\n\nMaps with additional layers added to the final map of Figure 9.1.\n\n\n\nTambién se pueden añadir más elementos con el operador +. Los ajustes estéticos, sin embargo, se controlan mediante argumentos a las funciones de capa.\nVariables visuales\nLos gráficos de la sección anterior muestran la configuración estética por defecto de tmap. Se utilizan tonos grises para las capas tm_fill() y tm_symbols() y una línea negra continua para representar las líneas creadas con tm_lines(). Por supuesto, estos valores por defecto y otros estéticos pueden ser anulados. El propósito de esta sección es mostrar cómo.\nHay dos tipos principales de estética de mapas: los que cambian con los datos y los que son constantes. A diferencia de ggplot2, que utiliza la función de ayuda aes() para representar estéticas variables, tmap acepta unos pocos argumentos estéticos, dependiendo del tipo de capa seleccionada:\n\n\nfill: color de relleno de un polígono\n\ncol: color del borde de un polígono, línea, punto o trama\n\nlwd: ancho de línea\n\nlty: tipo de línea\n\nsize: tamaño de un símbolo\n\nshape: forma de un símbolo\n\nAdemás, podemos personalizar la transparencia de los colores de relleno y borde utilizando fill_alpha y col_alpha.\nPara asignar una variable a una estética, pase su nombre de columna al argumento correspondiente, y para establecer una estética fija, pase en su lugar el valor deseado.1 En la próxima figura se ilustra el impacto de establecer estos valores fijos.\n\nma1 = tm_shape(nz) + tm_polygons(fill = \"red\")\nma2 = tm_shape(nz) + tm_polygons(fill = \"red\", fill_alpha = 0.3)\nma3 = tm_shape(nz) + tm_polygons(col = \"blue\")\nma4 = tm_shape(nz) + tm_polygons(lwd = 3)\nma5 = tm_shape(nz) + tm_polygons(lty = 2)\nma6 = tm_shape(nz) + tm_polygons(fill = \"red\", fill_alpha = 0.3,\n                                 col = \"blue\", lwd = 3, lty = 2)\ntmap_arrange(ma1, ma2, ma3, ma4, ma5, ma6)\n\n\n\nThe impact of changing commonly used fill and border aesthetics to fixed values.\n\n\n\nAl igual que los gráficos R base, los argumentos que definen la estética también pueden recibir valores que varían. A diferencia del código R base que se muestra a continuación, los argumentos estéticos tmap no aceptarán un vector numérico:\n\nplot(st_geometry(nz), col = nz$Land_area)  # works\ntm_shape(nz) + tm_fill(col = nz$Land_area) # fails\n#&gt; Error: palette should be a character value\n\nEn su lugar, col (y otras estéticas que pueden variar, como lwd para capas de líneas y size para capas de puntos) requiere una cadena de caracteres que nombre un atributo asociado a la geometría que se va a trazar. Así, se obtendría el resultado deseado de la siguiente manera:\n\ntm_shape(nz) + tm_fill(fill = \"Land_area\")\n\nCada variable visual tiene tres argumentos adicionales relacionados, con sufijos .scale, .legend y .free. Por ejemplo, la función tm_fill() tiene argumentos como fill, fill.scale, fill.legend y fill.free. El argumento .scale determina cómo se representan los valores proporcionados en el mapa y en la leyenda, mientras que el argumento .legend se utiliza para personalizar la configuración de la leyenda, como su título, orientación o posición. El argumento .free es relevante sólo para mapas con muchas facetas para determinar si cada faceta tiene la misma o diferente escala y leyenda.\nEscalas\nLas escalas controlan cómo se representan los valores en el mapa y en la leyenda, y dependen en gran medida de la variable visual seleccionada. Por ejemplo, cuando nuestra variable visual es col, entonces col.scale controla cómo los colores de los objetos espaciales están relacionados con los valores proporcionados; y cuando nuestra variable visual es size, entonces size.scale controla cómo los tamaños representan los valores proporcionados. Por defecto, la escala utilizada es tm_scale(), que selecciona la configuración visual dada automáticamente por el tipo de datos (factor, numérico y entero).\nVeamos cómo funcionan las escalas personalizando los colores de relleno de los polígonos. La configuración del color es una parte importante del diseño de mapas, ya que puede influir mucho en la representación de la variabilidad espacial, como se ilustra en la figura de abajo.Esta figura muestra cuatro formas de colorear las regiones de Nueva Zelanda en función de la renta media, de izquierda a derecha (y se muestra en el fragmento de código siguiente):\n\nLa configuración por defecto utiliza saltos “bonitos”, que se describen en el párrafo siguiente\n\nbreaks permite establecer manualmente los saltos\n\nn establece el número de intervalos en los que se clasifican las variables numéricas\n\nvalues define el esquema de colores, por ejemplo, BuGn.\n\n\ntm_shape(nz) + tm_polygons(fill = \"Median_income\")\ntm_shape(nz) + tm_polygons(fill = \"Median_income\",\n                        fill.scale = tm_scale(breaks = c(0, 30000, 40000, 50000)))\ntm_shape(nz) + tm_polygons(fill = \"Median_income\",\n                           fill.scale = tm_scale(n = 10))\ntm_shape(nz) + tm_polygons(fill = \"Median_income\",\n                           fill.scale = tm_scale(values = \"BuGn\"))\n\n\n\n\n\nIllustration of settings that affect color settings. The results show (from left to right): default settings, manual breaks, n breaks, and the impact of changing the palette.\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nTodos los argumentos anteriores (breaks, n y values) también funcionan para otros tipos de variables visuales. Por ejemplo, values espera un vector de colores o un nombre de paleta para fill.scale o col.scale, un vector de tamaños para size.scale, o un vector de símbolos para shape.scale.\n\n\nTambién podemos personalizar las escalas utilizando una familia de funciones que empiezan con el prefijo tm_scale_. Las más importantes son tm_scale_intervals(), tm_scale_continuous(), y tm_scale_categorical().\nLa función tm_scale_intervals() divide los valores de los datos de entrada en un conjunto de intervalos. Además de establecer manualmente los breaks, tmap permite a los usuarios especificar algoritmos para crear automáticamente los breaks con el argumento style. Éstas son algunas de las funciones de escala más útiles:\n\n\nstyle = \"pretty\": la configuración por defecto, redondea los saltos a números enteros cuando es posible y los espacia uniformemente\n\nstyle = \"equal\": divide los valores de entrada en intervalos de igual rango y es apropiado para variables con una distribución uniforme (no se recomienda para variables con una distribución sesgada, ya que el mapa resultante puede acabar teniendo poca diversidad de colores)\n\nstyle = \"quantile\": garantiza que el mismo número de observaciones pertenezcan a cada categoría (con la desventaja potencial de que los intervalos de los intervalos pueden variar mucho)\n\nstyle = \"jenks\": identifica grupos de valores similares en los datos y maximiza las diferencias entre categorías\n\nstyle = \"log10_pretty\": una versión logarítmica común (el logaritmo en base 10) del estilo regular pretty utilizado para variables con una distribución sesgada a la derecha\n\n\n\n\n\n\n\nNota\n\n\n\nAunque style es un argumento de las funciones tmap, en realidad se origina como argumento en classInt::classIntervals() — véase la página de ayuda de esta función para más detalles.\n\n\n\n\n\n\nIllustration of different interval scales’ methods set using the style argument in tmap.\n\n\n\nLa función tm_scale_continuous() presenta un gran número de colores sobre campos de color continuos y es particularmente adecuada para rásters continuos. En el caso de variables con distribución sesgada, también puede utilizar sus variantes: tm_scale_continuous_log() y tm_scale_continuous_log1p(). Por último, tm_scale_categorical() se diseñó para representar valores categóricos y garantiza que cada categoría reciba un color único.\n\n\n\n\nIllustration of continuous and categorical scales in tmap.\n\n\n\nLas paletas definen los rangos de color asociados a los bins y determinados por las funciones tm_scale_*(), y sus argumentos breaks y n descritos anteriormente. La paleta de colores por defecto se especifica en tm_layout(); sin embargo, puede cambiarse rápidamente usando el argumento values. Espera un vector de colores o un nuevo nombre de paleta de colores, que puede encontrarse interactivamente con cols4all::c4a_gui(). También puede añadir un - como prefijo del nombre de la paleta de colores para invertir el orden de la paleta.\n\n\n\n\n\n\nNota\n\n\n\nTodos los valores por defecto de las variables visuales, como las paletas de colores por defecto para los diferentes tipos de variables de entrada, se pueden encontrar con tmap_options()$values.var.\n\n\nHay tres grupos principales de paletas de colores: categórica, secuencial y divergente, y cada uno de ellos sirve para un propósito diferente. También existe un cuarto grupo de paletas de colores, denominadas bivariadas. Se utilizan cuando queremos representar relaciones entre dos variables en un mapa. ] Las paletas categóricas constan de colores fácilmente distinguibles y son las más apropiadas para datos categóricos sin ningún orden concreto, como nombres de estados o clases de cobertura del suelo. Los colores deben ser intuitivos: los ríos deben ser azules, por ejemplo, y los pastos verdes. Evite demasiadas categorías: los mapas con grandes leyendas y muchos colores pueden resultar ininteligibles.\nEl segundo grupo son las paletas secuenciales. Siguen un gradiente, por ejemplo de colores claros a oscuros (los colores claros suelen representar valores más bajos), y son apropiadas para variables continuas (numéricas). Las paletas secuenciales pueden ser simples (greens va del azul claro al azul oscuro, por ejemplo) o multicolor/tono (yl_gn_bu es un gradiente del amarillo claro al azul pasando por el verde, por ejemplo), como se muestra en el fragmento de código siguiente — no se muestra la salida, ¡ejecute el código usted mismo para ver los resultados!\n\ntm_shape(nz) + \n  tm_polygons(\"Median_income\", fill.scale = tm_scale(values = \"greens\"))\ntm_shape(nz) + \n  tm_polygons(\"Median_income\", fill.scale = tm_scale(values = \"yl_gn_bu\"))\n\nEl tercer grupo, las paletas divergentes, suelen oscilar entre tres colores distintos (morado-blanco-verde en la figura @ref(fig:colpal)) y suelen crearse uniendo dos paletas secuenciales de un solo color con los colores más oscuros en cada extremo. Su principal objetivo es visualizar la diferencia con respecto a un punto de referencia importante, por ejemplo, una temperatura determinada, la mediana de los ingresos familiares o la probabilidad media de que se produzca una sequía. El valor del punto de referencia puede ajustarse en tmap utilizando el argumento midpoint.\n\ntm_shape(nz) + \n  tm_polygons(\"Median_income\",\n              fill.scale = tm_scale_continuous(values = \"pu_gn_div\", \n                                               midpoint = 28000))\n\n\n\n\n\nExamples of categorical, sequential and diverging palettes.\n\n\n\nHay dos principios importantes a tener en cuenta cuando se trabaja con colores: perceptibilidad y accesibilidad. En primer lugar, los colores de los mapas deben coincidir con nuestra percepción. Esto significa que ciertos colores se ven a través de nuestra experiencia y también de lentes culturales. Por ejemplo, los colores verdes suelen representar vegetación o tierras bajas y el azul se relaciona con el agua o lo frío. Las paletas de colores también deben ser fáciles de entender para transmitir la información con eficacia. Debe quedar claro qué valores son más bajos y cuáles más altos, y los colores deben cambiar gradualmente. En segundo lugar, los cambios de color deben ser accesibles al mayor número de personas. Por lo tanto, es importante utilizar paletas aptas para daltónicos siempre que sea posible.2\nLeyendas\nUna vez decidida nuestra variable visual y sus propiedades, debemos centrar nuestra atención en el estilo de la leyenda del mapa. Usando la función tm_legend(), podemos cambiar su título, posición, orientación, o incluso desactivarla. El argumento más importante de esta función es title, que establece el título de la leyenda asociada. En general, el título de una leyenda de mapa debe proporcionar dos informaciones: qué representa la leyenda y cuáles son las unidades de la variable presentada. El siguiente fragmento de código demuestra esta funcionalidad proporcionando un nombre más atractivo que el nombre de la variable Área_terrestre (nótese el uso de expression() para crear texto en superíndice):\n\nlegend_title = expression(\"Area (km\"^2*\")\")\nmap_nza = tm_shape(nz) +\n  tm_polygons(fill = \"Land_area\", fill.legend = tm_legend(title = legend_title))\n\nLa orientación por defecto de la leyenda en tmap es \"vertical\", sin embargo, también es posible una orientación alternativa de la leyenda, \"horizontal\". Aparte de eso, también podemos personalizar la ubicación de la leyenda utilizando el argumento position.\n\nmap_nza2 = tm_shape(nz) +\n  tm_polygons(fill = \"Land_area\",\n              fill.legend = tm_legend(title = legend_title,\n                                      orientation = \"landscape\",\n                                      position = tm_pos_out(\"center\", \"bottom\")))\n\nLa posición de la leyenda (y también la posición de otros elementos del mapa en tmap) puede personalizarse utilizando una de las siguientes funciones. Las dos más importantes son\n\n\ntm_pos_out(): por defecto, añade la leyenda fuera del área del marco del mapa. Podemos personalizar su ubicación con dos valores que representan la posición horizontal (\"left\", \"center\", o \"right\"), y la posición vertical (\"bottom\", \"center\", o \"top\")\n\ntm_pos_in(): coloca la leyenda dentro del área del marco del mapa. Podemos decidir su posición usando dos argumentos, donde el primero puede ser \"left\", \"center\" o \"right\", y el segundo puede ser \"bottom\", \"center\", o \"top\".\n\nAlternativamente, podemos simplemente proporcionar un vector de dos valores (o dos números entre 0 y 1) aquí – y en tal caso, la leyenda se pondrá dentro del marco del mapa.\nDisposición\nEl diseño del mapa se refiere a la combinación de todos los elementos del mapa en un mapa cohesivo. Los elementos del mapa incluyen, entre otros, los objetos a cartografiar, el título, la barra de escala, la rejilla del mapa y los márgenes, mientras que los ajustes de color tratados en la sección anterior se refieren a la paleta y a los puntos de ruptura utilizados para afectar al aspecto del mapa. Ambos pueden dar lugar a cambios sutiles que pueden tener un impacto igualmente grande en la impresión que dejan sus mapas.\nLos elementos adicionales del mapa, como las retículas, las flechas del norte, las barras de escala y los títulos del mapa, tienen sus propias funciones: tm_graticules(), tm_compass(), tm_scalebar() y tm_title().3\n\nmap_nz + \n  tm_graticules() +\n  tm_compass(type = \"8star\", position = c(\"left\", \"top\")) +\n  tm_scalebar(breaks = c(0, 100, 200), text.size = 1, position = c(\"left\", \"top\")) +\n  tm_title(\"New Zealand\")\n\n\n\nMap with additional elements - a north arrow and scale bar.\n\n\n\ntmap también permite cambiar una amplia variedad de configuraciones de diseño, algunas de las cuales, producidas usando el siguiente código (ver args(tm_layout) o ?tm_layout para una lista completa), se ilustran en la próxima figura:\n\nmap_nz + tm_layout(scale = 4)\nmap_nz + tm_layout(bg.color = \"lightblue\")\nmap_nz + tm_layout(frame = FALSE)\n\n\n\n\n\nLayout options specified by (from left to right) title, scale, bg.color and frame arguments.\n\n\n\nLos demás argumentos de tm_layout() permiten controlar muchos más aspectos del mapa en relación con el lienzo sobre el que se coloca. A continuación se indican algunos ajustes de diseño útiles:\n\nAjustes de márgenes, incluidos outer.margin e inner.margin.\nAjustes de fuente controlados por “fontface” y “fontfamily”.\nConfiguración de la leyenda, incluyendo opciones como legend.show (mostrar o no la leyenda) legend.orientation, legend.position, y legend.frame.\nAnchura del marco (frame.lwd) y una opción para permitir líneas dobles (frame.double.line)\nAjustes de color que controlan “color.sepia.intensity” (el aspecto amarillento del mapa) y “color.saturation” (una escala de grises).\n\n\n\n\n\nIllustration of selected layout options.\n\n\n\nMapas facetados\nLos mapas facetados, también denominados “pequeños múltiplos”, se componen de muchos mapas dispuestos uno al lado del otro, y a veces apilados verticalmente. Las facetas permiten visualizar cómo cambian las relaciones espaciales con respecto a otra variable, como el tiempo. Las poblaciones cambiantes de los asentamientos, por ejemplo, pueden representarse en un mapa facetado en el que cada panel representa la población en un momento determinado. La dimensión temporal podría representarse mediante otra variable visual, como el color. Sin embargo, se corre el riesgo de saturar el mapa, ya que se superpondrían múltiples puntos (¡las ciudades no suelen moverse con el tiempo!).\nNormalmente, todas las facetas individuales de un mapa facetado contienen los mismos datos geométricos repetidos varias veces, una por cada columna de los datos de atributos (éste es el método de trazado por defecto para los objetos sf). Sin embargo, las facetas también pueden representar geometrías cambiantes, como la evolución de un patrón de puntos a lo largo del tiempo. Este caso de uso del trazado facetado se ilustra a continuación.\n\nurb_1970_2030 = urban_agglomerations |&gt; \n  filter(year %in% c(1970, 1990, 2010, 2030))\n\ntm_shape(world) +\n  tm_polygons() +\n  tm_shape(urb_1970_2030) +\n  tm_symbols(fill = \"black\", col = \"white\", size = \"population_millions\") +\n  tm_facets_wrap(by = \"year\", nrow = 2)\n\n\n\nFaceted map showing the top 30 largest urban agglomerations from 1970 to 2030 based on population projections by the United Nations.\n\n\n\nEl fragmento de código anterior muestra las principales características de los mapas facetados creados con la función tm_facets_wrap():\n\nLas formas que no tienen una variable de faceta se repiten (los países en world en este caso)\nEl argumento by que varía en función de una variable (\"year\" en este caso)\nEl parámetro nrow/ncol que especifica el número de filas y columnas en que deben organizarse las facetas\n\nAlternativamente, es posible usar la función tm_facets_grid() que permite tener facetas basadas en hasta tres variables diferentes: una para rows, una para columns, y posiblemente una para pages.\nAdemás de su utilidad para mostrar relaciones espaciales cambiantes, los mapas facetados también son útiles como base para mapas animados.\nInset maps\nUn mapa de inserción o inset map es un mapa más pequeño que se representa dentro del mapa principal o junto a él. Puede servir para muchos fines distintos, como proporcionar un contexto o acercar algunas regiones no contiguas para facilitar su comparación. También pueden utilizarse para centrarse en una zona más pequeña con más detalle o para cubrir la misma zona que el mapa, pero representando un tema diferente.\nEn el siguiente ejemplo, creamos un mapa de la parte central de los Alpes del Sur de Nueva Zelanda. Nuestro mapa de inserción mostrará dónde se encuentra el mapa principal en relación con toda Nueva Zelanda. El primer paso es definir el área de interés, lo que puede hacerse creando un nuevo objeto espacial, nz_region.\n\nnz_region = st_bbox(c(xmin = 1340000, xmax = 1450000,\n                      ymin = 5130000, ymax = 5210000),\n                    crs = st_crs(nz_height)) |&gt; \n  st_as_sfc()\n\nEn el segundo paso, creamos un mapa base que muestra la zona de los Alpes del Sur de Nueva Zelanda. En él se expone el mensaje más importante.\n\nnz_height_map = tm_shape(nz_elev, bbox = nz_region) +\n  tm_raster(col.scale = tm_scale_continuous(values = \"YlGn\"),\n            col.legend = tm_legend(position = c(\"left\", \"top\"))) +\n  tm_shape(nz_height) + tm_symbols(shape = 2, col = \"red\", size = 1) +\n  tm_scalebar(position = c(\"left\", \"bottom\"))\n\nEl tercer paso consiste en la creación del mapa de inserción. Aporta un contexto y ayuda a localizar la zona de interés. Es importante que este mapa indique claramente la ubicación del mapa principal, por ejemplo, indicando sus límites.\n\nnz_map = tm_shape(nz) + tm_polygons() +\n  tm_shape(nz_height) + tm_symbols(shape = 2, col = \"red\", size = 0.1) + \n  tm_shape(nz_region) + tm_borders(lwd = 3) +\n  tm_layout(bg.color = \"lightblue\")\n\nUna de las principales diferencias entre los gráficos normales (por ejemplo, los de dispersión) y los mapas es que los datos de entrada determinan la relación de aspecto de los mapas. Así, en este caso, tenemos que calcular las relaciones de aspecto de nuestros dos conjuntos de datos principales, nz_region y nz. La siguiente función, norm_dim() devuelve la anchura (\"w\") y la altura (\"h\") normalizadas del objeto (en unidades \"snpc\" entendidas en mi dispositivo gráfico).\n\nlibrary(grid)\nnorm_dim = function(obj){\n    bbox = st_bbox(obj)\n    width = bbox[[\"xmax\"]] - bbox[[\"xmin\"]]\n    height = bbox[[\"ymax\"]] - bbox[[\"ymin\"]]\n    w = width / max(width, height)\n    h = height / max(width, height)\n    return(unit(c(w, h), \"snpc\"))\n}\nmain_dim = norm_dim(nz_region)\nins_dim = norm_dim(nz)\n\nA continuación, sabiendo las relaciones de aspecto, tenemos que especificar los tamaños y ubicaciones de nuestros dos mapas - el mapa principal y el mapa de inserción - utilizando la función viewport(). Una ventana gráfica es parte de un dispositivo gráfico que utilizamos para dibujar los elementos gráficos en un momento dado. La ventana gráfica de nuestro mapa principal no es más que la representación de su relación de aspecto.\n\nmain_vp = viewport(width = main_dim[1], height = main_dim[2])\n\nPor otro lado, la ventana gráfica del mapa de inserción necesita especificar su tamaño y ubicación. En este caso, haremos el mapa de inserción dos veces más pequeño que el principal multiplicando la anchura y la altura por 0,5, y lo situaremos a 0,5 cm de la parte inferior derecha del marco del mapa principal.\n\nins_vp = viewport(width = ins_dim[1] * 0.5, height = ins_dim[2] * 0.5,\n                  x = unit(1, \"npc\") - unit(0.5, \"cm\"), y = unit(0.5, \"cm\"),\n                  just = c(\"right\", \"bottom\"))\n\nPor último, combinamos los dos mapas creando un nuevo lienzo en blanco, imprimiendo el mapa principal y colocando el mapa insertado dentro de la ventana del mapa principal.\n\ngrid.newpage()\nprint(nz_height_map, vp = main_vp)\npushViewport(main_vp)\nprint(nz_map, vp = ins_vp)\n\n\n\nInset map providing a context - location of the central part of the Southern Alps in New Zealand.\n\n\n\nEl mapa de inserción puede guardarse en un archivo utilizando un dispositivo gráfico o la función tmap_save() y sus argumentos - insets_tm y insets_vp.\nLos mapas de inserción también se utilizan para crear un mapa de zonas no contiguas. Probablemente, el ejemplo más utilizado sea un mapa de Estados Unidos, que consta de los Estados Unidos contiguos, Hawai y Alaska. Es muy importante encontrar la mejor proyección para cada inserto individual en este tipo de casos. Podemos utilizar US National Atlas Equal Area para el mapa de los Estados Unidos contiguos poniendo su código EPSG en el argumento projection de tm_shape().\n\nus_states_map = tm_shape(us_states, crs = \"EPSG:2163\") + tm_polygons() + \n  tm_layout(frame = FALSE)\n\nEl resto de nuestros objetos, hawaii y alaska, ya tienen proyecciones adecuadas; por tanto, sólo tenemos que crear dos mapas distintos:\n\nhawaii_map = tm_shape(hawaii) +\n  tm_polygons() + \n  tm_title(\"Hawaii\") +\n  tm_layout(frame = FALSE, bg.color = NA, \n            title.position = c(\"LEFT\", \"BOTTOM\"))\nalaska_map = tm_shape(alaska) +\n  tm_polygons() + \n  tm_title(\"Alaska\") +\n  tm_layout(frame = FALSE, bg.color = NA)\n\nEl mapa final se crea combinando y ordenando estos tres mapas:\n\nus_states_map\nprint(hawaii_map, vp = grid::viewport(0.35, 0.1, width = 0.2, height = 0.1))\nprint(alaska_map, vp = grid::viewport(0.15, 0.15, width = 0.3, height = 0.3))\n\n\n\nMap of the United States.\n\n\n\nEl código presentado más arriba es compacto y puede utilizarse como base para otros mapas de inserción, pero los resultados proporcionan una mala representación de las ubicaciones de Hawai y Alaska. Para un enfoque más detallado, consulte la viñeta us-map del geocompkg."
  },
  {
    "objectID": "haciendo_mapas_en_r.html#mapas-animados",
    "href": "haciendo_mapas_en_r.html#mapas-animados",
    "title": "Haciendo mapas en R",
    "section": "Mapas animados",
    "text": "Mapas animados\nLos mapas facetados pueden mostrar cómo cambian las distribuciones espaciales de las variables (por ejemplo, a lo largo del tiempo), pero el enfoque tiene desventajas. Las facetas se vuelven diminutas cuando hay muchas. Además, el hecho de que cada faceta esté físicamente separada en la pantalla o página hace que las diferencias sutiles entre facetas puedan ser difíciles de detectar.\nLos mapas animados resuelven estos problemas. Aunque dependen de la publicación digital, esto está dejando de ser un problema a medida que aumenta el contenido en línea. Los mapas animados pueden seguir mejorando los informes en papel: siempre se puede enlazar a los lectores con una página web que contenga una versión animada (o interactiva) de un mapa impreso para que cobre vida. Hay varias formas de generar animaciones en R, incluso con paquetes de animación como gganimate, que se basa en ggplot2. Esta sección se centra en la creación de mapas animados con tmap porque su sintaxis le resultará familiar de las secciones anteriores y por la flexibilidad del enfoque.\nLa siguiente figura es un ejemplo sencillo de mapa animado. A diferencia del gráfico facetado, no aprieta varios mapas en una sola pantalla y permite al lector ver cómo evoluciona en el tiempo la distribución espacial de las aglomeraciones más pobladas del mundo (véase la versión animada en el sitio web del libro).\n\nEl mapa animado ilustrado anteriormente puede crearse utilizando las mismas técnicas tmap que generan mapas facetados. Hay dos diferencias, sin embargo, relacionadas con los argumentos en tm_facets():\n\n\nnrow = 1, ncol = 1 se añaden para mantener un momento en el tiempo como una capa\n\nfree.coords = FALSE, que mantiene la extensión del mapa para cada iteración del mapa.\n\nEstos argumentos adicionales se demuestran en el siguiente fragmento de código4:\n\nurb_anim = tm_shape(world) + tm_polygons() + \n  tm_shape(urban_agglomerations) + tm_symbols(size = \"population_millions\") +\n  tm_facets(by = \"year\", nrow = 1, ncol = 1, free.coords = FALSE)\n\nEl urb_anim resultante representa un conjunto de mapas separados para cada año. La etapa final consiste en combinarlos y guardar el resultado como un archivo .gif con tmap_animation(). El siguiente comando guarda la animación ilustrada:\n\ntmap_animation(urb_anim, filename = \"urb_anim.gif\", delay = 25)"
  },
  {
    "objectID": "haciendo_mapas_en_r.html#mapas-interactivos",
    "href": "haciendo_mapas_en_r.html#mapas-interactivos",
    "title": "Haciendo mapas en R",
    "section": "Mapas interactivos",
    "text": "Mapas interactivos\nAunque los mapas estáticos y animados pueden animar los conjuntos de datos geográficos, los mapas interactivos pueden llevarlos a un nuevo nivel. La interactividad puede adoptar muchas formas, la más común y útil de las cuales es la posibilidad de desplazarse y hacer zoom en cualquier parte de un conjunto de datos geográficos superpuesto a un “mapa web” para mostrar el contexto. Los niveles de interactividad menos avanzados incluyen ventanas emergentes que aparecen al hacer clic en diferentes características, una especie de etiqueta interactiva. Los niveles más avanzados de interactividad incluyen la capacidad de inclinar y girar los mapas, como se demuestra en el ejemplo mapdeck a continuación, y la provisión de subparcelas “enlazadas dinámicamente” que se actualizan automáticamente cuando el usuario hace paneos y zooms.\nSin embargo, el tipo de interactividad más importante es la visualización de datos geográficos en mapas web interactivos o “deslizantes”. El lanzamiento del paquete leaflet en 2015 (que utiliza la biblioteca JavaScript leaflet) revolucionó la creación de mapas web interactivos desde dentro de R y una serie de paquetes se han construido sobre estos cimientos añadiendo nuevas características (por ejemplo, leaflet.extras) y haciendo que la creación de mapas web sea tan sencilla como la creación de mapas estáticos (por ejemplo, mapview y tmap). Esta sección ilustra cada enfoque en el orden inverso. Exploraremos cómo hacer mapas deslizantes con tmap (cuya sintaxis ya hemos aprendido), mapview, mapdeck y finalmente leaflet (que proporciona un control de bajo nivel sobre los mapas interactivos).\nUna característica única de tmap es su capacidad para crear mapas estáticos e interactivos utilizando el mismo código. Los mapas se pueden ver de forma interactiva en cualquier punto cambiando al modo de vista, utilizando el comando tmap_mode(\"view\"). Esto se demuestra en el siguiente código, que crea un mapa interactivo de Nueva Zelanda basado en el objeto tmap map_nz:\n\ntmap_mode(\"view\")\nmap_nz\n\nAhora que el modo interactivo ha sido ‘activado’, todos los mapas producidos con tmap se lanzarán (otra forma de crear mapas interactivos es con la función tmap_leaflet()). Entre las características destacables de este modo interactivo se incluye la posibilidad de especificar el mapa base con tm_basemap() (o tmap_options()) como se demuestra a continuación (resultado no mostrado):\n\nmap_nz + tm_basemap(server = \"OpenTopoMap\")\n\nUna característica impresionante y poco conocida del modo de visualización de tmap es que también funciona con gráficos facetados. El argumento sync de tm_facets() puede utilizarse en este caso para producir múltiples mapas con ajustes de zoom y panorámica sincronizados, como se ilustra abajo:\n\n\nworld_coffee = left_join(world, coffee_data, by = \"name_long\")\nfacets = c(\"coffee_production_2016\", \"coffee_production_2017\")\n\ncoffee &lt;- \n  tm_shape(world_coffee) + tm_polygons(facets) + \n  tm_facets_wrap(nrow = 2, sync = TRUE)\n\ncoffee\n\nCambie tmap de nuevo al modo de trazado con la misma función:\n\ntmap_mode(\"plot\")\n\nSi no domina tmap, la forma más rápida de crear mapas interactivos en R puede ser con mapview. El siguiente ‘one liner’ es una forma fiable de explorar interactivamente una amplia gama de formatos de datos geográficos:\n\nmapview::mapview(nz)\n\n\n\n\n\n\nmapview tiene una sintaxis concisa pero potente. Por defecto, dispone de algunas funciones estándar de los SIG, como información sobre la posición del ratón, consulta de atributos (mediante ventanas emergentes), barra de escala y botones de zoom a capa. También ofrece controles avanzados, como la posibilidad de “burst” conjuntos de datos en varias capas y la adición de varias capas con “+” seguido del nombre de un objeto geográfico. Además, permite colorear automáticamente los atributos mediante el argumento zcol. En esencia, puede considerarse una API de leaflet basada en datos (para más información sobre leaflet, véase más adelante). Dado que mapview siempre espera un objeto espacial (incluidos sf y SpatRaster) como primer argumento, funciona bien al final de expresiones canalizadas. Consideremos el siguiente ejemplo, en el que sf se utiliza para intersecar líneas y polígonos y, a continuación, se visualiza con mapview.\n\nlibrary(mapview)\noberfranken = subset(franconia, district == \"Oberfranken\")\ntrails |&gt;\n  st_transform(st_crs(oberfranken)) |&gt;\n  st_intersection(oberfranken) |&gt;\n  st_collection_extract(\"LINESTRING\") |&gt;\n  mapview(color = \"red\", lwd = 3, layer.name = \"trails\") +\n  mapview(franconia, zcol = \"district\") +\n  breweries\n\n\n\n\n\n\nUna cosa importante a tener en cuenta es que las capas de mapview se añaden mediante el operador + (similar a ggplot2 o tmap). Por defecto, mapview utiliza la biblioteca JavaScript leaflet para renderizar los mapas de salida, que es fácil de usar y tiene un montón de características. Sin embargo, algunas bibliotecas de renderizado alternativas podrían ser más performantes (trabajar más suavemente en conjuntos de datos más grandes). mapview permite establecer bibliotecas de renderizado alternativas (\"leafgl\" y \"mapdeck\") en mapviewOptions(). 5. Para más información sobre mapview, consulte el sitio web del paquete en: r-spatial.github.io/mapview/.\nExisten otras formas de crear mapas interactivos con R. El paquete googleway, por ejemplo, proporciona una interfaz de mapas interactivos que es flexible y extensible (véase googleway-vignette para más detalles). Otro enfoque del mismo autor es mapdeck, que proporciona acceso al framework Deck.gl de Uber. Su uso de WebGL permite visualizar de forma interactiva grandes conjuntos de datos de hasta millones de puntos. El paquete utiliza Mapbox tokens de acceso, para lo cual debe registrarse antes de utilizar el paquete.\n\n\n\n\n\n\nNota\n\n\n\nTen en cuenta que el siguiente bloque asume que el token de acceso está almacenado en tu entorno R como MAPBOX=your_unique_key. Esto se puede añadir con usethis::edit_r_environ().\n\n\nUna característica exclusiva de mapdeck es que ofrece perspectivas interactivas en 2,5D, como se ilustra en la figura (fig:mapdeck). Esto significa que puedes desplazarte, hacer zoom y rotar por los mapas, y ver los datos “extruidos” del mapa.\nPor último, pero no por ello menos importante, está leaflet, que es el paquete de mapeo interactivo más maduro y utilizado en R. leaflet proporciona una interfaz de nivel relativamente bajo a la biblioteca JavaScript Leaflet y muchos de sus argumentos pueden entenderse leyendo la documentación de la biblioteca JavaScript original (véase leafletjs.com).\nLos mapas Leaflet se crean con leaflet(), cuyo resultado es un objeto de mapa leaflet que puede ser canalizado a otras funciones leaflet. Esto permite añadir múltiples capas de mapas y ajustes de control de forma interactiva, como se demuestra en el siguiente código.\n\npal = colorNumeric(\"RdYlBu\", domain = cycle_hire$nbikes)\nleaflet(data = cycle_hire) |&gt; \n  addProviderTiles(providers$CartoDB.Positron) |&gt;\n  addCircles(col = ~pal(nbikes), opacity = 0.9) |&gt; \n  addPolygons(data = lnd, fill = FALSE) |&gt; \n  addLegend(pal = pal, values = ~nbikes) |&gt; \n  setView(lng = -0.1, 51.5, zoom = 12) |&gt; \n  addMiniMap()\n\n\nThe leaflet package in action, showing cycle hire points in London. See interactive version online."
  },
  {
    "objectID": "haciendo_mapas_en_r.html#footnotes",
    "href": "haciendo_mapas_en_r.html#footnotes",
    "title": "Haciendo mapas en R",
    "section": "Notas",
    "text": "Notas\n\nSi hay un conflicto entre un valor fijo y un nombre de columna, el nombre de columna tiene preferencia. Esto se puede comprobar ejecutando el siguiente trozo de código después de ejecutar nz$red = 1:nrow(nz).↩︎\nVéanse las opciones “Visión del color” y el panel “Apto para daltónicos” en cols4all::c4a_gui().↩︎\nOtros elementos adicionales del mapa son tm_grid(), tm_logo() y tm_credits().↩︎\nTambién existe un atajo para este enfoque: tm_facets_pagewise()↩︎\nTambién puede intentar utilizar mapviewOptions(georaster = TRUE) para obtener visualizaciones de mayor rendimiento de grandes datos rasterizados↩︎"
  },
  {
    "objectID": "interaccion_raster_vector.html",
    "href": "interaccion_raster_vector.html",
    "title": "Interacciones raster-vector",
    "section": "",
    "text": "library(sf)\nlibrary(terra)\nlibrary(dplyr)"
  },
  {
    "objectID": "interaccion_raster_vector.html#introducción",
    "href": "interaccion_raster_vector.html#introducción",
    "title": "Interacciones raster-vector",
    "section": "Introducción",
    "text": "Introducción\nEste capítulo se centra en las interacciones entre los modelos de datos geográficos ráster y vectoriales. Incluye cuatro técnicas principales: recorte y enmascaramiento ráster utilizando objetos vectoriales; extracción de valores ráster utilizando diferentes tipos de datos vectoriales; y conversión ráster-vector."
  },
  {
    "objectID": "interaccion_raster_vector.html#recorte",
    "href": "interaccion_raster_vector.html#recorte",
    "title": "Interacciones raster-vector",
    "section": "Recorte",
    "text": "Recorte\nMuchos proyectos de datos geográficos implican la integración de datos de muchas fuentes diferentes, como imágenes de teledetección (rásters) y límites administrativos (vectores). A menudo, la extensión de los conjuntos de datos ráster de entrada es mayor que el área de interés. En este caso, el recorte y el enmascaramiento ráster son útiles para unificar la extensión espacial de los datos de entrada. Ambas operaciones reducen el uso de memoria del objeto y los recursos computacionales asociados para los pasos de análisis posteriores, y pueden ser un paso de preprocesamiento necesario antes de crear mapas atractivos que incluyan datos ráster.\nUtilizaremos dos objetos para ilustrar el recorte raster:\n\nUn objeto SpatRaster srtm que representa la elevación (metros sobre el nivel del mar) en el suroeste de Utah\nUn objeto vectorial (sf) zion que representa el Parque Nacional de Zion.\n\nTanto el objeto de destino como el de recorte deben tener la misma proyección. Por lo tanto, el siguiente fragmento de código no sólo lee los conjuntos de datos del paquete spDataLarge, sino que también “reproyecta” zion:\n\nsrtm = rast(system.file(\"raster/srtm.tif\", package = \"spDataLarge\"))\nzion = read_sf(system.file(\"vector/zion.gpkg\", package = \"spDataLarge\"))\nzion = st_transform(zion, crs(srtm))\n\nUtilizamos crop() del paquete terra para recortar srtm. La función reduce la extensión rectangular del objeto pasado como primer argumento en función de la extensión del objeto pasado como segundo argumento.\n\nsrtm_cropped = crop(srtm, zion)\n\nRelacionada con crop() está la función terra mask(), que establece como NA los valores fuera de los límites del objeto pasado a su segundo argumento. Por tanto, el siguiente comando enmascara todas las celdas situadas fuera de los límites del Parque Nacional de Zion:\n\nsrtm_masked = mask(srtm, zion)\n\nEs importante destacar que, en la mayoría de los casos, se recomienda utilizar conjuntamente las funciones crop() y mask(). Esta combinación de funciones (a) limitaría la extensión del raster a nuestra área de interés y (b) reemplazaría todos los valores fuera del área a NA.\n\nsrtm_cropped = crop(srtm, zion)\nsrtm_final = mask(srtm_cropped, zion)\n\nCambiando la configuración de mask() se obtienen resultados diferentes. Si se establece inverse = TRUE se enmascarará todo lo que esté dentro de los límites del parque (véase ?mask para más detalles), mientras que si se establece updatevalue = 0 se pondrán a 0 todos los píxeles fuera del parque nacional.\n\nsrtm_inv_masked = mask(srtm, zion, inverse = TRUE)\n\n\n\n\n\nIllustration of raster cropping and raster masking."
  },
  {
    "objectID": "interaccion_raster_vector.html#extracción-de-datos-de-un-raster",
    "href": "interaccion_raster_vector.html#extracción-de-datos-de-un-raster",
    "title": "Interacciones raster-vector",
    "section": "Extracción de datos de un raster",
    "text": "Extracción de datos de un raster\nLa extracción de raster es el proceso de identificar y devolver los valores asociados a un raster “objetivo” en ubicaciones específicas, basándose en un objeto “selector” geográfico (normalmente vectorial). Los resultados dependen del tipo de selector utilizado (puntos, líneas o polígonos) y de los argumentos pasados a la función terra::extract(). El reverso de la extracción raster — asignar valores de celda raster basado en objetos vectoriales — es la rasterización, que se describe más adelante.\nEl ejemplo básico consiste en extraer el valor de una celda ráster en puntos específicos. Para ello, utilizaremos zion_points, que contiene una muestra de 30 localizaciones dentro del Parque Nacional de Zion. El siguiente comando extrae los valores de elevación de srtm y crea un data frame con los ID de los puntos (un valor por fila del vector) y los valores srtm relacionados para cada punto. Ahora, podemos añadir el objeto resultante a nuestro conjunto de datos zion_points con la función cbind():\n\ndata(\"zion_points\", package = \"spDataLarge\")\nelevation = terra::extract(srtm, zion_points)\nzion_points = cbind(zion_points, elevation)\n\n\n\n\n\nLocations of points used for raster extraction.\n\n\n\nLa extracción de datos raster también funciona con selectores de tipo línea. Entonces, extrae un valor por cada celda raster tocada por la línea. El enfoque consiste en dividir la línea en muchos puntos y luego extraer los valores de estos puntos. Para demostrarlo, el código siguiente crea zion_transect, una línea recta que va del noroeste al sureste del Parque Nacional de Zion:\n\nzion_transect = cbind(c(-113.2, -112.9), c(37.45, 37.2)) |&gt;\n  st_linestring() |&gt; \n  st_sfc(crs = crs(srtm)) |&gt;\n  st_sf(geometry = _)\n\nLa utilidad de extraer alturas de un selector lineal se ilustra imaginando que está planeando una excursión. El método que se muestra a continuación proporciona un perfil de elevación de la ruta (no es necesario que la línea sea recta), útil para estimar cuánto tiempo se tardará debido a las subidas.\nEl primer paso es añadir un id único para cada transecto. A continuación, con la función st_segmentize() podemos añadir puntos a lo largo de nuestra(s) línea(s) con una densidad proporcionada (dfMaxLength) y convertirlos en puntos con st_cast().\n\nzion_transect$id = 1:nrow(zion_transect)\nzion_transect = st_segmentize(zion_transect, dfMaxLength = 250)\nzion_transect = st_cast(zion_transect, \"POINT\")\n\nAhora, tenemos un gran conjunto de puntos, y queremos derivar una distancia entre el primer punto de nuestros transectos y cada uno de los puntos subsiguientes. En este caso, sólo tenemos un transecto, pero el código, en principio, debería funcionar con cualquier número de transectos:\n\nzion_transect = zion_transect |&gt; \n  group_by(id) |&gt; \n  mutate(dist = st_distance(geometry)[, 1]) \n\nPor último, podemos extraer los valores de elevación de cada punto de nuestros transectos y combinar esta información con nuestro objeto principal.\n\nzion_elev = terra::extract(srtm, zion_transect)\nzion_transect = cbind(zion_transect, zion_elev)\n\nEl zion_transect resultante puede utilizarse para crear perfiles de elevación, como se ilustra a continuación.\n\n\n\n\nLocation of a line used for raster extraction (left) and the elevation along this line (right).\n\n\n\nEl último tipo de objeto vectorial geográfico para la extracción de rásters son los polígonos. Al igual que las líneas, los polígonos tienden a devolver muchos valores ráster por polígono. Esto se demuestra en el siguiente comando, que da como resultado un marco de datos con nombres de columna ID (el número de fila del polígono) y srtm (valores de elevación asociados):\n\nzion_srtm_values = terra::extract(x = srtm, y = zion)\n\nEstos resultados pueden utilizarse para generar estadísticas resumidas de valores ráster por polígono, por ejemplo para caracterizar una única región o para comparar muchas regiones. Esto se muestra en el siguiente código, que crea el objeto zion_srtm_df que contiene estadísticas resumidas para los valores de elevación en el Parque Nacional de Zion:\n\ngroup_by(zion_srtm_values, ID) |&gt; \n  summarize(across(srtm, list(min = min, mean = mean, max = max)))\n\n\n\n\nID\nsrtm_min\nsrtm_mean\nsrtm_max\n\n\n1\n1122\n1818.212\n2661\n\n\n\n\n\nEl trozo de código anterior utilizó dplyr para proporcionar estadísticas de resumen para los valores de celda por ID de polígono. Los resultados proporcionan resúmenes útiles, por ejemplo, que la altura máxima en el parque es de alrededor de 2.661 metros sobre el nivel del mar (otras estadísticas de resumen, como la desviación estándar, también se puede calcular de esta manera). Como en el ejemplo sólo hay un polígono, se devuelve una tabla de datos con una única fila; sin embargo, el método funciona cuando se utilizan varios polígonos selectores.\nUn método similar funciona para el recuento de ocurrencias de valores ráster categóricos dentro de polígonos. Esto se ilustra con un conjunto de datos de cobertura del suelo (nlcd) del paquete spDataLarge, y se demuestra en el código siguiente:\n\nnlcd = rast(system.file(\"raster/nlcd.tif\", package = \"spDataLarge\"))\nzion2 = st_transform(zion, st_crs(nlcd))\nzion_nlcd = terra::extract(nlcd, zion2)\nzion_nlcd |&gt; \n  group_by(ID, levels) |&gt;\n  count()\n\n\n\n\nID\nlevels\nn\n\n\n\n1\nDeveloped\n4205\n\n\n1\nBarren\n98285\n\n\n1\nForest\n298299\n\n\n1\nShrubland\n203701\n\n\n1\nHerbaceous\n235\n\n\n1\nCultivated\n62\n\n\n1\nWetlands\n679\n\n\n\n\n\n\n\n\n\n\nArea used for continuous (left) and categorical (right) raster extraction.\n\n\n\nAunque el paquete terra ofrece una rápida extracción de valores ráster dentro de polígonos, extract() puede seguir siendo un cuello de botella cuando se procesan grandes conjuntos de datos de polígonos. El paquete exactextractr ofrece una alternativa significativamente más rápida para extraer valores de píxeles a través de la función exact_extract(). La función exact_extract() también calcula, por defecto, la fracción de cada celda ráster solapada por el polígono, lo cual es más preciso.\n\n\n\n\n\n\nNota\n\n\n\nLos polígonos suelen tener formas irregulares y, por lo tanto, un polígono puede solapar sólo algunas partes de las celdas de un ráster. Para obtener resultados más detallados, la función terra::extract() tiene un argumento llamado exact. Con exact = TRUE, obtenemos una columna más fraction en el marco de datos de salida, que representa una fracción de cada celda que está cubierta por el polígono. Esto podría ser útil para calcular, por ejemplo, una media ponderada para rásters continuos o una cobertura más precisa para rásters categóricos. Por defecto, es FALSE ya que esta operación requiere más cálculos. La función exactextractr::exact_extract() siempre calcula la fracción de cobertura del polígono en cada celda."
  },
  {
    "objectID": "interaccion_raster_vector.html#rasterización",
    "href": "interaccion_raster_vector.html#rasterización",
    "title": "Interacciones raster-vector",
    "section": "Rasterización",
    "text": "Rasterización\nLa rasterización es la conversión de objetos vectoriales a raster. Normalmente, el ráster de salida se utiliza después para análisis cuantitativos (por ejemplo, análisis del terreno) o modelado. El proceso de rasterización puede ayudar a simplificar los conjuntos de datos porque todos los valores resultantes tienen la misma resolución espacial: la rasterización puede considerarse un tipo especial de agregación de datos geográficos.\nEl paquete terra contiene la función rasterize() para realizar este trabajo. Sus dos primeros argumentos son, x, objeto vectorial a rasterizar e, y, un objeto `plantilla raster’ que define la extensión, resolución y CRS de la salida. La resolución geográfica del ráster de entrada tiene un gran impacto en los resultados: si es demasiado baja (el tamaño de las celdas es demasiado grande), el resultado puede perder toda la variabilidad geográfica de los datos vectoriales; si es demasiado alta, los tiempos de cálculo pueden ser excesivos. No existen reglas sencillas a la hora de decidir la resolución geográfica adecuada, que depende en gran medida del uso que se pretenda dar a los resultados. A menudo, la resolución objetivo se impone al usuario, por ejemplo cuando el resultado de la rasterización debe alinearse con algún otro raster existente.\nPara demostrar la rasterización en acción, utilizaremos una plantilla raster que tiene la misma extensión y CRS que los datos vectoriales de entrada cycle_hire_osm_projected y una resolución espacial de 1000 metros:\n\ncycle_hire_osm = spData::cycle_hire_osm\ncycle_hire_osm_projected = st_transform(cycle_hire_osm, \"EPSG:27700\")\nraster_template = rast(ext(cycle_hire_osm_projected), resolution = 1000,\n                       crs = st_crs(cycle_hire_osm_projected)$wkt)\n\nLa rasterización es una operación muy flexible: los resultados dependen no sólo de la naturaleza de la plantilla raster, sino también del tipo de vector de entrada (por ejemplo, puntos, polígonos) y de una variedad de argumentos tomados por la función rasterize().\nPara ilustrar esta flexibilidad, probaremos tres enfoques diferentes de la rasterización. En primer lugar, crearemos un raster que represente la presencia o ausencia de puntos de alquiler de bicicletas (conocidos como raster de presencia/ausencia). En este caso, rasterize() no requiere ningún argumento además de x e y, los objetos vector y raster antes mencionados.\n\nch_raster1 = rasterize(cycle_hire_osm_projected, raster_template)\n\nEl argumento fun especifica los estadísticos de resumen utilizados para convertir múltiples observaciones muy próximas en celdas asociadas en el objeto raster. Por defecto se utiliza fun = \"last\" pero se pueden utilizar otras opciones como fun = \"length\", en este caso para contar el número de puntos de alquiler de ciclos en cada celda de la cuadrícula.\n\nch_raster2 = rasterize(cycle_hire_osm_projected, raster_template, \n                       fun = \"length\")\n\nEl nuevo resultado, ch_raster2, muestra el número de puntos de alquiler de bicicletas en cada cuadrícula. Los puntos de alquiler de bicicletas tienen diferentes números de bicicletas descritos por la variable capacity, lo que plantea la siguiente pregunta: ¿cuál es la capacidad de cada celda de la cuadrícula? Para calcularlo debemos “sumar” el campo (\"capacity\"), calculada con el siguiente comando (también se podrían utilizar otras funciones de resumen como mean):\n\nch_raster3 = rasterize(cycle_hire_osm_projected, raster_template, \n                       field = \"capacity\", fun = sum, na.rm = TRUE)\n\n\n\n\n\nExamples of point rasterization.\n\n\n\nOtro conjunto de datos basado en polígonos y fronteras de California ilustra la rasterización de líneas. Tras fundir los objetos poligonales en una multilínea, se crea un raster de plantilla con una resolución de 0.5 grados:\n\nlibrary(spData)\ncalifornia = dplyr::filter(us_states, NAME == \"California\")\ncalifornia_borders = st_cast(california, \"MULTILINESTRING\")\nraster_template2 = rast(ext(california), resolution = 0.5,\n                        crs = st_crs(california)$wkt)\n\nAl considerar la rasterización de líneas o polígonos, un argumento adicional útil es “touches”. Por defecto es FALSE, pero cuando se cambia a TRUE – todas las celdas que son tocadas por el borde de una línea o polígono obtienen un valor. La rasterización de líneas con touches = TRUE se muestra en el siguiente código.\n\ncalifornia_raster1 = rasterize(california_borders, raster_template2,\n                               touches = TRUE)\n\nCompárelo con una rasterización de polígonos, con touches = FALSE por defecto, que selecciona sólo las celdas raster cuyos centroides están dentro del polígono selector.\n\ncalifornia_raster2 = rasterize(california, raster_template2) \n\n\n\n\n\nExamples of line and polygon rasterizations."
  },
  {
    "objectID": "interaccion_raster_vector.html#vectorización-espacial",
    "href": "interaccion_raster_vector.html#vectorización-espacial",
    "title": "Interacciones raster-vector",
    "section": "Vectorización espacial",
    "text": "Vectorización espacial\nLa vectorización espacial es la contrapartida de la rasterización. Consiste en convertir datos ráster espacialmente continuos en datos vectoriales espacialmente discretos, como puntos, líneas o polígonos.\n\n\n\n\n\n\nNota\n\n\n\nEn R, la vectorización suele referirse a la posibilidad de sustituir los bucles for y similares haciendo cosas como 1:10 / 2.\n\n\nLa forma más simple de vectorización es convertir los centroides de las celdas raster en puntos. as.points() hace exactamente esto para todas las celdas de cuadrícula raster que no sean NA. Tenga en cuenta que aquí también utilizamos st_as_sf() para convertir el objeto resultante a la clase sf.\n\nelev = rast(system.file(\"raster/elev.tif\", package = \"spData\"))\nelev_point = as.points(elev) |&gt; \n  st_as_sf()\n\n\n\n\n\nRaster and point representation of the elev object.\n\n\n\nOtro tipo común de vectorización espacial es la creación de curvas de nivel que representen líneas de altura o temperaturas continuas (isotermas), por ejemplo. Utilizaremos un modelo digital de elevación (MDE) del mundo real porque el ráster artificial elev produce líneas paralelas. Las curvas de nivel se pueden crear con la función terra as.contour(), que es a su vez una envoltura de la función incorporada en R filled.contour(), como se demuestra a continuación:\n\ndem = rast(system.file(\"raster/dem.tif\", package = \"spDataLarge\"))\ncl = as.contour(dem) |&gt; \n  st_as_sf()\nplot(dem, axes = FALSE)\nplot(cl, add = TRUE)\n\n\n\n\nTambién pueden añadirse contornos a los gráficos existentes con funciones como contour(), rasterVis::contourplot() o tmap::tm_iso() y, las isolíneas pueden etiquetarse.\n\n\n\n\nDEM with hillshading, showing the southern flank of Mt. Mongón overlaid with contour lines.\n\n\n\nEl último tipo de vectorización implica la conversión de rásters en polígonos. Esto puede hacerse con terra::as.polygons(), que convierte cada celda ráster en un polígono formado por cinco coordenadas, todas las cuales se almacenan en memoria (¡explicando por qué los rásters son a menudo rápidos comparados con los vectores!).\nEsto se ilustra a continuación convirtiendo el objeto grain en polígonos y disolviendo posteriormente los bordes entre polígonos con los mismos valores de atributo (véase también el argumento dissolve en as.polygons()).\n\ngrain = rast(system.file(\"raster/grain.tif\", package = \"spData\"))\ngrain_poly = as.polygons(grain) |&gt; \n  st_as_sf()\n\n\n\n\n\nIllustration of vectorization of raster (left) into polygons (dissolve = FALSE; center) and aggregated polygons (dissolve = TRUE; right)."
  },
  {
    "objectID": "lc_index.html",
    "href": "lc_index.html",
    "title": "Lectura complementaria",
    "section": "",
    "text": "El material que se presenta en esta sección fue traducido y recortado del libro “Geocomputation with R” de Robin Lovelace, Jakub Nowosad y Jannes Muenchow.\n\nDatos espaciales en R\nOperaciones con atributos\nOperaciones espaciales\nOperaciones con geometrías\nInteracción raster-vector\nReproyección de datos espaciales\nEntrada y salida de datos espaciales\nHaciendo mapas en R"
  },
  {
    "objectID": "operaciones_espaciales.html",
    "href": "operaciones_espaciales.html",
    "title": "Operaciones espaciales",
    "section": "",
    "text": "library(sf)\nlibrary(terra)\nlibrary(dplyr)\nlibrary(spData)\nLas operaciones espaciales, incluidas las uniones espaciales entre conjuntos de datos vectoriales y las operaciones locales y focales en datos ráster, son una parte vital de la geocomputación. Los objetos espaciales pueden modificarse de múltiples maneras en función de su ubicación y forma. Muchas operaciones espaciales tienen un equivalente no espacial (atributo), por lo que conceptos como el subset y la unión de conjuntos de datos demostrados anteriormente son aplicables aquí.\nSin embargo, las operaciones espaciales difieren de las no espaciales en varios aspectos. Las uniones espaciales, por ejemplo, pueden realizarse de varias formas, incluida la coincidencia de entidades que se cruzan o se encuentran a una cierta distancia del conjunto de datos de destino, mientras que las uniones por atributos sólo pueden realizarse de una forma.\nOtro aspecto único de los objetos espaciales es la distancia: todos los objetos espaciales se relacionan a través del espacio, y los cálculos de distancia se pueden utilizar para explorar la fuerza de esta relación (Sección @ref(relaciones-distancia)).\nLas operaciones espaciales sobre objetos ráster incluyen el subset o subdivisión y la fusión de varios “mosaicos” ráster en un único objeto. El álgebra de mapas abarca una serie de operaciones que modifican los valores de las celdas ráster, con o sin referencia a los valores de las celdas circundantes. Así, se muestran operaciones de álgebra de mapas locales, focales, zonales y globales."
  },
  {
    "objectID": "operaciones_espaciales.html#operaciones-espaciales-sobre-datos-vectoriales",
    "href": "operaciones_espaciales.html#operaciones-espaciales-sobre-datos-vectoriales",
    "title": "Operaciones espaciales",
    "section": "Operaciones espaciales sobre datos vectoriales",
    "text": "Operaciones espaciales sobre datos vectoriales\nEsta sección proporciona una visión general de las operaciones espaciales sobre datos geográficos vectoriales sf.\nSubdivisión espacial\nEl subset espacial es el proceso de tomar un objeto espacial y devolver un nuevo objeto que contenga sólo las características que se relacionan en el espacio con otro objeto. De forma análoga al sudset de atributos, pueden crearse subconjuntos de data.frames sf con el operador corchete ([) utilizando la sintaxis x[y, , op = st_intersects], donde x es un objeto sf del que se obtendrá un subconjunto de filas, y es el objeto de subconjunto y , op = st_intersects es un argumento opcional que especifica la relación topológica (también conocida como predicado binario) utilizada para realizar el subconjunto.\nLa relación topológica por defecto utilizada cuando no se proporciona un argumento op es st_intersects(): el comando x[y, ] es idéntico a x[y, , op = st_intersects] mostrado anteriormente pero no a x[y, , op = st_disjoint] (el significado de estas y otras relaciones topológicas se describe en la siguiente sección).\nPara demostrar el subset espacial, utilizaremos los conjuntos de datos nz y nz_height del paquete spData, que contienen datos geográficos sobre las 16 regiones principales y los 101 puntos más altos de Nueva Zelanda, respectivamente (Figura @ref(fig:nz-subset)), en un sistema de coordenadas proyectado. El siguiente fragmento de código crea un objeto que representa Canterbury y, a continuación, utiliza el subset espacial para devolver todos los puntos altos de la región:\n\ncanterbury = nz |&gt; filter(Name == \"Canterbury\")\ncanterbury_height = nz_height[canterbury, ]\n\n\n\n\n\nIllustration of spatial subsetting with red triangles representing 101 high points in New Zealand, clustered near the central Canterbuy region (left). The points in Canterbury were created with the [ subsetting operator (highlighted in gray, right).\n\n\n\nAl igual que el subset de atributos, el comando x[y, ] (equivalente a nz_height[canterbury, ]) selecciona características de un objeto objetivo x utilizando el contenido de un objeto fuente y. Sin embargo, en lugar de que y sea un vector de clase lógica o entera, para el subset espacial tanto x como y deben ser objetos geográficos, en este caso sf.\nSe pueden utilizar varias relaciones topológicas que determinan el tipo de relación espacial pueden ser: toques, cruces o dentro de. El parámetro por defecto st_intersects es una relación topológica tipo ‘catch all’ que devolverá características en el objetivo que toquen, crucen o estén dentro del objeto fuente. Como se ha indicado anteriormente, se pueden especificar operadores espaciales alternativos con el argumento op =, como se demuestra en el siguiente comando que devuelve lo contrario de st_intersects(), puntos que no se intersecan con Canterbury:\n\nnz_height[canterbury, , op = st_disjoint]\n\n\n\n\n\n\n\nNota\n\n\n\nObserve que el argumento vacío — denotado con , , — en el trozo de código anterior se incluye para resaltar op, el tercer argumento en [ para objetos sf. Se puede utilizar para cambiar la operación de subset de muchas maneras. nz_height[canterbury, 2, op = st_disjoint], por ejemplo, devuelve las mismas filas pero sólo incluye la segunda columna de atributos (véase sf:::`[.sf` y el ?sf para más detalles).\n\n\nUnión espacial\nLa unión de dos conjuntos de datos no espaciales se basa en una variable “clave” compartida o key. La unión de datos espaciales aplica el mismo concepto, pero se basa en las relaciones espaciales. Al igual que con los atributos, la unión añade nuevas columnas al objeto de destino (el argumento x en las funciones de unión), a partir de un objeto de origen (y).\nEl proceso se ilustra con el siguiente ejemplo: imagine que tiene diez puntos distribuidos aleatoriamente por la superficie de la Tierra y pregunta, para los puntos que están en tierra, ¿en qué países se encuentran?\nEl punto de partida es crear puntos dispersos aleatoriamente por la superficie terrestre:\n\nset.seed(2018) # set seed for reproducibility\n(bb = st_bbox(world)) # the world's bounds\nrandom_df = data.frame(\n  x = runif(n = 10, min = bb[1], max = bb[3]),\n  y = runif(n = 10, min = bb[2], max = bb[4])\n)\nrandom_points = random_df |&gt; \n  st_as_sf(coords = c(\"x\", \"y\"), crs = \"EPSG:4326\") # set coordinates and CRS\n##       xmin       ymin       xmax       ymax \n## -180.00000  -89.90000  179.99999   83.64513\n\nEl escenario ilustrado abajo muestra que el objeto random_points (arriba a la izquierda) carece de datos de atributos, mientras que el world (arriba a la derecha) tiene atributos, incluidos los nombres de los países mostrados para una muestra de países en la leyenda. Las uniones espaciales se implementan con st_join(), como se ilustra en el siguiente fragmento de código. El resultado es el objeto random_joined que se ilustra abajo a la izquierda.\n\nAntes de crear el conjunto de datos unido, utilizamos el subconjunto espacial para crear world_random, que contiene sólo países que contienen puntos aleatorios, para verificar que el número de nombres de países devueltos en el conjunto de datos unido debe ser cuatro.\n\nworld_random = world[random_points, ]\nnrow(world_random)\nrandom_joined = st_join(random_points, world[\"name_long\"])\n## [1] 4\n\nPor defecto, st_join() realiza una unión a la izquierda, lo que significa que el resultado es un objeto que contiene todas las filas de x incluyendo las filas que no coinciden con y, pero también puede realizar uniones internas estableciendo el argumento left = FALSE. Al igual que el subset espacial, el operador topológico por defecto utilizado por st_join() es st_intersects(), que puede cambiarse estableciendo el argumento join (véase ?st_join para más detalles). El ejemplo anterior muestra la adición de una columna de una capa de polígonos a una capa de puntos, pero el método funciona independientemente del tipo de geometría. En tales casos, por ejemplo cuando x contiene polígonos, cada uno de los cuales coincide con múltiples objetos en y, las uniones espaciales darán lugar a características duplicadas al crear una nueva fila por cada coincidencia en y.\nUniones no solapadas\nA veces, dos conjuntos de datos geográficos no se tocan, pero mantienen una estrecha relación geográfica. Los conjuntos de datos cycle_hire y cycle_hire_osm, ya adjuntos en el paquete spData, constituyen un buen ejemplo. Su representación gráfica muestra que a menudo están estrechamente relacionados pero no se tocan, como se muestra abajo:\n\nplot(st_geometry(cycle_hire), col = \"blue\")\nplot(st_geometry(cycle_hire_osm), add = TRUE, pch = 3, col = \"red\")\n\nPodemos comprobar si algún punto coincide con st_intersects() como se muestra a continuación:\n\nany(st_touches(cycle_hire, cycle_hire_osm, sparse = FALSE))\n## [1] FALSE\n\nImaginemos que necesitamos unir la variable capacity de cycle_hire_osm a los datos oficiales target contenidos en cycle_hire. En este caso se necesita una unión no solapada. El método más sencillo es utilizar el predicado binario st_is_within_distance(), como se muestra a continuación utilizando una distancia umbral de 20 m. Se puede establecer la distancia umbral en unidades métricas también para datos no proyectados (por ejemplo, lon/lat CRSs como WGS84), si el motor de geometría esférica (s2) está habilitado, como lo está en sf por defecto.\n\nsel = st_is_within_distance(cycle_hire, cycle_hire_osm, \n                            dist = units::set_units(20, \"m\"))\nsummary(lengths(sel) &gt; 0)\n##    Mode   FALSE    TRUE \n## logical     304     438\n\nEsto muestra que hay 438 puntos en el objeto de destino cycle_hire dentro de la distancia umbral de cycle_hire_osm. ¿Cómo recuperar los valores asociados a los respectivos puntos de cycle_hire_osm? La solución es de nuevo con st_join(), pero añadiendo el argumento dist (fijado en 20 m más abajo):\n\nz = st_join(cycle_hire, cycle_hire_osm, st_is_within_distance, \n            dist = units::set_units(20, \"m\"))\nnrow(cycle_hire)\nnrow(z)\n## [1] 742\n## [1] 762\n\nObserve que el número de filas del resultado unido es mayor que el objetivo. Esto se debe a que algunas estaciones de alquiler de bicicletas en cycle_hire tienen múltiples coincidencias en cycle_hire_osm. Para agregar los valores de los puntos solapados y devolver la media, podemos utilizar los métodos de agregación aprendidos ates, dando como resultado un objeto con el mismo número de filas que el objetivo:\n\nz = z |&gt; \n  group_by(id) |&gt; \n  summarize(capacity = mean(capacity))\nnrow(z) == nrow(cycle_hire)\n## [1] TRUE\n\nLa capacidad de las estaciones cercanas puede verificarse comparando un gráfico de la capacidad de los datos de la fuente cycle_hire_osm con los resultados de este nuevo objeto (gráficos no mostrados):\n\nplot(cycle_hire_osm[\"capacity\"])\n\n\n\nplot(z[\"capacity\"])\n\n\n\n\nEl resultado de esta unión ha utilizado una operación espacial para cambiar los datos de atributos asociados a sf; la geometría asociada a cada característica ha permanecido inalterada.\nAgregación espacial\nAl igual que la agregación de datos de atributos, la agregación de datos espaciales condensa los datos: las salidas agregadas tienen menos filas que las entradas no agregadas. Las funciones de agregación estadística, como la media o la suma, resumen múltiples valores de una variable, y devuelven un único valor por variable de agrupación. Ya se demostró cómo aggregate() y group_by() |&gt; summarize() condensan datos basados en variables de atributo, esta sección muestra cómo funcionan las mismas funciones con objetos espaciales.\nVolviendo al ejemplo de Nueva Zelanda, imagine que desea averiguar la altura media de los puntos altos de cada región: es la geometría de la fuente (y o nz en este caso) la que define cómo se agrupan los valores en el objeto de destino (x o nz_height). Esto se puede hacer en una sola línea de código con el método aggregate() de R base:\n\nnz_agg = aggregate(x = nz_height, by = nz, FUN = mean)\n\nEl resultado del comando anterior es un objeto sf con la misma geometría que el objeto de agregación (espacial) (nz), lo que puede comprobar con el comando identical(st_geometry(nz), st_geometry(nz_agg)). El resultado de la operación anterior se ilustra en la figura @ref(fig:spatial-aggregation), que muestra el valor medio de las características en nz_height dentro de cada una de las 16 regiones de Nueva Zelanda. El mismo resultado también puede generarse canalizando la salida de st_join() a las funciones group_by() y summarize() de la siguiente forma:\n\n\n\n\nAverage height of the top 101 high points across the regions of New Zealand.\n\n\n\n\nnz_agg2 = st_join(x = nz, y = nz_height) |&gt;\n  group_by(Name) |&gt;\n  summarize(elevation = mean(elevation, na.rm = TRUE))\n\nLos objetos nz_agg resultantes tienen la misma geometría que el objeto agregador nz pero con una nueva columna que resume los valores de x en cada región utilizando la función mean(). Se pueden utilizar otras funciones en lugar de mean(), incluyendo median(), sd() y otras funciones que devuelven un único valor por grupo.\nRelaciones de distancia\nMientras que las relaciones topológicas son binarias (una característica se cruza con otra o no), las relaciones de distancia son continuas. La distancia entre dos objetos se calcula con la función st_distance(). Esto se ilustra en el siguiente fragmento de código, que encuentra la distancia entre el punto más alto de Nueva Zelanda y el centroide geográfico de la región de Canterbury:\n\nnz_highest = nz_height |&gt; slice_max(n = 1, order_by = elevation)\ncanterbury_centroid = st_centroid(canterbury)\nst_distance(nz_highest, canterbury_centroid)\n## Units: [m]\n##        [,1]\n## [1,] 115540\n\nHay dos cosas potencialmente sorprendentes en el resultado:\n\nTiene “unidades”, lo que nos indica que la distancia es de 100.000 metros, no de 100.000 pulgadas ni de ninguna otra medida de distancia.\nSe devuelve como una matriz, aunque el resultado sólo contenga un valor.\n\nEsta segunda característica indica otra característica útil de st_distance(), su capacidad para devolver matrices de distancia entre todas las combinaciones de características en los objetos x e y. Esto se ilustra en el siguiente comando, que encuentra las distancias entre las tres primeras características de nz_height y las regiones de Otago y Canterbury de Nueva Zelanda representadas por el objeto co.\n\nco = filter(nz, grepl(\"Canter|Otag\", Name))\nst_distance(nz_height[1:3, ], co)\n## Units: [m]\n##           [,1]     [,2]\n## [1,] 123537.16 15497.72\n## [2,]  94282.77     0.00\n## [3,]  93018.56     0.00\n\nObserve que la distancia entre la segunda y tercera características de nz_height y la segunda característica de co es cero. Esto demuestra el hecho de que las distancias entre puntos y polígonos se refieren a la distancia a cualquier parte del polígono: Los puntos segundo y tercero de nz_height están en Otago, lo que puede comprobarse trazándolos:\n\nplot(st_geometry(co)[2])\nplot(st_geometry(nz_height)[2:3], add = TRUE)"
  },
  {
    "objectID": "operaciones_espaciales.html#operaciones-espaciales-sobre-datos-ráster",
    "href": "operaciones_espaciales.html#operaciones-espaciales-sobre-datos-ráster",
    "title": "Operaciones espaciales",
    "section": "Operaciones espaciales sobre datos ráster",
    "text": "Operaciones espaciales sobre datos ráster\nEsta sección demuestra operaciones ráster más avanzadas y explícitamente espaciales con los objetos elev y grain del paquete spData.\n\nelev = rast(system.file(\"raster/elev.tif\", package = \"spData\"))\ngrain = rast(system.file(\"raster/grain.tif\", package = \"spData\"))\n\nSubdivisión espacial\nYa se vio cómo recuperar valores asociados con IDs de celdas específicas o combinaciones de filas y columnas. Los objetos ráster también pueden subdividirse por ubicación (coordenadas) y con otros objetos espaciales. Para utilizar coordenadas para realizar el subset, se pueden “traducir” las coordenadas a un ID de celda con la función terra cellFromXY(). Una alternativa es utilizar terra::extract() para extraer valores. Ambos métodos se demuestran a continuación para encontrar el valor de la celda que cubre un punto situado en las coordenadas (0.1, 0.1).\n\nid = cellFromXY(elev, xy = matrix(c(0.1, 0.1), ncol = 2))\nelev[id]\n# the same as\nterra::extract(elev, matrix(c(0.1, 0.1), ncol = 2))\n\n\n\n\nelev\n\n\n16\n\n\n\n\n\n\nelev\n\n\n16\n\n\n\n\n\nLos objetos ráster también se pueden subdividir con otro objeto ráster, como se demuestra en el fragmento de código siguiente:\n\nclip = rast(xmin = 0.9, xmax = 1.8, ymin = -0.45, ymax = 0.45,\n            resolution = 0.3, vals = rep(1, 9))\nelev[clip]\n# we can also use extract\n# terra::extract(elev, ext(clip))\n\n\n\n\nelev\n\n\n\n18\n\n\n24\n\n\n\n\n\n\nSe trata de recuperar los valores del primer objeto raster (en este caso, elev) que se encuentran dentro de la extensión de un segundo raster.\nEl ejemplo anterior devolvía los valores de celdas específicas, pero en muchos casos se necesitan salidas espaciales. Esto puede hacerse estableciendo el argumento drop del operador [ en FALSE. El siguiente código devuelve las dos primeras celdas de elev, es decir, las dos primeras celdas de la fila superior, como un objeto raster:\n\nelev[1:2, drop = FALSE]    # spatial subsetting with cell IDs\n## class       : SpatRaster \n## dimensions  : 1, 2, 1  (nrow, ncol, nlyr)\n## resolution  : 0.5, 0.5  (x, y)\n## extent      : -1.5, -0.5, 1, 1.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## varname     : elev \n## name        : elev \n## min value   :    1 \n## max value   :    2\n\n\n\n\n\n\nOtro caso de uso común del subset espacial es cuando un ráster con valores lógicos (o NA) se utiliza para enmascarar otro ráster con la misma extensión y resolución. En este caso, pueden utilizarse las funciones [ y mask() (resultados no mostrados):\n\n# create raster mask\nrmask = elev\nvalues(rmask) = sample(c(NA, TRUE), 36, replace = TRUE)\n\nEn el fragmento de código anterior, hemos creado un objeto máscara llamado rmask con valores asignados aleatoriamente a NA y TRUE. A continuación, queremos mantener los valores de elev que son TRUE en rmask. En otras palabras, queremos enmascarar elev con rmask.\n\n# spatial subsetting\nelev[rmask, drop = FALSE]           # with [ operator\nmask(elev, rmask)                   # with mask()\n\nEl enfoque anterior también se puede utilizar para sustituir algunos valores (por ejemplo, los que se espera que sean erróneos) por NA.\n\nelev[elev &lt; 20] = NA\n\nEstas operaciones son, de hecho, operaciones locales booleanas, ya que comparamos celda por celda dos rásters. En la siguiente subsección se analizan con más detalle estas operaciones y otras relacionadas.\nÁlgebra de mapas\nEl término ‘álgebra de mapas’ se acuñó a finales de la década de 1970 para describir un “conjunto de convenciones, capacidades y técnicas” para el análisis de datos geográficos ráster y (aunque con menos prominencia) vectoriales. En este contexto, definimos el álgebra de mapas de forma más restringida, como operaciones que modifican o resumen valores de celdas ráster, con referencia a celdas circundantes, zonas o funciones estadísticas que se aplican a cada celda.\nLas operaciones de álgebra de mapas suelen ser rápidas, porque los conjuntos de datos ráster sólo almacenan implícitamente coordenadas. La ubicación de las celdas en los conjuntos de datos ráster puede calcularse utilizando su posición matricial y la resolución y origen del conjunto de datos (almacenados en la cabecera). Para el procesamiento, sin embargo, la posición geográfica de una celda apenas es relevante, siempre y cuando nos aseguremos de que la posición de la celda sigue siendo la misma después del procesamiento. Además, si dos o más conjuntos de datos ráster comparten la misma extensión, proyección y resolución, se podrían tratar como matrices.\nAsí funciona el álgebra de mapas con el paquete terra. En primer lugar, se consultan las cabeceras de los conjuntos de datos ráster y se comprueba que los conjuntos de datos sean compatibles. En segundo lugar, el álgebra de mapas mantiene la llamada correspondencia de localización uno a uno, lo que significa que las celdas no pueden moverse. Esto difiere del álgebra matricial, en la que los valores cambian de posición, por ejemplo al multiplicar o dividir matrices.\nEl álgebra de mapas divide las operaciones ráster en cuatro subclases:\n\nOperaciones locales o por celda\n\nOperaciones focales o de vecindad. Lo más frecuente es que el valor de la celda de salida sea el resultado de un bloque de celdas de entrada de 3 x 3\n\nLas operaciones zonales son similares a las operaciones focales, pero la cuadrícula de píxeles circundante sobre la que se calculan los nuevos valores puede tener tamaños y formas irregulares\n\nOperaciones globales o per-raster. Esto significa que la celda de salida puede derivar su valor de uno o varios rásters completos.\nOperaciones locales\nLas operaciones locales comprenden todas las operaciones celda por celda en una o varias capas. El álgebra ráster es un caso de uso clásico de las operaciones locales, que incluye la suma o resta de valores de un ráster, el cuadrado y la multiplicación de rásters. El álgebra raster también permite realizar operaciones lógicas, como encontrar todas las celdas que superen un valor determinado. El paquete terra admite todas estas operaciones y más, como se muestra a continuación:\n\nelev + elev\nelev^2\nlog(elev)\nelev &gt; 5\n\nOtro buen ejemplo de operaciones locales es la clasificación de intervalos de valores numéricos en grupos, como la agrupación de un modelo digital de elevación en elevaciones bajas (clase 1), medias (clase 2) y altas (clase 3). Para utilizar el comando classify(), necesitamos primero construir una matriz de reclasificación, donde la primera columna corresponde al extremo inferior y la segunda columna al extremo superior de la clase. La tercera columna representa el nuevo valor para los rangos especificados en las columnas uno y dos.\n\nrcl = matrix(c(0, 12, 1, 12, 24, 2, 24, 36, 3), ncol = 3, byrow = TRUE)\nrcl\n##      [,1] [,2] [,3]\n## [1,]    0   12    1\n## [2,]   12   24    2\n## [3,]   24   36    3\n\nAquí, los valores ráster en los rangos 0–12, 12–24 y 24–36 se reclasifican para tomar los valores 1, 2 y 3, respectivamente.\n\nrecl = classify(elev, rcl = rcl)\n\nLa función classify() también puede utilizarse cuando queremos reducir el número de clases en nuestros rásters categóricos.\nAdemás de los operadores aritméticos, también se pueden utilizar las funciones app(), tapp() y lapp(). Son más eficientes, por lo que son preferibles en presencia de grandes conjuntos de datos ráster. Además, permiten guardar directamente un archivo de salida. La función app() aplica una función a cada celda de un raster y se utiliza para resumir (por ejemplo, calculando la suma) los valores de múltiples capas en una sola capa. La función tapp() es una extensión de app() que nos permite seleccionar un subconjunto de capas (véase el argumento index) para las que queremos realizar una determinada operación. Por último, la función lapp() permite aplicar una función a cada celda utilizando las capas como argumentos – a continuación se presenta una aplicación de lapp().\nEl cálculo del índice de vegetación de diferencia normalizada (NDVI) es una conocida operación de raster local (píxel a píxel). Devuelve un raster con valores entre -1 y 1; los valores positivos indican la presencia de plantas vivas (en su mayoría &gt; 0.2). El NDVI se calcula a partir de las bandas roja e infrarroja cercana (NIR) de imágenes satelitales.\n\\[\n\\begin{split}\nNDVI&= \\frac{\\text{NIR} - \\text{Red}}{\\text{NIR} + \\text{Red}}\\\\\n\\end{split}\n\\]\nCalculemos el NDVI para el archivo de satélite multiespectral del Parque Nacional de Zion.\n\nmulti_raster_file = system.file(\"raster/landsat.tif\", package = \"spDataLarge\")\nmulti_rast = rast(multi_raster_file)\n\nEl objeto raster tiene cuatro bandas de satélite: azul, verde, rojo e infrarrojo cercano (NIR). Nuestro siguiente paso será implementar la fórmula NDVI en una función de R:\n\nndvi_fun = function(nir, red){\n  (nir - red) / (nir + red)\n}\n\nEsta función acepta dos argumentos numéricos, nir y red, y devuelve un vector numérico con valores NDVI. Puede utilizarse como argumento fun de lapp(). Sólo tenemos que recordar que nuestra función sólo necesita dos bandas (no cuatro de la trama original), y tienen que estar en el orden NIR, rojo. Por eso, antes de hacer los cálculos, se hace un subconjunto del raster de entrada con multi_rast[[c(4, 3)]].\n\nndvi_rast = lapp(multi_rast[[c(4, 3)]], fun = ndvi_fun)\nplot(ndvi_rast)\n\n\n\n\nLa cartografía predictiva es otra aplicación interesante de las operaciones raster locales. La variable de respuesta corresponde a puntos medidos u observados en el espacio, por ejemplo, la riqueza de especies, la presencia de corrimientos de tierras, la enfermedad de los árboles o el rendimiento de los cultivos. Por consiguiente, podemos recuperar fácilmente variables predictoras espaciales o aéreas a partir de diversos rásters (elevación, pH, precipitaciones, temperatura, cubierta vegetal, clase de suelo, etc.). A continuación, modelizamos nuestra respuesta en función de nuestros predictores mediante lm(), glm(), gam() o una técnica de aprendizaje automático. Por tanto, las predicciones espaciales sobre objetos ráster pueden realizarse aplicando coeficientes estimados a los valores ráster predictores y sumando los valores ráster de salida.\nOperaciones focales\nMientras que las funciones locales operan sobre una celda, aunque posiblemente de varias capas, las operaciones focales tienen en cuenta una celda central (focal) y sus vecinas. El vecindario (también denominado núcleo, filtro o ventana móvil) considerado suele tener un tamaño de 3 por 3 celdas (es decir, la celda central y sus ocho vecinas circundantes), pero puede adoptar cualquier otra forma (no necesariamente rectangular) definida por el usuario. Una operación focal aplica una función de agregación a todas las celdas dentro del vecindario especificado, utiliza el resultado correspondiente como nuevo valor para la celda central y pasa a la siguiente celda central. Otros nombres para esta operación son filtrado espacial y convolución.\n\nEn R, podemos utilizar la función focal() para realizar el filtrado espacial. Definimos la forma de la ventana móvil con una “matriz” cuyos valores corresponden a los pesos (véase el parámetro “w” en el fragmento de código siguiente). En segundo lugar, el parámetro fun nos permite especificar la función que deseamos aplicar a este vecindario. Aquí, elegimos el mínimo, pero cualquier otra función de resumen, incluyendo sum(), mean(), o var() se puede utilizar.\n\nr_focal = focal(elev, w = matrix(1, nrow = 3, ncol = 3), fun = min)\n\nEsta función también acepta argumentos adicionales, por ejemplo, si debe eliminar los NA en el proceso (na.rm = TRUE) o no (na.rm = FALSE).\nOperaciones zonales\nAl igual que las operaciones focales, las operaciones zonales aplican una función de agregación a múltiples celdas de trama. Sin embargo, un segundo ráster, normalmente con valores categóricos, define los filtros zonales (o “zonas”), a diferencia de una ventana de vecindad predefinida en el caso de la operación focal presentada en la sección anterior. Por consiguiente, las celdas del ráster que definen el filtro zonal no tienen por qué ser necesariamente vecinas. Nuestro ráster de tamaño de grano es un buen ejemplo: los diferentes tamaños de grano están repartidos irregularmente por todo el ráster. Por último, el resultado de una operación zonal es una tabla resumen agrupada por zonas, razón por la cual esta operación también se conoce como estadística zonal en el mundo SIG. Esto contrasta con las operaciones focales que devuelven un objeto raster.\nEl siguiente fragmento de código utiliza la función zonal() para calcular la elevación media asociada a cada clase de tamaño de grano, por ejemplo.\n\nz = zonal(elev, grain, fun = \"mean\")\nz\n\n\n\n\ngrain\nelev\n\n\n\nclay\n14.80000\n\n\nsilt\n21.15385\n\n\nsand\n18.69231\n\n\n\n\n\n\nNota: también es posible obtener un raster con estadísticas calculadas para cada zona estableciendo el argumento as.raster a TRUE.\nOperaciones globales\nLas operaciones globales son un caso especial de las operaciones zonales, en las que todo el conjunto de datos ráster representa una única zona. Las operaciones globales más comunes son las estadísticas descriptivas para todo el conjunto de datos ráster.\nFusión de rásters\nSupongamos que queremos calcular el NDVI, y además queremos calcular atributos del terreno a partir de datos de elevación para observaciones dentro de un área de estudio. Estos cálculos se basan en información obtenida por teledetección. Las imágenes correspondientes suelen dividirse en escenas que cubren una extensión espacial específica y, con frecuencia, un área de estudio abarca más de una escena. Entonces, tendríamos que fusionar las escenas cubiertas por nuestra zona de estudio. En el caso más sencillo, basta con fusionar las escenas, es decir, ponerlas una al lado de la otra. Esto es posible, por ejemplo, con datos digitales de elevación (SRTM, ASTER). En el siguiente fragmento de código descargamos primero los datos de elevación SRTM de Austria y Suiza (para los códigos de país, véase la función geodata country_codes()). En un segundo paso, fusionamos los dos rásters en uno.\n\naut = geodata::elevation_30s(country = \"AUT\", path = tempdir())\nch = geodata::elevation_30s(country = \"CHE\", path = tempdir())\naut_ch = merge(aut, ch)\n\nEl comando merge() de terra combina dos imágenes y, en caso de que se solapen, utiliza el valor de la primera trama."
  },
  {
    "objectID": "reproyeccion.html",
    "href": "reproyeccion.html",
    "title": "Reproyeccion",
    "section": "",
    "text": "library(sf)\nlibrary(terra)\nlibrary(dplyr)\nlibrary(spData)\nlibrary(spDataLarge)"
  },
  {
    "objectID": "reproyeccion.html#introducción",
    "href": "reproyeccion.html#introducción",
    "title": "Reproyeccion",
    "section": "Introducción",
    "text": "Introducción\nLos sistemas de referencia de coordenadas (SRC) pueden ser de dos tipos principales: sistemas de coordenadas geográficas (‘lon/lat’, con unidades en grados de longitud y latitud) y proyectadas (normalmente con unidades de metros desde un datum). Este capítulo demuestra cómo establecer y transformar datos geográficos de un CRS a otro y, además, destaca problemas específicos que pueden surgir debido a ignorar CRSs y que deberías tener en cuenta, especialmente si tus datos se almacenan con coordenadas lon/lat.\nEn muchos proyectos no hay necesidad de preocuparse por los diferentes CRS, y mucho menos de realizar conversiones entre ellos. Sin embargo, si conoces el CRS de tus datos y las consecuencias para las operaciones geométricas (tratadas en la siguiente sección), los CRSs deberían simplemente funcionar entre bastidores: la gente a menudo necesita aprender de repente sobre los CRSs cuando las cosas van mal. Tener un CRS claramente definido en el que estén todos los datos del proyecto, además de entender cómo y por qué usar diferentes CRSs, puede asegurar que las cosas no vayan mal.\nEste capítulo enseña los fundamentos de los CRS, demuestra las consecuencias de utilizar diferentes CRS (incluyendo lo que puede salir mal) y cómo “reproyectar” conjuntos de datos de un sistema de coordenadas a otro. En las siguientes secciones introducimos los CRSs en R, cómo obtener y establecer CRSs asociados con objetos espaciales, cuándo reproyectar y qué CRS utilizar, entre otras cosas."
  },
  {
    "objectID": "reproyeccion.html#sistemas-de-referencia-de-coordenadas",
    "href": "reproyeccion.html#sistemas-de-referencia-de-coordenadas",
    "title": "Reproyeccion",
    "section": "Sistemas de referencia de coordenadas",
    "text": "Sistemas de referencia de coordenadas\nLa mayoría de las herramientas geográficas modernas que requieren conversiones de CRS, incluidos los paquetes básicos de R-spatial y el software SIG de escritorio como QGIS, interactúan con PROJ, una biblioteca C++ de código abierto que “transforma coordenadas de un sistema de referencia de coordenadas (CRS) a otro”. Los CRS pueden describirse de muchas maneras, entre las que se incluyen las siguientes.\n\nEnunciados simples pero potencialmente ambiguos como “está en coordenadas lon/lat”.\n“proj4 strings” formalizadas, aunque ya obsoletas, como +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs.\nCon una cadena de texto identificativa “authority:code” como EPSG:4326.\n\nCada una de ellas hace referencia a lo mismo: el sistema de coordenadas “WGS84” que constituye la base de las coordenadas del Sistema de Posicionamiento Global (GPS) y de muchos otros conjuntos de datos. Pero, ¿cuál es el correcto?\nLa respuesta corta es que la tercera forma de identificar los CRS es preferible: Los paquetes sf (y por extensión stars) y terra, además de muchos otros proyectos de software para trabajar con datos geográficos, entienden EPSG:4326. Además, es corto, fácil de recordar y muy ‘localizable’ en línea. sf entiende el identificador más conciso 4326, pero recomendamos la representación más explícita AUTHORITY:CODE para evitar ambigüedades y proporcionar contexto.\nLa respuesta más larga es que ninguna de las tres descripciones es suficiente y se necesitan más detalles para manejar y transformar los CRS sin ambigüedades: debido a la complejidad de los SIR, no es posible capturar toda la información relevante sobre ellos en cadenas de texto tan cortas. Por este motivo, el Open Geospatial Consortium desarrolló un formato estándar abierto que se denomina WKT (Well-Known Text). Esto se detalla en un documento de más de 100 páginas que “define la estructura y el contenido de una implementación de cadena de texto del modelo abstracto para sistemas de referencia de coordenadas descrito en ISO 19111:2019”. La representación WKT del SIR WGS84, que tiene el identificador EPSG:4326 es la siguiente:\n\nst_crs(\"EPSG:4326\")\n## Coordinate Reference System:\n##   User input: EPSG:4326 \n##   wkt:\n## GEOGCRS[\"WGS 84\",\n##     ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n##         MEMBER[\"World Geodetic System 1984 (Transit)\"],\n##         MEMBER[\"World Geodetic System 1984 (G730)\"],\n##         MEMBER[\"World Geodetic System 1984 (G873)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1150)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1674)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1762)\"],\n##         MEMBER[\"World Geodetic System 1984 (G2139)\"],\n##         ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n##             LENGTHUNIT[\"metre\",1]],\n##         ENSEMBLEACCURACY[2.0]],\n##     PRIMEM[\"Greenwich\",0,\n##         ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     CS[ellipsoidal,2],\n##         AXIS[\"geodetic latitude (Lat)\",north,\n##             ORDER[1],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##         AXIS[\"geodetic longitude (Lon)\",east,\n##             ORDER[2],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     USAGE[\n##         SCOPE[\"Horizontal component of 3D system.\"],\n##         AREA[\"World.\"],\n##         BBOX[-90,-180,90,180]],\n##     ID[\"EPSG\",4326]]\n\nLa convención de referirse a los identificadores CRSs de la forma AUTORIDAD:CÓDIGO, que también es utilizada por el software geográfico escrito en otros lenguajes, permite referirse a una amplia gama de sistemas de coordenadas formalmente definidos.1 La autoridad más utilizada en los identificadores CRS es EPSG, acrónimo de European Petroleum Survey Group, que publicó una lista normalizada de CRS (el EPSG fue absorbido por el organismo de petróleo y gas el Comité de Geomática de la Asociación Internacional de Productores de Petróleo y Gas en 2005). Pueden utilizarse otras autoridades en los identificadores SIR. ESRI:54030, por ejemplo, se refiere a la implementación de ESRI de la proyección Robinson, que tiene la siguiente cadena WKT (sólo se muestran las 8 primeras líneas):\n\nst_crs(\"ESRI:54030\")\n#&gt; Coordinate Reference System:\n#&gt;   User input: ESRI:54030 \n#&gt;   wkt:\n#&gt; PROJCRS[\"World_Robinson\",\n#&gt;     BASEGEOGCRS[\"WGS 84\",\n#&gt;         DATUM[\"World Geodetic System 1984\",\n#&gt;             ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n#&gt;                 LENGTHUNIT[\"metre\",1]]],\n#&gt; ...\n\nLas cadenas WKT son exhaustivas, detalladas y precisas, y permiten almacenar y transformar los SIR sin ambigüedades. Contienen toda la información relevante sobre cualquier SIR, incluido su datum y elipsoide, meridiano principal, proyección y unidades. Antes de la aparición de las definiciones WKT CRS, proj-string era la forma estándar de especificar operaciones de coordenadas y almacenar CRSs. Estas representaciones de cadena, construidas sobre una forma clave=valor (por ejemplo, +proj=longlat +datum=WGS84 +no_defs), ya han sido, o deberían ser en el futuro, sustituidas por representaciones WKT en la mayoría de los casos.\nLas versiones recientes de PROJ (6+) todavía permiten el uso de proj-strings para definir operaciones de coordenadas, pero algunas claves proj-string (+nadgrids, +towgs84, +k, +init=epsg:) ya no se soportan o se desaconsejan."
  },
  {
    "objectID": "reproyeccion.html#crs-setting",
    "href": "reproyeccion.html#crs-setting",
    "title": "Reproyeccion",
    "section": "Consulta y establecimiento de sistemas de coordenadas",
    "text": "Consulta y establecimiento de sistemas de coordenadas\nVeamos cómo se almacenan los CRS en los objetos espaciales de R y cómo pueden consultarse y establecerse. Primero veremos cómo obtener y establecer CRS en objetos geográficos vector, comenzando con el siguiente ejemplo:\n\nvector_filepath = system.file(\"shapes/world.gpkg\", package = \"spData\")\nnew_vector = read_sf(vector_filepath)\n\nEl CRS puede recuperarse con la función sf st_crs().\n\nst_crs(new_vector) # get CRS\n#&gt; Coordinate Reference System:\n#&gt;   User input: WGS 84 \n#&gt;   wkt:\n#&gt;   ...\n\nLa salida es una lista que contiene dos componentes principales:\n\n\nUser input (en este caso WGS 84, un sinónimo de EPSG:4326 que en este caso se tomó del fichero de entrada), correspondiente a los identificadores CRS descritos anteriormente\n\nwkt, que contiene la cadena WKT completa con toda la información pertinente sobre el CRS.\n\nEl elemento input es flexible, y dependiendo del fichero de entrada o de la entrada del usuario, puede contener la representación AUTHORITY:CODE (por ejemplo, EPSG:4326), el nombre del CRS (por ejemplo, WGS 84), o incluso la definición proj-string. El elemento wkt almacena la representación WKT, que se utiliza al guardar el objeto en un archivo o al realizar cualquier operación de coordenadas. Arriba, podemos ver que el objeto new_vector tiene el elipsoide WGS84, utiliza el meridiano de Greenwich, y el orden de los ejes de latitud y longitud. En este caso, también tenemos algunos elementos adicionales, como USAGE que explica el área adecuada para el uso de este CRS, e ID que señala el identificador del CRS: EPSG:4326.\nLa función st_crs también tiene una característica útil: podemos recuperar información adicional sobre el CRS utilizado. Por ejemplo, intente ejecutar\n\n\nst_crs(new_vector)$IsGeographic para comprobar si el CRS es geográfico o no\n\nst_crs(new_vector)$units_gdal para averiguar las unidades del CRS\n\nst_crs(new_vector)$srid extrae su identificador “SRID” (si está disponible)\n\nst_crs(new_vector)$proj4string extrae la representación proj-string\n\nEn los casos en los que falta un sistema de referencia de coordenadas (CRS) o se establece un CRS incorrecto, se puede utilizar la función st_set_crs():\n\nnew_vector = st_set_crs(new_vector, \"EPSG:4326\") # set CRS\n\nLa obtención y configuración de los CRS funciona de forma similar para los objetos ráster. La función crs() del paquete terra accede a la información CRS de un objeto SpatRaster (nótese el uso de la función cat() para imprimirla correctamente):\n\nraster_filepath = system.file(\"raster/srtm.tif\", package = \"spDataLarge\")\nmy_rast = rast(raster_filepath)\ncat(crs(my_rast)) # get CRS\n## GEOGCRS[\"WGS 84\",\n##     ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n##         MEMBER[\"World Geodetic System 1984 (Transit)\"],\n##         MEMBER[\"World Geodetic System 1984 (G730)\"],\n##         MEMBER[\"World Geodetic System 1984 (G873)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1150)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1674)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1762)\"],\n##         MEMBER[\"World Geodetic System 1984 (G2139)\"],\n##         ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n##             LENGTHUNIT[\"metre\",1]],\n##         ENSEMBLEACCURACY[2.0]],\n##     PRIMEM[\"Greenwich\",0,\n##         ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     CS[ellipsoidal,2],\n##         AXIS[\"geodetic latitude (Lat)\",north,\n##             ORDER[1],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##         AXIS[\"geodetic longitude (Lon)\",east,\n##             ORDER[2],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     USAGE[\n##         SCOPE[\"Horizontal component of 3D system.\"],\n##         AREA[\"World.\"],\n##         BBOX[-90,-180,90,180]],\n##     ID[\"EPSG\",4326]]\n\nLa salida es la representación de cadena WKT de CRS. La misma función, crs(), también se puede utilizar para establecer un CRS para objetos raster.\n\ncrs(my_rast) = \"EPSG:26912\" # set CRS\n\nEs importante destacar que las funciones st_crs() y crs() no alteran los valores de las coordenadas ni las geometrías. Su función es únicamente establecer una información de metadatos sobre el CRS del objeto.\nEn algunos casos, el CRS de un objeto geográfico es desconocido, como es el caso del conjunto de datos london creado en el fragmento de código siguiente:\n\nlondon = data.frame(lon = -0.1, lat = 51.5) |&gt; \n  st_as_sf(coords = c(\"lon\", \"lat\"))\nst_is_longlat(london)\n## [1] NA\n\nLa salida NA muestra que sf no sabe cuál es el CRS y no está dispuesto a adivinarlo (NA significa literalmente ‘no disponible’). A menos que un CRS se especifique manualmente o se cargue desde una fuente que tenga metadatos CRS, sf no hace ninguna suposición explícita sobre qué sistemas de coordenadas, aparte de decir “no lo sé”. Este comportamiento tiene sentido dada la diversidad de CRS disponibles, pero difiere de algunos enfoques, como la especificación del formato de archivo GeoJSON, que hace la suposición simplificadora de que todas las coordenadas tienen un CRS lon/lat: EPSG:4326. Los conjuntos de datos sin un CRS especificado pueden causar problemas: todas las coordenadas geográficas tienen un sistema de coordenadas y el software sólo puede tomar decisiones correctas sobre el trazado y las operaciones geométricas si sabe con qué tipo de CRS está trabajando. Por lo tanto, de nuevo, es importante comprobar siempre el CRS de un conjunto de datos y establecerlo si falta.\n\nlondon_geo = st_set_crs(london, \"EPSG:4326\")\nst_is_longlat(london_geo)\n## [1] TRUE"
  },
  {
    "objectID": "reproyeccion.html#geom-proj",
    "href": "reproyeccion.html#geom-proj",
    "title": "Reproyeccion",
    "section": "Operaciones geométricas sobre datos proyectados y no proyectados",
    "text": "Operaciones geométricas sobre datos proyectados y no proyectados\nDesde la versión 1.0.0 de sf, la capacidad de R para trabajar con conjuntos de datos vectoriales geográficos que tienen CRS lon/lat ha mejorado sustancialmente, gracias a su integración con el motor de geometría esférica S2. GEOS se utiliza siempre para datos proyectados y datos sin CRS; para datos geográficos se utiliza S2 por defecto, pero puede desactivarse con sf::sf_use_s2(FALSE).\nPara demostrar la importancia de los SIR, crearemos un búfer de 100 km alrededor del objeto “Londres” de la sección anterior. También crearemos un búfer deliberadamente defectuoso con una “distancia” de 1 grado, que equivale aproximadamente a 100 km (1 grado son unos 111 km en el ecuador).\nLa primera etapa consiste en crear tres buffers alrededor de los objetos london y london_geo creados anteriormente con distancias límite de 1 grado y 100 km (o 100.000 m, que puede expresarse como 1e5 en notación científica) desde el centro de Londres:\n\nlondon_buff_no_crs = st_buffer(london, dist = 1)   # incorrect: no CRS\nlondon_buff_s2 = st_buffer(london_geo, dist = 100000) # silent use of s2\nlondon_buff_s2_100_cells = st_buffer(london_geo, dist = 100000, max_cells = 100) \n\nEn la primera línea de arriba, sf asume que la entrada es proyectada y genera un resultado que tiene un buffer en unidades de grados, lo cual es problemático, como veremos. En la segunda línea, sf usa silenciosamente el motor de geometría esférica S2 para calcular la extensión del buffer usando el valor por defecto de max_cells = 1000 — fijado a 100 en la línea tres — las consecuencias se harán evidentes en breve (ver ?s2::s2_buffer_cells para más detalles).\nPara resaltar el impacto del uso del motor de geometría S2 por sf para sistemas de coordenadas (geográficas) no proyectadas, lo desactivaremos temporalmente con el comando sf_use_s2() (que está activado, TRUE, por defecto), en el trozo de código que sigue. Al igual que london_buff_no_crs, el nuevo objeto london_geo es una abominación geográfica: tiene unidades de grados, lo que no tiene sentido en la gran mayoría de los casos:\n\nsf::sf_use_s2(FALSE)\nlondon_buff_lonlat = st_buffer(london_geo, dist = 1) # incorrect result\nsf::sf_use_s2(TRUE)\n\nEl mensaje de advertencia anterior indica problemas al realizar operaciones geométricas planas en datos lon/lat. Cuando las operaciones de geometría esférica están desactivadas, con el comando sf::sf_use_s2(FALSE), los buffers (y otras operaciones geométricas) pueden dar como resultado salidas sin valor porque utilizan unidades de latitud y longitud, un mal sustituto de las unidades adecuadas de distancias como los metros.\n\n\n\n\n\n\nNota\n\n\n\nLa distancia entre dos líneas de longitud, llamadas meridianos, es de unos 111 km en el ecuador (ejecute geosphere::distGeo(c(0, 0), c(1, 0)) para encontrar la distancia exacta). En los polos se reduce a cero. En la latitud de Londres, por ejemplo, los meridianos están a menos de 70 km de distancia.\nLas líneas de latitud, por el contrario, son equidistantes entre sí independientemente de la latitud: siempre están separadas unos 111 km, incluso en el ecuador y cerca de los polos.\n\n\nPara las operaciones que implican distancias, como el buffering, la única forma de garantizar un buen resultado (sin utilizar motores de geometría esférica) es crear una copia proyectada de los datos y ejecutar la operación sobre ella.\n\nlondon_proj = data.frame(x = 530000, y = 180000) |&gt; \n  st_as_sf(coords = c(\"x\", \"y\"), crs = \"EPSG:27700\")\n\nEl resultado es un nuevo objeto idéntico a london, pero reproyectado sobre un CRS adecuado (la British National Grid, que tiene un código EPSG de 27700 en este caso) que tiene unidades de metros. Podemos verificar que el CRS ha cambiado usando st_crs() como sigue (parte de la salida ha sido reemplazada por ...):\n\nst_crs(london_proj)\n#&gt; Coordinate Reference System:\n#&gt;   User input: EPSG:27700 \n#&gt;   wkt:\n#&gt; PROJCRS[\"OSGB36 / British National Grid\",\n#&gt;     BASEGEOGCRS[\"OSGB36\",\n#&gt;         DATUM[\"Ordnance Survey of Great Britain 1936\",\n#&gt;             ELLIPSOID[\"Airy 1830\",6377563.396,299.3249646,\n#&gt;                 LENGTHUNIT[\"metre\",1]]],\n#&gt; ...\n\nEntre los componentes más destacados de esta descripción se incluyen el código EPSG (EPSG: 27700) y la cadena detallada wkt (de la que sólo se muestran las 5 primeras líneas). El hecho de que las unidades del CRS, descritas en el campo LENGTHUNIT, sean metros (en lugar de grados) nos indica que se trata de un CRS proyectado: st_is_longlat(london_proj) devuelve ahora FALSE y las operaciones geométricas sobre london_proj funcionarán sin advertencia. Las operaciones de buffer sobre london_proj utilizarán GEOS y los resultados se devolverán con las unidades de distancia adecuadas. La siguiente línea de código crea un buffer alrededor de datos proyectados de exactamente 100 km:\n\nlondon_buff_projected = st_buffer(london_proj, 100000)\n\nLas geometrías de los tres objetos london_buff* que tienen un CRS especificado creados anteriormente (london_buff_s2, london_buff_lonlat y london_buff_projected) creados en los trozos de código anteriores se ilustran en la Figura @ref(fig:crs-buf).\n\n\n\n\nBuffers around London showing results created with the S2 spherical geometry engine on lon/lat data (left), projected data (middle) and lon/lat data without using spherical geometry (right). The left plot illustrates the result of buffering unprojected data with sf, which calls Google’s S2 spherical geometry engine by default with max cells set to 1000 (thin line). The thick ‘blocky’ line illustrates the result of the same operation with max cells set to 100.\n\n\n\nSe ve claramente que los búferes basados en s2 y CRS proyectados correctamente no están “aplastados”, lo que significa que cada parte del límite del búfer es equidistante de Londres. Los resultados generados a partir de CRSs lon/lat cuando no se utiliza s2, ya sea porque la entrada carece de CRS o porque sf_use_s2() está desactivada, están muy distorsionados, con el resultado alargado en el eje norte-sur, lo que pone de manifiesto los peligros de utilizar algoritmos que asumen datos proyectados en entradas lon/lat (como hace GEOS). Sin embargo, los resultados generados con S2 también están distorsionados, aunque de forma menos dramática. Los dos límites de los búferes de la figura izquierda están dentados, aunque esto sólo puede ser evidente o relevante en el caso del límite grueso que representa un búfer creado con el argumento s2 max_cells fijado en 100. La lección es que los resultados obtenidos a partir de datos lon/lat con S2 también están distorsionados, aunque de forma menos dramática. La lección es que los resultados obtenidos a partir de datos lon/lat mediante S2 serán diferentes de los resultados obtenidos utilizando datos proyectados. La diferencia entre los buffers derivados de S2 y los buffers derivados de GEOS sobre datos proyectados se reducen a medida que aumenta el valor de max_cells: el valor “correcto” para este argumento puede depender de muchos factores y el valor por defecto 1000 es un valor por defecto razonable. Al elegir los valores de max_cells, la velocidad de cálculo debe equilibrarse con la resolución de los resultados. En situaciones en las que los límites curvos son ventajosos, puede ser apropiado transformar a un CRS proyectado antes de almacenar (o realizar otras operaciones geométricas).\nLa importancia de los CRS (principalmente si son proyectados o geográficos) y los impactos de la configuración por defecto de sf de utilizar S2 para los buffers en los datos lon/lat quedan claros en el ejemplo anterior. En las secciones siguientes se profundiza en qué CRS utilizar cuando se necesitan CRS proyectados y en los detalles de la reproyección de objetos vectoriales y ráster."
  },
  {
    "objectID": "reproyeccion.html#cuándo-reproyectar",
    "href": "reproyeccion.html#cuándo-reproyectar",
    "title": "Reproyeccion",
    "section": "¿Cuándo reproyectar?",
    "text": "¿Cuándo reproyectar?\nLa sección anterior mostraba cómo establecer el CRS manualmente, con st_set_crs(london, \"EPSG:4326\"). Sin embargo, en las aplicaciones del mundo real, los CRS suelen establecerse automáticamente cuando se leen los datos. En muchos proyectos, la principal tarea relacionada con los CRS es transformar objetos, de un CRS a otro. Pero, ¿cuándo deben transformarse los datos? ¿Y en qué CRS? No hay respuestas claras a estas preguntas y la selección del CRS siempre implica compromisos. Sin embargo, se ofrecen algunos principios generales que pueden ayudarle a decidir.\nEn primer lugar, merece la pena considerar cuándo transformar. En algunos casos la transformación a un CRS geográfico es esencial, como cuando se publican datos en línea con el paquete leaflet. Otro caso es cuando hay que comparar o combinar dos objetos con diferentes CRS, como cuando intentamos encontrar la distancia entre dos objetos con diferentes CRS:\n\nst_distance(london_geo, london_proj)\n# &gt; Error: st_crs(x) == st_crs(y) is not TRUE\n\nPara que los objetos london y london_proj sean geográficamente comparables, uno de ellos debe transformarse en el CRS del otro. Pero, ¿qué CRS utilizar? La respuesta depende del contexto: muchos proyectos, especialmente los de cartografía web, requieren salidas en EPSG:4326, en cuyo caso merece la pena transformar el objeto proyectado. Si, por el contrario, el proyecto requiere operaciones de geometría plana en lugar del motor de operaciones de geometría esférica (por ejemplo, para crear buffers con bordes suaves), puede merecer la pena transformar los datos con un CRS geográfico en un objeto equivalente con un CRS proyectado, como la British National Grid (EPSG:27700)."
  },
  {
    "objectID": "reproyeccion.html#qué-crs-utilizar",
    "href": "reproyeccion.html#qué-crs-utilizar",
    "title": "Reproyeccion",
    "section": "¿Qué CRS utilizar?",
    "text": "¿Qué CRS utilizar?\nLa cuestión de qué CRS es delicada, y rara vez hay una respuesta “correcta”: “No existen proyecciones que sirvan para todo, todas implican distorsión cuando se alejan del centro del marco especificado”.\nA la hora de seleccionar CRS geográficos, la respuesta suele ser WGS84. Se utiliza no sólo para la cartografía web, sino también porque los conjuntos de datos GPS y miles de conjuntos de datos ráster y vectoriales se proporcionan por defecto en este CRS. WGS84 es el CRS más común en el mundo, por lo que conviene conocer su código EPSG: 4326. Este “número mágico” puede utilizarse para convertir objetos con CRS proyectados inusuales en algo que se entienda ampliamente.\n¿Qué ocurre cuando se necesita un CRS proyectado? En algunos casos, no es algo que podamos decidir libremente: “a menudo, la elección de la proyección corre a cargo de un organismo cartográfico público”. Esto significa que, al trabajar con fuentes de datos locales, probablemente sea preferible trabajar con el CRS en el que se proporcionaron los datos, para garantizar la compatibilidad, aunque el CRS oficial no sea el más preciso.\nUna proyección utilizada habitualmente por defecto es la Universal Transverse Mercator (UTM), un conjunto de CRS que divide la Tierra en 60 cuñas longitudinales y 20 segmentos latitudinales. La proyección transversal de Mercator utilizada por los CRSs UTM es conforme pero distorsiona áreas y distancias con severidad creciente con la distancia desde el centro de la zona UTM. Por lo tanto, ¡recomendamos utilizar UTM sólo cuando su objetivo sea preservar los ángulos de un área relativamente pequeña!\nCasi todos los lugares de la Tierra tienen un código UTM, como “60H”, que se refiere al norte de Nueva Zelanda, donde se inventó R. Los códigos EPSG de UTM van secuencialmente de 32601 a 32660 para los lugares del hemisferio norte y de 32701 a 32760 para los lugares del hemisferio sur.\nPara mostrar cómo funciona el sistema, vamos a crear una función, lonlat2UTM() para calcular el código EPSG asociado a cualquier punto del planeta como sigue:\n\nlonlat2UTM = function(lonlat) {\n  utm = (floor((lonlat[1] + 180) / 6) %% 60) + 1\n  if (lonlat[2] &gt; 0) {\n    utm + 32600\n  } else{\n    utm + 32700\n  }\n}\n\nEl siguiente comando utiliza esta función para identificar la zona UTM y el código EPSG asociado para Auckland y Londres:\n\nlonlat2UTM(c(174.7, -36.9))\nlonlat2UTM(st_coordinates(london))\n## [1] 32760\n## [1] 32630\n\nActualmente, también disponemos de herramientas que nos ayudan a seleccionar un CRS adecuado, entre las que se incluye el paquete crssuggest. La función principal de este paquete, suggest_crs(), toma un objeto espacial con CRS geográfico y devuelve una lista de posibles CRS proyectados que podrían utilizarse para el área dada.2. Otra herramienta útil es una página web https://jjimenezshaw.github.io/crs-explorer/ que enumera los CRS en función de la ubicación y el tipo seleccionados.\nEn los casos en los que no esté claro cuál es el CRS adecuado, la elección del CRS debe depender de las propiedades que sea más importante preservar en los mapas y análisis posteriores. Todos los CRS son de igual área, equidistantes, conformes (con formas que permanecen inalteradas), o alguna combinación de los mismos. Pueden crearse CRS personalizados con parámetros locales para una región de interés y pueden utilizarse múltiples CRS en proyectos cuando ningún CRS se adapte a todas las tareas. Los “cálculos geodésicos” pueden proporcionar un recurso alternativo si no hay CRS adecuados. Independientemente del CRS proyectado que se utilice, los resultados pueden no ser precisos para geometrías que abarquen cientos de kilómetros.\nA la hora de decidirse por un SRI personalizado, recomendamos lo siguiente:\n\nUna proyección acimutal igual al área de Lambert (LAEA) para una proyección local personalizada (establezca la latitud y la longitud del origen en el centro del área de estudio), que es una proyección igual al área en todas las ubicaciones pero distorsiona las formas más allá de miles de kilómetros.\nProyecciones acimutales equidistantes (AEQD) para una distancia en línea recta específicamente precisa entre un punto y el punto central de la proyección local.\nProyecciones cónicas conformes de Lambert (LCC) para regiones que abarcan miles de kilómetros, con el cono ajustado para mantener unas propiedades de distancia y área razonables entre las líneas secantes.\nProyecciones estereográficas (STERE) para regiones polares, pero teniendo cuidado de no confiar en cálculos de área y distancia a miles de kilómetros del centro.\n\nUn posible enfoque para seleccionar automáticamente un CRS proyectado específico para un conjunto de datos local es crear una proyección equidistante azimutal (AEQD) para el punto central del área de estudio. Esto implica crear un CRS personalizado (sin código EPSG) con unidades de metros basado en el punto central de un conjunto de datos. Tenga en cuenta que este método debe utilizarse con precaución: ningún otro conjunto de datos será compatible con el CRS personalizado creado y es posible que los resultados no sean precisos cuando se utilicen en conjuntos de datos extensos que abarquen cientos de kilómetros.\nLos principios descritos en esta sección se aplican tanto a los conjuntos de datos vectoriales como a los ráster. Sin embargo, algunas características de la transformación CRS son exclusivas de cada modelo de datos geográficos."
  },
  {
    "objectID": "reproyeccion.html#reproyección-de-geometrías-vectoriales",
    "href": "reproyeccion.html#reproyección-de-geometrías-vectoriales",
    "title": "Reproyeccion",
    "section": "Reproyección de geometrías vectoriales",
    "text": "Reproyección de geometrías vectoriales\nLa reproyección de vectores consiste en transformar las coordenadas de los puntos que forman los vértices de las rectas y los polígonos.\n\nlondon2 = st_transform(london_geo, \"EPSG:27700\")\n\nAhora que se ha creado una versión transformada de london, utilizando la función sf st_transform(), se puede encontrar la distancia entre las dos representaciones de Londres. Puede sorprender que londres y londres2 estén a poco más de 2 km de distancia.\n\nst_distance(london2, london_proj)\n## Units: [m]\n##         [,1]\n## [1,] 2017.95\n\nLas funciones para consultar y reproyectar CRS se muestran a continuación con referencia a cycle_hire_osm, un objeto sf de spData que representa “estaciones de carga” donde se pueden alquilar bicicletas en Londres. Los CRS de los objetos sf pueden consultarse y establecerse con la función st_crs(). La salida se imprime como múltiples líneas de texto que contienen información sobre el sistema de coordenadas:\n\nst_crs(cycle_hire_osm)\n## Coordinate Reference System:\n##   User input: EPSG:4326 \n##   wkt:\n## GEOGCS[\"WGS 84\",\n##     DATUM[\"WGS_1984\",\n##         SPHEROID[\"WGS 84\",6378137,298.257223563,\n##             AUTHORITY[\"EPSG\",\"7030\"]],\n##         AUTHORITY[\"EPSG\",\"6326\"]],\n##     PRIMEM[\"Greenwich\",0,\n##         AUTHORITY[\"EPSG\",\"8901\"]],\n##     UNIT[\"degree\",0.0174532925199433,\n##         AUTHORITY[\"EPSG\",\"9122\"]],\n##     AUTHORITY[\"EPSG\",\"4326\"]]\n\nLos componentes principales del CRS, User input y wkt, se imprimen como una sola entidad, la salida de st_crs() es de hecho una lista con nombre de la clase crs con dos elementos, cadenas de caracteres simples llamadas input y wkt, como se muestra en la salida del siguiente trozo de código:\n\ncrs_lnd = st_crs(london_geo)\nclass(crs_lnd)\nnames(crs_lnd)\n## [1] \"crs\"\n## [1] \"input\" \"wkt\"\n\nSe pueden recuperar elementos adicionales con el operador $, incluyendo Name, proj4string y epsg (ver ?st_crs y el tutorial CRS y tranformación en el sitio web de GDAL para más detalles):\n\ncrs_lnd$Name\ncrs_lnd$proj4string\ncrs_lnd$epsg\n## [1] \"WGS 84\"\n## [1] \"+proj=longlat +datum=WGS84 +no_defs\"\n## [1] 4326\n\nLa representación WKT almacenada en el elemento $wkt del objeto crs_lnd es la última fuente de verdad. Esto significa que las salidas del trozo de código anterior son consultas de la representación wkt proporcionada por PROJ, en lugar de atributos inherentes del objeto y su CRS.\nTanto los elementos wkt como User Input del CRS se modifican cuando se transforma el CRS del objeto. En el siguiente fragmento de código, creamos una nueva versión de cycle_hire_osm con un CRS proyectado (sólo se muestran las 4 primeras líneas de la salida CRS por brevedad):\n\ncycle_hire_osm_projected = st_transform(cycle_hire_osm, \"EPSG:27700\")\nst_crs(cycle_hire_osm_projected)\n#&gt; Coordinate Reference System:\n#&gt;   User input: EPSG:27700 \n#&gt;   wkt:\n#&gt; PROJCRS[\"OSGB36 / British National Grid\",\n#&gt; ...\n\nEl objeto resultante tiene un nuevo CRS con un código EPSG 27700. Pero, ¿cómo averiguar más detalles sobre este código EPSG, o sobre cualquier código?\n\ncrs_lnd_new = st_crs(\"EPSG:27700\")\ncrs_lnd_new$Name\ncrs_lnd_new$proj4string\ncrs_lnd_new$epsg\n## [1] \"OSGB36 / British National Grid\"\n## [1] \"+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +units=m +no_defs\"\n## [1] 27700\n\n\n\n\n\n\n\nNota\n\n\n\nLa impresión de un objeto espacial en la consola devuelve automáticamente su sistema de referencia de coordenadas. Para acceder a él y modificarlo explícitamente, utilice la función st_crs, por ejemplo, st_crs(ciclo_hire_osm)."
  },
  {
    "objectID": "reproyeccion.html#reproj-ras",
    "href": "reproyeccion.html#reproj-ras",
    "title": "Reproyeccion",
    "section": "Reproyección de geometrías raster",
    "text": "Reproyección de geometrías raster\nExisten diferencias importantes en la reproyección de vectores y rásters: transformar un objeto vectorial implica cambiar las coordenadas de cada vértice, pero esto no se aplica a los datos raster. Los rásters se componen de celdas rectangulares del mismo tamaño (expresadas en unidades cartográficas, como grados o metros), por lo que suele ser impracticable transformar las coordenadas de los píxeles por separado. La reproyección de rásters implica la creación de un nuevo objeto ráster, a menudo con un número de columnas y filas distinto del original. A continuación, hay que volver a estimar los atributos, lo que permite “rellenar” los nuevos píxeles con los valores adecuados. En otras palabras, la reproyección ráster puede considerarse como dos operaciones espaciales separadas: una reproyección vectorial de la extensión ráster a otro CRS y el cálculo de nuevos valores de píxel mediante remuestreo. Por lo tanto, en la mayoría de los casos en que se utilizan datos ráster y vectoriales, es mejor evitar la reproyección de rásteres y reproyectar vectores en su lugar.\n\n\n\n\n\n\nNota\n\n\n\nLa reproyección de los rásters regulares también se conoce como “warping”. Además, existe una segunda operación similar denominada “transformación”. En lugar de remuestrear todos los valores, deja todos los valores intactos pero vuelve a calcular nuevas coordenadas para cada celda del raster, cambiando la geometría de la cuadrícula. Por ejemplo, podría convertir el ráster de entrada (una malla regular) en una malla curvilínea. La operación de transformación puede realizarse en R utilizando el paquete stars.\n\n\nEl proceso de reproyección raster se realiza con project() del paquete terra. project() toma un objeto geográfico (un conjunto de datos raster en este caso) y alguna representación CRS como segundo argumento. Nota al margen: el segundo argumento también puede ser un objeto ráster existente con un CRS diferente.\nVeamos dos ejemplos de transformación ráster: el uso de datos categóricos y continuos. Los datos de cobertura del suelo suelen representarse mediante mapas categóricos. El archivo nlcd.tif proporciona información para una pequeña área en Utah, EE.UU. obtenida de National Land Cover Database 2011 en el CRS NAD83 / UTM zona 12N, como se muestra en la salida del fragmento de código a continuación:\n\ncat_raster = rast(system.file(\"raster/nlcd.tif\", package = \"spDataLarge\"))\ncrs(cat_raster)\n#&gt; PROJCRS[\"NAD83 / UTM zone 12N\",\n#&gt; ...\n\nEn esta región se distinguieron 8 clases de ocupación del suelo (la lista completa de las clases de ocupación del suelo de la NLCD2011 puede consultarse en mrlc.gov):\n\nunique(cat_raster)\n\n\n\n\nlevels\n\n\n\nWater\n\n\nDeveloped\n\n\nBarren\n\n\nForest\n\n\nShrubland\n\n\nHerbaceous\n\n\nCultivated\n\n\nWetlands\n\n\n\n\n\n\nAl reproyectar rásters categóricos, los valores estimados deben ser los mismos que los del original. Para ello se puede utilizar el método del vecino más cercano (near), que establece el valor de cada nueva celda en el valor de la celda más cercana (centro) del ráster de entrada. Un ejemplo es la reproyección de cat_raster a WGS84, un CRS geográfico muy adecuado para la cartografía web. El primer paso es obtener la definición PROJ de este CRS, lo que puede hacerse, por ejemplo, utilizando la página web http://spatialreference.org. El último paso es reproyectar el ráster con la función project() que, en el caso de datos categóricos, utiliza el método del vecino más cercano (near):\n\ncat_raster_wgs84 = project(cat_raster, \"EPSG:4326\", method = \"near\")\n\nMuchas propiedades del nuevo objeto difieren del anterior, incluido el número de columnas y filas (y, por tanto, el número de celdas), la resolución (transformada de metros a grados) y la extensión.\n\n\n\nKey attributes in the original (‘cat_raster’) and projected (‘cat_raster_wgs84’) categorical raster datasets.\n\nCRS\nnrow\nncol\nncell\nresolution\nunique_categories\n\n\n\nNAD83\n1359\n1073\n1458207\n31.5275\n8\n\n\nWGS84\n1246\n1244\n1550024\n0.0003\n9\n\n\n\n\n\nLa reproyección de rásters numéricos (con valores numéricos o en este caso enteros) sigue un procedimiento casi idéntico. Esto se demuestra a continuación con srtm.tif de the Shuttle Radar Topography Mission (SRTM), que representa la altura en metros sobre el nivel del mar (elevación) con el WGS84 CRS:\n\ncon_raster = rast(system.file(\"raster/srtm.tif\", package = \"spDataLarge\"))\ncrs(con_raster)\n## [1] \"GEOGCRS[\\\"WGS 84\\\",\\n    ENSEMBLE[\\\"World Geodetic System 1984 ensemble\\\",\\n        MEMBER[\\\"World Geodetic System 1984 (Transit)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G730)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G873)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G1150)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G1674)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G1762)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G2139)\\\"],\\n        ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n        ENSEMBLEACCURACY[2.0]],\\n    PRIMEM[\\\"Greenwich\\\",0,\\n        ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    CS[ellipsoidal,2],\\n        AXIS[\\\"geodetic latitude (Lat)\\\",north,\\n            ORDER[1],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        AXIS[\\\"geodetic longitude (Lon)\\\",east,\\n            ORDER[2],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    USAGE[\\n        SCOPE[\\\"Horizontal component of 3D system.\\\"],\\n        AREA[\\\"World.\\\"],\\n        BBOX[-90,-180,90,180]],\\n    ID[\\\"EPSG\\\",4326]]\"\n\nReproyectaremos este conjunto de datos en un CRS proyectado, pero no con el método del vecino más próximo, que es apropiado para datos categóricos. En su lugar, utilizaremos el método bilineal, que calcula el valor de la celda de salida basándose en las cuatro celdas más cercanas de la trama original. Los valores del conjunto de datos proyectado son la media ponderada por distancia de los valores de estas cuatro celdas: cuanto más cerca esté la celda de entrada del centro de la celda de salida, mayor será su peso. Los siguientes comandos crean una cadena de texto que representa WGS 84 / UTM zona 12N, y reproyectan el ráster en este CRS, utilizando el método bilineal:\n\ncon_raster_ea = project(con_raster, \"EPSG:32612\", method = \"bilinear\")\ncrs(con_raster_ea)\n## [1] \"PROJCRS[\\\"WGS 84 / UTM zone 12N\\\",\\n    BASEGEOGCRS[\\\"WGS 84\\\",\\n        ENSEMBLE[\\\"World Geodetic System 1984 ensemble\\\",\\n            MEMBER[\\\"World Geodetic System 1984 (Transit)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G730)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G873)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G1150)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G1674)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G1762)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G2139)\\\"],\\n            ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n                LENGTHUNIT[\\\"metre\\\",1]],\\n            ENSEMBLEACCURACY[2.0]],\\n        PRIMEM[\\\"Greenwich\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        ID[\\\"EPSG\\\",4326]],\\n    CONVERSION[\\\"UTM zone 12N\\\",\\n        METHOD[\\\"Transverse Mercator\\\",\\n            ID[\\\"EPSG\\\",9807]],\\n        PARAMETER[\\\"Latitude of natural origin\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8801]],\\n        PARAMETER[\\\"Longitude of natural origin\\\",-111,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8802]],\\n        PARAMETER[\\\"Scale factor at natural origin\\\",0.9996,\\n            SCALEUNIT[\\\"unity\\\",1],\\n            ID[\\\"EPSG\\\",8805]],\\n        PARAMETER[\\\"False easting\\\",500000,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8806]],\\n        PARAMETER[\\\"False northing\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8807]]],\\n    CS[Cartesian,2],\\n        AXIS[\\\"(E)\\\",east,\\n            ORDER[1],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n        AXIS[\\\"(N)\\\",north,\\n            ORDER[2],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n    USAGE[\\n        SCOPE[\\\"Navigation and medium accuracy spatial referencing.\\\"],\\n        AREA[\\\"Between 114°W and 108°W, northern hemisphere between equator and 84°N, onshore and offshore. Canada - Alberta; Northwest Territories (NWT); Nunavut; Saskatchewan. Mexico. United States (USA).\\\"],\\n        BBOX[0,-114,84,-108]],\\n    ID[\\\"EPSG\\\",32612]]\"\n\nLa reproyección raster sobre variables numéricas también provoca pequeños cambios en los valores y propiedades espaciales, como el número de celdas, la resolución y la extensión. Estos cambios se muestran en la Tabla @ref(tab:rastercrs)3:\n\n\n\nKey attributes in the original (‘con_raster’) and projected (‘con_raster_ea’) continuous raster datasets.\n\nCRS\nnrow\nncol\nncell\nresolution\nmean\n\n\n\nWGS84\n457\n465\n212505\n0.0008\n1842.548\n\n\nUTM zone 12N\n515\n422\n217330\n83.5334\n1842.083\n\n\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nPor supuesto, las limitaciones de las proyecciones de la Tierra en 2D se aplican tanto a los datos vectoriales como a los ráster. En el mejor de los casos, podemos cumplir dos de las tres propiedades espaciales (distancia, área, dirección). Por lo tanto, la tarea a realizar determina qué proyección elegir. Por ejemplo, si estamos interesados en una densidad (puntos por celda de cuadrícula o habitantes por celda de cuadrícula) deberíamos utilizar una proyección de igual área."
  },
  {
    "objectID": "reproyeccion.html#footnotes",
    "href": "reproyeccion.html#footnotes",
    "title": "Reproyeccion",
    "section": "Notas",
    "text": "Notas\n\nSe pueden utilizar otras formas de referirse a CRS únicos, con cinco tipos de identificadores (código EPSG, PostGIS SRID, INTERNAL SRID, proj-string y cadenas WKT) aceptados por QGIS y otros tipos de identificadores como una variante más verbosa del identificador EPSG:4326, urn:ogc:def:crs:EPSG::4326.↩︎\nEste paquete también permite averiguar el verdadero CRS de los datos sin ninguna información CRS adjunta↩︎\n Otro cambio menor es que la clase de los valores en el nuevo conjunto de datos ráster proyectado es numérico. Esto se debe a que el método bilineal trabaja con datos continuos y los resultados raramente se convierten en valores enteros. Esto puede tener implicaciones en el tamaño de los archivos cuando se guardan los conjuntos de datos ráster.↩︎"
  }
]