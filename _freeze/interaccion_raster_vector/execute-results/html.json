{
  "hash": "40aa4632c2d40b8384c016b12e65105f",
  "result": {
    "markdown": "---\ntitle: \"Interacciones raster-vector\"\nauthor: \"Modificado de <https://r.geocompx.org/>\"\nformat: \n  html:\n    toc: true\n    df-print: kable\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(terra)\nlibrary(dplyr)\n```\n:::\n\n\n## Introducción\n\nEste capítulo se centra en las interacciones entre los modelos de datos geográficos ráster y vectoriales.\nIncluye cuatro técnicas principales: recorte y enmascaramiento ráster utilizando objetos vectoriales;\nextracción de valores ráster utilizando diferentes tipos de datos vectoriales; y conversión ráster-vector. \n\n## Recorte \n\nMuchos proyectos de datos geográficos implican la integración de datos de muchas fuentes diferentes, como imágenes de teledetección (rásters) y límites administrativos (vectores).\nA menudo, la extensión de los conjuntos de datos ráster de entrada es mayor que el área de interés.\nEn este caso, el **recorte** y el **enmascaramiento** ráster son útiles para unificar la extensión espacial de los datos de entrada.\nAmbas operaciones reducen el uso de memoria del objeto y los recursos computacionales asociados para los pasos de análisis posteriores, y pueden ser un paso de preprocesamiento necesario antes de crear mapas atractivos que incluyan datos ráster.\n\nUtilizaremos dos objetos para ilustrar el recorte raster:\n\n- Un objeto `SpatRaster` `srtm` que representa la elevación (metros sobre el nivel del mar) en el suroeste de Utah\n- Un objeto vectorial (`sf`) `zion` que representa el Parque Nacional de Zion.\n\nTanto el objeto de destino como el de recorte deben tener la misma proyección.\nPor lo tanto, el siguiente fragmento de código no sólo lee los conjuntos de datos del paquete **spDataLarge**, sino que también \"reproyecta\" `zion`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsrtm = rast(system.file(\"raster/srtm.tif\", package = \"spDataLarge\"))\nzion = read_sf(system.file(\"vector/zion.gpkg\", package = \"spDataLarge\"))\nzion = st_transform(zion, crs(srtm))\n```\n:::\n\n\nUtilizamos `crop()` del paquete **terra** para recortar `srtm`.\nLa función reduce la extensión rectangular del objeto pasado como primer argumento en función de la extensión del objeto pasado como segundo argumento.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsrtm_cropped = crop(srtm, zion)\n```\n:::\n\n\nRelacionada con `crop()` está la función **terra** `mask()`, que establece como `NA` los valores fuera de los límites del objeto pasado a su segundo argumento.\nPor tanto, el siguiente comando enmascara todas las celdas situadas fuera de los límites del Parque Nacional de Zion:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsrtm_masked = mask(srtm, zion)\n```\n:::\n\n\nEs importante destacar que, en la mayoría de los casos, se recomienda utilizar conjuntamente las funciones `crop()` y `mask()`. \nEsta combinación de funciones (a) limitaría la extensión del raster a nuestra área de interés y (b) reemplazaría todos los valores fuera del área a NA.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsrtm_cropped = crop(srtm, zion)\nsrtm_final = mask(srtm_cropped, zion)\n```\n:::\n\n\nCambiando la configuración de `mask()` se obtienen resultados diferentes.\nSi se establece `inverse = TRUE` se enmascarará todo lo que esté *dentro* de los límites del parque (véase `?mask` para más detalles), mientras que si se establece `updatevalue = 0` se pondrán a 0 todos los píxeles fuera del parque nacional.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsrtm_inv_masked = mask(srtm, zion, inverse = TRUE)\n```\n:::\n\n::: {.cell fig.asp='0.36'}\n::: {.cell-output-display}\n![Illustration of raster cropping and raster masking.](interaccion_raster_vector_files/figure-html/cropmask-1.png){width=960}\n:::\n:::\n\n\n## Extracción de datos de un raster\n\nLa extracción de raster es el proceso de identificar y devolver los valores asociados a un raster \"objetivo\" en ubicaciones específicas, basándose en un objeto \"selector\" geográfico (normalmente vectorial).\nLos resultados dependen del tipo de selector utilizado (puntos, líneas o polígonos) y de los argumentos pasados a la función `terra::extract()`.\nEl reverso de la extracción raster --- asignar valores de celda raster basado en objetos vectoriales --- es la rasterización, que se describe más adelante.\n\nEl ejemplo básico consiste en extraer el valor de una celda ráster en **puntos** específicos.\nPara ello, utilizaremos `zion_points`, que contiene una muestra de 30 localizaciones dentro del Parque Nacional de Zion. \nEl siguiente comando extrae los valores de elevación de `srtm` y crea un data frame con los ID de los puntos (un valor por fila del vector) y los valores `srtm` relacionados para cada punto.\nAhora, podemos añadir el objeto resultante a nuestro conjunto de datos `zion_points` con la función `cbind()`: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"zion_points\", package = \"spDataLarge\")\nelevation = terra::extract(srtm, zion_points)\nzion_points = cbind(zion_points, elevation)\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell fig.asp='0.57'}\n::: {.cell-output-display}\n![Locations of points used for raster extraction.](interaccion_raster_vector_files/figure-html/pointextr-1.png){width=672}\n:::\n:::\n\n\nLa extracción de datos raster también funciona con selectores de tipo **línea**.\nEntonces, extrae un valor por cada celda raster tocada por la línea.\nEl enfoque consiste en dividir la línea en muchos puntos y luego extraer los valores de estos puntos.\nPara demostrarlo, el código siguiente crea `zion_transect`, una línea recta que va del noroeste al sureste del Parque Nacional de Zion:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nzion_transect = cbind(c(-113.2, -112.9), c(37.45, 37.2)) |>\n  st_linestring() |> \n  st_sfc(crs = crs(srtm)) |>\n  st_sf(geometry = _)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nLa utilidad de extraer alturas de un selector lineal se ilustra imaginando que está planeando una excursión.\nEl método que se muestra a continuación proporciona un `perfil de elevación` de la ruta (no es necesario que la línea sea recta), útil para estimar cuánto tiempo se tardará debido a las subidas.\n\nEl primer paso es añadir un `id` único para cada transecto.\nA continuación, con la función `st_segmentize()` podemos añadir puntos a lo largo de nuestra(s) línea(s) con una densidad proporcionada (`dfMaxLength`) y convertirlos en puntos con `st_cast()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nzion_transect$id = 1:nrow(zion_transect)\nzion_transect = st_segmentize(zion_transect, dfMaxLength = 250)\nzion_transect = st_cast(zion_transect, \"POINT\")\n```\n:::\n\n\nAhora, tenemos un gran conjunto de puntos, y queremos derivar una distancia entre el primer punto de nuestros transectos y cada uno de los puntos subsiguientes. \nEn este caso, sólo tenemos un transecto, pero el código, en principio, debería funcionar con cualquier número de transectos:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nzion_transect = zion_transect |> \n  group_by(id) |> \n  mutate(dist = st_distance(geometry)[, 1]) \n```\n:::\n\n\nPor último, podemos extraer los valores de elevación de cada punto de nuestros transectos y combinar esta información con nuestro objeto principal.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nzion_elev = terra::extract(srtm, zion_transect)\nzion_transect = cbind(zion_transect, zion_elev)\n```\n:::\n\n\nEl `zion_transect` resultante puede utilizarse para crear perfiles de elevación, como se ilustra a continuación.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Location of a line used for raster extraction (left) and the elevation along this line (right).](interaccion_raster_vector_files/figure-html/lineextr-1.png){fig-scap='Line-based raster extraction.' width=672}\n:::\n:::\n\n\nEl último tipo de objeto vectorial geográfico para la extracción de rásters son los **polígonos**.\nAl igual que las líneas, los polígonos tienden a devolver muchos valores ráster por polígono.\nEsto se demuestra en el siguiente comando, que da como resultado un marco de datos con nombres de columna `ID` (el número de fila del polígono) y `srtm` (valores de elevación asociados):\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nzion_srtm_values = terra::extract(x = srtm, y = zion)\n```\n:::\n\n\nEstos resultados pueden utilizarse para generar estadísticas resumidas de valores ráster por polígono, por ejemplo para caracterizar una única región o para comparar muchas regiones.\nEsto se muestra en el siguiente código, que crea el objeto `zion_srtm_df` que contiene estadísticas resumidas para los valores de elevación en el Parque Nacional de Zion:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroup_by(zion_srtm_values, ID) |> \n  summarize(across(srtm, list(min = min, mean = mean, max = max)))\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| ID| srtm_min| srtm_mean| srtm_max|\n|--:|--------:|---------:|--------:|\n|  1|     1122|  1818.212|     2661|\n\n</div>\n:::\n:::\n\n\nEl trozo de código anterior utilizó **dplyr** para proporcionar estadísticas de resumen para los valores de celda por ID de polígono.\nLos resultados proporcionan resúmenes útiles, por ejemplo, que la altura máxima en el parque es de alrededor de 2.661 metros sobre el nivel del mar (otras estadísticas de resumen, como la desviación estándar, también se puede calcular de esta manera).\nComo en el ejemplo sólo hay un polígono, se devuelve una tabla de datos con una única fila; sin embargo, el método funciona cuando se utilizan varios polígonos selectores.\n\nUn método similar funciona para el recuento de ocurrencias de valores ráster categóricos dentro de polígonos.\nEsto se ilustra con un conjunto de datos de cobertura del suelo (`nlcd`) del paquete **spDataLarge**, y se demuestra en el código siguiente:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnlcd = rast(system.file(\"raster/nlcd.tif\", package = \"spDataLarge\"))\nzion2 = st_transform(zion, st_crs(nlcd))\nzion_nlcd = terra::extract(nlcd, zion2)\nzion_nlcd |> \n  group_by(ID, levels) |>\n  count()\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| ID|levels     |      n|\n|--:|:----------|------:|\n|  1|Developed  |   4205|\n|  1|Barren     |  98285|\n|  1|Forest     | 298299|\n|  1|Shrubland  | 203700|\n|  1|Herbaceous |    235|\n|  1|Cultivated |     62|\n|  1|Wetlands   |    679|\n\n</div>\n:::\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Area used for continuous (left) and categorical (right) raster extraction.](interaccion_raster_vector_files/figure-html/polyextr-1.png){width=672}\n:::\n:::\n\n\nAunque el paquete **terra** ofrece una rápida extracción de valores ráster dentro de polígonos, `extract()` puede seguir siendo un cuello de botella cuando se procesan grandes conjuntos de datos de polígonos.\nEl paquete **exactextractr** ofrece una [alternativa significativamente más rápida](https://github.com/geocompx/geocompr/issues/813) para extraer valores de píxeles a través de la función `exact_extract()`. \nLa función `exact_extract()` también calcula, por defecto, la fracción de cada celda ráster solapada por el polígono, lo cual es más preciso. \n\n:::{.callout-note}\nLos polígonos suelen tener formas irregulares y, por lo tanto, un polígono puede solapar sólo algunas partes de las celdas de un ráster. \nPara obtener resultados más detallados, la función `terra::extract()` tiene un argumento llamado `exact`. \nCon `exact = TRUE`, obtenemos una columna más `fraction` en el marco de datos de salida, que representa una fracción de cada celda que está cubierta por el polígono.\nEsto podría ser útil para calcular, por ejemplo, una media ponderada para rásters continuos o una cobertura más precisa para rásters categóricos.\nPor defecto, es `FALSE` ya que esta operación requiere más cálculos. \nLa función `exactextractr::exact_extract()` siempre calcula la fracción de cobertura del polígono en cada celda.\n:::\n\n\n\n\n\n## Rasterización\n\nLa rasterización es la conversión de objetos vectoriales a raster.\nNormalmente, el ráster de salida se utiliza después para análisis cuantitativos (por ejemplo, análisis del terreno) o modelado.\nEl proceso de rasterización puede ayudar a simplificar los conjuntos de datos porque todos los valores resultantes tienen la misma resolución espacial: la rasterización puede considerarse un tipo especial de agregación de datos geográficos.\n\nEl paquete **terra** contiene la función `rasterize()` para realizar este trabajo.\nSus dos primeros argumentos son, `x`, objeto vectorial a rasterizar e, `y`, un objeto `plantilla raster' que define la extensión, resolución y CRS de la salida.\nLa resolución geográfica del ráster de entrada tiene un gran impacto en los resultados: si es demasiado baja (el tamaño de las celdas es demasiado grande), el resultado puede perder toda la variabilidad geográfica de los datos vectoriales; si es demasiado alta, los tiempos de cálculo pueden ser excesivos.\nNo existen reglas sencillas a la hora de decidir la resolución geográfica adecuada, que depende en gran medida del uso que se pretenda dar a los resultados.\nA menudo, la resolución objetivo se impone al usuario, por ejemplo cuando el resultado de la rasterización debe alinearse con algún otro raster existente.\n\nPara demostrar la rasterización en acción, utilizaremos una plantilla raster que tiene la misma extensión y CRS que los datos vectoriales de entrada `cycle_hire_osm_projected` y una resolución espacial de 1000 metros:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncycle_hire_osm = spData::cycle_hire_osm\ncycle_hire_osm_projected = st_transform(cycle_hire_osm, \"EPSG:27700\")\nraster_template = rast(ext(cycle_hire_osm_projected), resolution = 1000,\n                       crs = st_crs(cycle_hire_osm_projected)$wkt)\n```\n:::\n\n\nLa rasterización es una operación muy flexible: los resultados dependen no sólo de la naturaleza de la plantilla raster, sino también del tipo de vector de entrada (por ejemplo, puntos, polígonos) y de una variedad de argumentos tomados por la función `rasterize()`.\n\nPara ilustrar esta flexibilidad, probaremos tres enfoques diferentes de la rasterización.\nEn primer lugar, crearemos un raster que represente la presencia o ausencia de puntos de alquiler de bicicletas (conocidos como raster de presencia/ausencia).\nEn este caso, `rasterize()` no requiere ningún argumento además de `x` e `y`, los objetos vector y raster antes mencionados.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nch_raster1 = rasterize(cycle_hire_osm_projected, raster_template)\n```\n:::\n\n\nEl argumento `fun` especifica los estadísticos de resumen utilizados para convertir múltiples observaciones muy próximas en celdas asociadas en el objeto raster.\nPor defecto se utiliza `fun = \"last\"` pero se pueden utilizar otras opciones como `fun = \"length\"`, en este caso para contar el número de puntos de alquiler de ciclos en cada celda de la cuadrícula.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nch_raster2 = rasterize(cycle_hire_osm_projected, raster_template, \n                       fun = \"length\")\n```\n:::\n\n\nEl nuevo resultado, `ch_raster2`, muestra el número de puntos de alquiler de bicicletas en cada cuadrícula.\nLos puntos de alquiler de bicicletas tienen diferentes números de bicicletas descritos por la variable `capacity`, lo que plantea la siguiente pregunta: ¿cuál es la capacidad de cada celda de la cuadrícula?\nPara calcularlo debemos \"sumar\" el campo (`\"capacity\"`), calculada con el siguiente comando (también se podrían utilizar otras funciones de resumen como `mean`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nch_raster3 = rasterize(cycle_hire_osm_projected, raster_template, \n                       field = \"capacity\", fun = sum, na.rm = TRUE)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Examples of point rasterization.](interaccion_raster_vector_files/figure-html/vector-rasterization1-1.png){width=672}\n:::\n:::\n\n\nOtro conjunto de datos basado en polígonos y fronteras de California ilustra la rasterización de líneas.\nTras fundir los objetos poligonales en una multilínea, se crea un raster de plantilla con una resolución de 0.5 grados:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(spData)\ncalifornia = dplyr::filter(us_states, NAME == \"California\")\ncalifornia_borders = st_cast(california, \"MULTILINESTRING\")\nraster_template2 = rast(ext(california), resolution = 0.5,\n                        crs = st_crs(california)$wkt)\n```\n:::\n\n\nAl considerar la rasterización de líneas o polígonos, un argumento adicional útil es \"touches\".\nPor defecto es `FALSE`, pero cuando se cambia a `TRUE` -- todas las celdas que son tocadas por el borde de una línea o polígono obtienen un valor.\nLa rasterización de líneas con `touches = TRUE` se muestra en el siguiente código.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalifornia_raster1 = rasterize(california_borders, raster_template2,\n                               touches = TRUE)\n```\n:::\n\n\nCompárelo con una rasterización de polígonos, con `touches = FALSE` por defecto, que selecciona sólo las celdas raster cuyos centroides están dentro del polígono selector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalifornia_raster2 = rasterize(california, raster_template2) \n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Examples of line and polygon rasterizations.](interaccion_raster_vector_files/figure-html/vector-rasterization2-1.png){width=672}\n:::\n:::\n\n\n## Vectorización espacial\n\nLa vectorización espacial es la contrapartida de la rasterización.\nConsiste en convertir datos ráster espacialmente continuos en datos vectoriales espacialmente discretos, como puntos, líneas o polígonos.\n\n:::{.callout-note}\nEn R, la vectorización suele referirse a la posibilidad de sustituir los bucles `for` y similares haciendo cosas como `1:10 / 2`.\n:::\n\nLa forma más simple de vectorización es convertir los centroides de las celdas raster en puntos.\n`as.points()` hace exactamente esto para todas las celdas de cuadrícula raster que no sean `NA`.\nTenga en cuenta que aquí también utilizamos `st_as_sf()` para convertir el objeto resultante a la clase `sf`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelev = rast(system.file(\"raster/elev.tif\", package = \"spData\"))\nelev_point = as.points(elev) |> \n  st_as_sf()\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Raster and point representation of the elev object.](interaccion_raster_vector_files/figure-html/raster-vectorization1-1.png){width=672}\n:::\n:::\n\n\nOtro tipo común de vectorización espacial es la creación de curvas de nivel que representen líneas de altura o temperaturas continuas (isotermas), por ejemplo.\nUtilizaremos un modelo digital de elevación (MDE) del mundo real porque el ráster artificial `elev` produce líneas paralelas.\nLas curvas de nivel se pueden crear con la función **terra** `as.contour()`, que es a su vez una envoltura de la función incorporada en R `filled.contour()`, como se demuestra a continuación:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndem = rast(system.file(\"raster/dem.tif\", package = \"spDataLarge\"))\ncl = as.contour(dem) |> \n  st_as_sf()\nplot(dem, axes = FALSE)\nplot(cl, add = TRUE)\n```\n\n::: {.cell-output-display}\n![](interaccion_raster_vector_files/figure-html/06-raster-vector-36-1.png){width=672}\n:::\n:::\n\n\nTambién pueden añadirse contornos a los gráficos existentes con funciones como `contour()`, `rasterVis::contourplot()` o `tmap::tm_iso()` y, las isolíneas pueden etiquetarse.\n\n\n::: {.cell fig.asp='0.56'}\n::: {.cell-output-display}\n![DEM with hillshading, showing the southern flank of Mt. Mongón overlaid with contour lines.](interaccion_raster_vector_files/figure-html/contour-tmap-1.png){fig-scap='DEM with hillshading.' width=672}\n:::\n:::\n\n\nEl último tipo de vectorización implica la conversión de rásters en polígonos.\nEsto puede hacerse con `terra::as.polygons()`, que convierte cada celda ráster en un polígono formado por cinco coordenadas, todas las cuales se almacenan en memoria (¡explicando por qué los rásters son a menudo rápidos comparados con los vectores!).\n\nEsto se ilustra a continuación convirtiendo el objeto `grain` en polígonos y disolviendo posteriormente los bordes entre polígonos con los mismos valores de atributo (véase también el argumento `dissolve` en `as.polygons()`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrain = rast(system.file(\"raster/grain.tif\", package = \"spData\"))\ngrain_poly = as.polygons(grain) |> \n  st_as_sf()\n```\n:::\n\n::: {.cell fig.asp='0.4'}\n::: {.cell-output-display}\n![Illustration of vectorization of raster (left) into polygons (dissolve = FALSE; center) and aggregated polygons (dissolve = TRUE; right).](interaccion_raster_vector_files/figure-html/06-raster-vector-40-1.png){fig-scap='Illustration of vectorization.' width=672}\n:::\n:::\n",
    "supporting": [
      "interaccion_raster_vector_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}