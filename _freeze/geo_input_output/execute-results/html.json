{
  "hash": "6825b826aeb17af9a22838e046d2bcdb",
  "result": {
    "markdown": "---\ntitle: \"Entrada y salida de geo-datos\"\nauthor: \"Veronica Andreo\"\ndate: today\nformat: \n  html:\n    toc: true\n    df-print: kable\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(terra)\nlibrary(dplyr)\nlibrary(spData)\n```\n:::\n\n\n## Introducción\n\nEste capítulo trata sobre la lectura y escritura de datos geográficos.\nLa *entrada* de datos geográficos es esencial para la geocomputación: las aplicaciones del mundo real son imposibles sin datos.\nLa *salida* de datos también es vital, ya que permite a otros utilizar valiosos conjuntos de datos nuevos o mejorados resultantes de su trabajo.\nEn conjunto, estos procesos de entrada/salida pueden denominarse E/S de datos (I/O en Inglés).\n\nLa E/S de datos geográficos suele realizarse con unas pocas líneas de código al principio y al final de los proyectos.\nA menudo se pasa por alto como un simple proceso de un solo paso.\nSin embargo, los errores cometidos al principio de los proyectos (por ejemplo, utilizar un conjunto de datos obsoleto o defectuoso de alguna manera) pueden dar lugar a grandes problemas más adelante, por lo que vale la pena dedicar un tiempo considerable a identificar qué conjuntos de datos están *disponibles*, dónde se pueden *encontrar* y cómo *recuperarlos*. Por otra parte, existen muchos formatos de archivos geográficos, cada uno de los cuales tiene sus pros y sus contras, como así también diferentes formas de lectura y escritura eficiente.\n\n## Recuperación de datos abiertos\n\nCada vez hay más datos geográficos disponibles en Internet, muchos de los cuales son de acceso y uso gratuitos (siempre que se dé el crédito correspondiente a sus proveedores)^[Por ejemplo, visite <https://freegisdata.rtwilson.com/> para consultar una lista de sitios web con conjuntos de datos geográficos de libre acceso].\nEn cierto modo, ahora hay *demasiados* datos, en el sentido de que a menudo hay varios sitios donde acceder al mismo conjunto de datos.\nAlgunos conjuntos de datos son de mala calidad. En este contexto, es vital saber dónde buscar.\nVarios \"geoportales\" (servicios web que proporcionan conjuntos de datos geoespaciales, como [Data.gov](https://catalog.data.gov/dataset?metadata_type=geospatial)) son un buen punto de partida, ya que ofrecen una amplia gama de datos, pero a menudo sólo para lugares concretos (como se ilustra en la página actualizada de [Wikipedia](https://en.wikipedia.org/wiki/Geoportal) sobre el tema).\n\nAlgunos geoportales globales superan este problema.\nEl [portal GEOSS](http://www.geoportal.org/) y el [Copernicus Open Access Hub](https://scihub.copernicus.eu/), por ejemplo, contienen muchos conjuntos de datos ráster con cobertura mundial.\nEn el portal [SEDAC](http://sedac.ciesin.columbia.edu/), gestionado por la Administración Nacional de Aeronáutica y del Espacio (NASA), y en el [geoportal INSPIRE](http://inspire-geoportal.ec.europa.eu/) de la Unión Europea, con cobertura mundial y regional, se puede acceder a una gran cantidad de conjuntos de datos vectoriales.\n\nLa mayoría de los geoportales ofrecen una interfaz gráfica que permite consultar los conjuntos de datos en función de características como la extensión espacial y temporal, siendo el [EarthExplorer](https://earthexplorer.usgs.gov/) del Servicio Geológico de Estados Unidos un buen ejemplo.\n*Explorar* los conjuntos de datos de forma interactiva en un navegador es una forma eficaz de comprender las capas disponibles.\nSin embargo, desde el punto de vista de la reproducibilidad y la eficiencia, es mejor descargar los datos mediante código.\nLas descargas pueden iniciarse desde la línea de comandos mediante diversas técnicas, principalmente a través de URL y API (véase [Sentinel API](https://scihub.copernicus.eu/twiki/do/view/SciHubWebPortal/APIHubDescription), por ejemplo).\nLos archivos alojados en URL estáticas pueden descargarse con `download.file()`, como se ilustra en el fragmento de código siguiente que accede a PeRL: Permafrost Region Pond and Lake Database de [doi.pangaea.de](https://doi.pangaea.de/10.1594/PANGAEA.868349):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndownload.file(url = \"https://hs.pangaea.de/Maps/PeRL/PeRL_permafrost_landscapes.zip\",\n              destfile = \"PeRL_permafrost_landscapes.zip\", \n              mode = \"wb\")\nunzip(\"PeRL_permafrost_landscapes.zip\")\ncanada_perma_land = read_sf(\"PeRL_permafrost_landscapes/canada_perma_land.shp\")\n```\n:::\n\n\n## Paquetes de datos geográficos\n\nSe han desarrollado muchos paquetes de R para acceder a datos geográficos, algunos de los cuales se presentan a continuación.\nÉstos proporcionan interfaces a una o más bibliotecas espaciales o geoportales y tienen como objetivo hacer que el acceso a los datos sea aún más rápido desde la línea de comandos.\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table\" style=\"margin-left: auto; margin-right: auto;\">\n<caption>Selected R packages for geographic data retrieval.</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Package </th>\n   <th style=\"text-align:left;\"> Description </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> FedData </td>\n   <td style=\"text-align:left;\"> Datasets maintained by the US Federal government, including elevation and land cover. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> geodata </td>\n   <td style=\"text-align:left;\"> Download and import imports administrative, elevation, WorldClim data. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> osmdata </td>\n   <td style=\"text-align:left;\"> Download and import small OpenStreetMap datasets. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> osmextract </td>\n   <td style=\"text-align:left;\"> Download and import large OpenStreetMap datasets. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> rnaturalearth </td>\n   <td style=\"text-align:left;\"> Access to Natural Earth vector and raster data. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> rnoaa </td>\n   <td style=\"text-align:left;\"> Imports National Oceanic and Atmospheric Administration (NOAA) climate data. </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nCabe destacar que la tabla representa sólo un pequeño número de paquetes de datos geográficos disponibles.\nPor ejemplo, existe un gran número de paquetes R para obtener diversos datos sociodemográficos, como **tidycensus** y **tigris** (EE.UU.), **cancensus** (Canadá), **eurostat** y **giscoR** (Unión Europea), o **idbr** (bases de datos internacionales) -- lea [Analyzing US Census Data](https://walker-data.com/census-r) para encontrar algunos ejemplos de cómo analizar dichos datos.\nDel mismo modo, existen varios paquetes de R que dan acceso a datos espaciales de diversas regiones y países, como **bcdata** (provincia de Columbia Británica), **geobr** (Brasil), **RCzechia** (Chequia) o **rgugik** (Polonia).\nOtro paquete destacable es **GSODR**, que proporciona un resumen global de datos meteorológicos diarios en R (consulte el [README](https://github.com/ropensci/GSODR) del paquete para obtener una visión general de las fuentes de datos meteorológicos).\n\nCada paquete de datos tiene su propia sintaxis para acceder a los datos.\nEsta diversidad se demuestra en los siguientes trozos de código, que muestran cómo obtener datos utilizando tres paquetes de la tabla anterior.^[En <https://rspatialdata.github.io/> se pueden encontrar más ejemplos de descarga de datos utilizando paquetes R dedicados].\nLas fronteras de los países suelen ser útiles y se puede acceder a ellas con la función `ne_countries()` del paquete **rnaturalearth** de la siguiente manera:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rnaturalearth)\nusa = ne_countries(country = \"United States of America\") # United States borders\nclass(usa)\n# alternative way of accessing the data, with geodata\n# geodata::gadm(\"USA\", level = 0, path = tempdir())\n## [1] \"SpatialPolygonsDataFrame\"\n## attr(,\"package\")\n## [1] \"sp\"\n```\n:::\n\n\nPor defecto **rnaturalearth** devuelve objetos de la clase `Spatial*`.\nEl resultado se puede convertir en un objeto `sf` con `st_as_sf()` de la siguiente manera:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusa_sf = st_as_sf(usa)\n```\n:::\n\n\nUn segundo ejemplo descarga una serie de rásters que contienen sumas mensuales globales de precipitación con una resolución espacial de diez minutos (~18,5 km en el ecuador) utilizando el paquete **geodata**.\nEl resultado es un objeto multicapa de la clase `SpatRaster`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(geodata)\nworldclim_prec = worldclim_global(\"prec\", res = 10, path = tempdir())\nclass(worldclim_prec)\n```\n:::\n\n\nUn tercer ejemplo utiliza el paquete **osmdata** para buscar parques en la base de datos OpenStreetMap (OSM).\nComo se ilustra en el fragmento de código siguiente, las consultas comienzan con la función `opq()` (abreviatura de OpenStreetMap query), cuyo primer argumento es bounding box, o cadena de texto que representa un bounding box (la ciudad de Leeds en este caso).\nEl resultado se pasa a una función para seleccionar los elementos OSM que nos interesan (parques en este caso), representados por *pares clave-valor*.\nA continuación, se pasan a la función `osmdata_sf()` que hace el trabajo de descargar los datos y convertirlos en una lista de objetos `sf` (ver `vignette('osmdata')` para más detalles):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(osmdata)\nparks = opq(bbox = \"leeds uk\") |> \n  add_osm_feature(key = \"leisure\", value = \"park\") |> \n  osmdata_sf()\n```\n:::\n\n\nUna limitación del paquete **osmdata** es que no puede descargar grandes conjuntos de datos OSM (por ejemplo, todos los datos OSM de una gran ciudad).\nPara superar esta limitación, se desarrolló el paquete **osmextract**, que se puede utilizar para descargar e importar archivos binarios `.pbf` que contienen versiones comprimidas de la base de datos OSM para regiones predefinidas.\n\nOpenStreetMap es una vasta base de datos mundial de origen colectivo que crece día a día y cuenta con un amplio ecosistema de herramientas que facilitan el acceso a los datos, desde el servicio web [Overpass turbo](https://overpass-turbo.eu/) para desarrollar y probar rápidamente consultas OSM hasta [osm2pgsql](https://osm2pgsql.org/) para importar los datos a una base de datos PostGIS.\nAunque la calidad de los conjuntos de datos derivados de OSM varía, la fuente de datos y los ecosistemas OSM más amplios tienen muchas ventajas: proporcionan conjuntos de datos disponibles a nivel mundial, gratuitos y en constante mejora gracias a un ejército de voluntarios.\nEl uso de OSM fomenta la \"ciencia ciudadana\" y las contribuciones al patrimonio digital (puedes empezar a editar datos que representen una parte del mundo que conozcas bien en [www.openstreetmap.org](https://www.openstreetmap.org)).\n\nA veces, los paquetes vienen con conjuntos de datos incorporados.\nSe puede acceder a ellos de cuatro maneras: adjuntando el paquete (si el paquete utiliza \"carga lenta\" como **spData**), con `data(dataset, package = mypackage)`, haciendo referencia al conjunto de datos con `mypackage::dataset`, o con `system.file(filepath, package = mypackage)` para acceder a los archivos de datos sin procesar.\nEl siguiente fragmento de código ilustra las dos últimas opciones utilizando el conjunto de datos `world` (ya cargado adjuntando su paquete padre con `library(spData)`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld2 = spData::world\nworld3 = read_sf(system.file(\"shapes/world.gpkg\", package = \"spData\"))\n```\n:::\n\n\nEl último ejemplo, `system.file(\"shapes/world.gpkg\", package = \"spData\")`, devuelve una ruta al archivo `world.gpkg`, que se almacena dentro de la carpeta `\"shapes/\"` del paquete **spData**.\n\nOtra forma de obtener información espacial es realizar la geocodificación: transformar la descripción de una ubicación, normalmente una dirección, en sus coordenadas.\nEsto suele hacerse enviando una consulta a un servicio en línea y obteniendo la ubicación como resultado.\nExisten muchos servicios de este tipo que difieren en el método de geocodificación utilizado, las limitaciones de uso, los costes o los requisitos de clave API. \nR dispone de varios paquetes para geocodificación; sin embargo, **tidygeocoder** parece permitir conectar con [el mayor número de servicios de geocodificación](https://jessecambon.github.io/tidygeocoder/articles/geocoder_services.html) con una interfaz consistente.\nLa función principal de **tidygeocoder** es `geocode`, que toma un marco de datos con direcciones y añade coordenadas como `\"lat\"` y `\"long\"`.\nEsta función también permite seleccionar un servicio de geocodificación con el argumento `method` y tiene muchos parámetros adicionales.\n\nEl siguiente ejemplo busca las coordenadas de la placa azul de John Snow situada en un edificio del barrio londinense del Soho.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidygeocoder)\ngeo_df = data.frame(address = \"54 Frith St, London W1D 4SJ, UK\")\ngeo_df = geocode(geo_df, address, method = \"osm\")\ngeo_df\n```\n:::\n\n\nEl data.frame resultante puede convertirse en un objeto `sf` con `st_as_sf()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeo_sf = st_as_sf(geo_df, coords = c(\"long\", \"lat\"), crs = \"EPSG:4326\")\n```\n:::\n\n\nEste paquete también permite realizar el proceso inverso denominado geocodificación inversa utilizado para obtener un conjunto de información (nombre, dirección, etc.) a partir de un par de coordenadas.\n\n## Servicios web geográficos\n\nEn un esfuerzo por estandarizar las API web para acceder a los datos espaciales, el Open Geospatial Consortium (OGC) ha creado una serie de especificaciones para los servicios web (conocidos colectivamente como OWS, que es la abreviatura de OGC Web Services).\nEstas especificaciones incluyen el Web Feature Service (WFS), el Web Map Service (WMS), el Web Map Tile Service (WMTS), el Web Coverage Service (WCS) e incluso un Web Processing Service (WPS).\nServidores de mapas como PostGIS han adoptado estos protocolos, lo que ha llevado a la estandarización de las consultas.\nAl igual que otras API web, las API OWS utilizan una \"URL base\", un \"endpoint\" y \"argumentos de consulta URL\" seguidos de un `?` para solicitar datos (véase la viñeta [`best-practices-api-packages`](https://httr.r-lib.org/articles/api-packages.html) en el paquete **httr**).\n\nHay muchas peticiones que se pueden hacer a un servicio OWS.\nUna de las más fundamentales es `getCapabilities`, demostrada con las funciones **httr** `GET()` y `modify_url()` a continuación.\n\nEl fragmento de código muestra cómo pueden construirse y enviarse consultas API, en este caso para descubrir las capacidades de un servicio gestionado por la Organización de las Naciones Unidas para la Agricultura y la Alimentación (FAO):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(httr)\nbase_url = \"http://www.fao.org\"\nendpoint = \"/figis/geoserver/wfs\"\nq = list(request = \"GetCapabilities\")\nres = GET(url = modify_url(base_url, path = endpoint), query = q)\nres$url\n## [1] \"https://www.fao.org/figis/geoserver/wfs?request=GetCapabilities\"\n```\n:::\n\n\nEl fragmento de código anterior demuestra cómo se pueden construir programáticamente las peticiones API\\index{API} con la función `GET()`, que toma una URL base y una lista de parámetros de consulta que pueden ampliarse fácilmente.\nEl resultado de la petición se guarda en `res`, un objeto de la clase `response` definido en el paquete **httr**, que es una lista que contiene información de la petición, incluyendo la URL.\nComo puede verse ejecutando `browseURL(res$url)`, los resultados también pueden leerse directamente en un navegador. Una forma de extraer el contenido de la petición es la siguiente:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntxt = content(res, \"text\")\nxml = xml2::read_xml(txt)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nxml\n#> {xml_document} ...\n#> [1] <ows:ServiceIdentification>\\n  <ows:Title>GeoServer WFS...\n#> [2] <ows:ServiceProvider>\\n  <ows:ProviderName>UN-FAO Fishe...\n#> ...\n```\n:::\n\n\nLos datos pueden descargarse de los servicios WFS con la petición `GetFeature` y un `typeName` específico (como se ilustra en el fragmento de código siguiente).\n\n\n::: {.cell}\n\n:::\n\n\nLos nombres disponibles varían en función del servicio de características web al que se acceda.\nSe pueden extraer mediante programación utilizando tecnologías web o desplazándose manualmente por el contenido de la salida `GetCapabilities` en un navegador.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqf = list(request = \"GetFeature\", typeName = \"area:FAO_AREAS\")\nfile = tempfile(fileext = \".gml\")\nGET(url = base_url, path = endpoint, query = qf, write_disk(file))\nfao_areas = read_sf(file)\n```\n:::\n\n\nNótese el uso de `write_disk()` para asegurar que los resultados se escriben en disco en lugar de cargarse en memoria, lo que permite importarlos con **sf**.\nEste ejemplo muestra cómo obtener acceso de bajo nivel a servicios web utilizando **httr**, que puede ser útil para entender cómo funcionan los servicios web.\nPara muchas tareas cotidianas, sin embargo, puede ser más apropiada una interfaz de más alto nivel, y se han desarrollado una serie de paquetes de R, y tutoriales, precisamente con este propósito.\nEl paquete **ows4R** fue desarrollado para trabajar con servicios OWS.\n\n## Formatos de archivo\n\nLos conjuntos de datos geográficos suelen almacenarse como archivos o en bases de datos espaciales.\nLos formatos de archivo pueden almacenar datos vectoriales o ráster, mientras que las bases de datos espaciales como [PostGIS](https://postgis.net/) pueden almacenar ambos.\nHoy en día, la variedad de formatos de archivo puede parecer desconcertante, pero se ha producido una gran consolidación y estandarización desde los inicios del software SIG en la década de 1960, cuando se creó el primer programa de amplia distribución ([SYMAP](https://news.harvard.edu/gazette/story/2011/10/the-invention-of-gis/)) para el análisis espacial en la Universidad de Harvard.\n\nGDAL (que debería pronunciarse \"goo-dal\", con la doble \"o\" en referencia a la orientación a objetos), la Biblioteca de Abstracción de Datos Geoespaciales, ha resuelto muchos problemas relacionados con la incompatibilidad entre formatos de archivos geográficos desde su lanzamiento en 2000.\nGDAL proporciona una interfaz unificada y de alto rendimiento para la lectura y escritura de muchos formatos de datos ráster y vectoriales.^[GDAL también contiene un conjunto de funciones de utilidad que permiten la creación de mosaicos ráster, el remuestreo, el recorte y la reproyección, etc.].\nMuchos programas SIG abiertos y propietarios, incluidos GRASS GIS, ArcGIS y QGIS, utilizan GDAL detrás de sus interfaces gráficas de usuario para realizar el trabajo de ingesta y escupir los datos geográficos en los formatos adecuados.\n\nGDAL proporciona acceso a más de 200 formatos de datos vectoriales y ráster.\nLa siguiente tabla presenta información básica sobre los formatos de archivos espaciales seleccionados y utilizados con frecuencia.\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table>\n<caption>Selected spatial file formats.</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Name </th>\n   <th style=\"text-align:left;\"> Extension </th>\n   <th style=\"text-align:left;\"> Info </th>\n   <th style=\"text-align:left;\"> Type </th>\n   <th style=\"text-align:left;\"> Model </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> ESRI Shapefile </td>\n   <td style=\"text-align:left;width: 7em; \"> .shp (the main file) </td>\n   <td style=\"text-align:left;width: 14em; \"> Popular format consisting of at least three files. No support for: files &gt; 2GB;  mixed types; names &gt; 10 chars; cols &gt; 255. </td>\n   <td style=\"text-align:left;\"> Vector </td>\n   <td style=\"text-align:left;width: 7em; \"> Partially open </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> GeoJSON </td>\n   <td style=\"text-align:left;width: 7em; \"> .geojson </td>\n   <td style=\"text-align:left;width: 14em; \"> Extends the JSON exchange format by including a subset of the simple feature representation; mostly used for storing coordinates in longitude and latitude; it is extended by the TopoJSON format </td>\n   <td style=\"text-align:left;\"> Vector </td>\n   <td style=\"text-align:left;width: 7em; \"> Open </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> KML </td>\n   <td style=\"text-align:left;width: 7em; \"> .kml </td>\n   <td style=\"text-align:left;width: 14em; \"> XML-based format for spatial visualization, developed for use with Google Earth. Zipped KML file forms the KMZ format. </td>\n   <td style=\"text-align:left;\"> Vector </td>\n   <td style=\"text-align:left;width: 7em; \"> Open </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> GPX </td>\n   <td style=\"text-align:left;width: 7em; \"> .gpx </td>\n   <td style=\"text-align:left;width: 14em; \"> XML schema created for exchange of GPS data. </td>\n   <td style=\"text-align:left;\"> Vector </td>\n   <td style=\"text-align:left;width: 7em; \"> Open </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> FlatGeobuf </td>\n   <td style=\"text-align:left;width: 7em; \"> .fgb </td>\n   <td style=\"text-align:left;width: 14em; \"> Single file format allowing for quick reading and writing of vector data. Has streaming capabilities. </td>\n   <td style=\"text-align:left;\"> Vector </td>\n   <td style=\"text-align:left;width: 7em; \"> Open </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> GeoTIFF </td>\n   <td style=\"text-align:left;width: 7em; \"> .tif/.tiff </td>\n   <td style=\"text-align:left;width: 14em; \"> Popular raster format. A TIFF file containing additional spatial metadata. </td>\n   <td style=\"text-align:left;\"> Raster </td>\n   <td style=\"text-align:left;width: 7em; \"> Open </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Arc ASCII </td>\n   <td style=\"text-align:left;width: 7em; \"> .asc </td>\n   <td style=\"text-align:left;width: 14em; \"> Text format where the first six lines represent the raster header, followed by the raster cell values arranged in rows and columns. </td>\n   <td style=\"text-align:left;\"> Raster </td>\n   <td style=\"text-align:left;width: 7em; \"> Open </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> SQLite/SpatiaLite </td>\n   <td style=\"text-align:left;width: 7em; \"> .sqlite </td>\n   <td style=\"text-align:left;width: 14em; \"> Standalone  relational database, SpatiaLite is the spatial extension of SQLite. </td>\n   <td style=\"text-align:left;\"> Vector and raster </td>\n   <td style=\"text-align:left;width: 7em; \"> Open </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> ESRI FileGDB </td>\n   <td style=\"text-align:left;width: 7em; \"> .gdb </td>\n   <td style=\"text-align:left;width: 14em; \"> Spatial and nonspatial objects created by ArcGIS. Allows: multiple feature classes; topology. Limited support from GDAL. </td>\n   <td style=\"text-align:left;\"> Vector and raster </td>\n   <td style=\"text-align:left;width: 7em; \"> Proprietary </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> GeoPackage </td>\n   <td style=\"text-align:left;width: 7em; \"> .gpkg </td>\n   <td style=\"text-align:left;width: 14em; \"> Lightweight database container based on SQLite allowing an easy and platform-independent exchange of geodata </td>\n   <td style=\"text-align:left;\"> Vector and (very limited) raster </td>\n   <td style=\"text-align:left;width: 7em; \"> Open </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nLa fundación del Open Geospatial Consortium ([OGC](http://www.opengeospatial.org/)) en 1994 supuso un avance importante en la normalización y la apertura de los formatos de archivo.\nAdemás de definir el modelo de datos de características simples o simple features, el OGC también coordina el desarrollo de normas abiertas, por ejemplo, las utilizadas en formatos de archivo como KML y GeoPackage.\nLos formatos de archivo abiertos del tipo respaldado por el OGC tienen varias ventajas sobre los formatos propietarios: los estándares se publican, garantizan la transparencia y abren la posibilidad de que los usuarios sigan desarrollando y ajustando los formatos de archivo a sus necesidades específicas.\n\nESRI Shapefile es el formato de intercambio de datos vectoriales más popular; sin embargo, no es un formato abierto (aunque su especificación sí lo es).\nSe desarrolló a principios de la década de 1990 y tiene una serie de limitaciones.\nEn primer lugar, es un formato multiarchivo, que consta de al menos tres archivos.\nSólo admite 255 columnas, los nombres de las columnas están restringidos a diez caracteres y el límite de tamaño de los archivos es de 2 GB.\nAdemás, ESRI Shapefile no admite todos los tipos de geometría posibles, por ejemplo, no es capaz de distinguir entre un polígono y un multipolígono.^[Para obtener más información sobre las limitaciones de ESRI Shapefile y posibles formatos de archivo alternativos, visite <http://switchfromshapefile.org/>.]\nA pesar de estas limitaciones, hacía tiempo que se echaba en falta una alternativa viable. \nMientras tanto, surgió [GeoPackage](https://www.geopackage.org/)\\index{GeoPackage}, y parece ser un candidato más que adecuado para sustituir a ESRI Shapefile.\nGeopackage es un formato de intercambio de información geoespacial y una norma OGC. \nLa norma GeoPackage describe las reglas para almacenar información geoespacial en un pequeño contenedor SQLite.\nPor lo tanto, GeoPackage es un contenedor de base de datos espacial ligero, que permite almacenar datos vectoriales y ráster, pero también datos no espaciales y extensiones.\nAparte de GeoPackage, hay otros formatos de intercambio de datos geoespaciales que merece la pena consultar.\n\nEl formato GeoTIFF parece ser el formato de datos ráster más destacado.\nPermite incrustar información espacial, como CRS, en un archivo TIFF. \nAl igual que ESRI Shapefile, este formato se desarrolló por primera vez en los años 90, pero como formato abierto.\nAdemás, GeoTIFF sigue ampliándose y mejorándose.\nUna de las recientes incorporaciones más significativas al formato GeoTIFF es su variante denominada [COG](https://www.cogeo.org/) (*Cloud Optimized GeoTIFF*).\nLos objetos ráster guardados como COG pueden alojarse en servidores HTTP, de modo que otras personas puedan leer sólo partes del archivo sin descargarlo entero.\n\nAdemás, se están desarrollando nuevos formatos de datos espaciales (por ejemplo, [GeoParquet](https://geoparquet.org/) y [Zarr](https://zarr.dev/)) y se están mejorando los existentes.\nSi necesita más información sobre otros formatos, le recomendamos que lea la documentación de GDAL sobre los controladores [vector](https://gdal.org/drivers/vector/index.html) y [raster](https://gdal.org/drivers/raster/index.html).\nAdemás, algunos formatos de datos espaciales pueden almacenar otros modelos (tipos) de datos que no sean vectoriales o ráster.\nEntre ellos se incluyen los formatos LAS y LAZ para almacenar nubes de puntos lidar, y NetCDF y HDF para almacenar matrices multidimensionales.\n\nLos datos espaciales también suelen almacenarse en formatos de texto tabulares (no espaciales), como archivos CSV u hojas de cálculo Excel.\nPor ejemplo, esto puede ser conveniente para compartir muestras espaciales con personas que no utilizan herramientas SIG o intercambiar datos con otro software que no acepte formatos de datos espaciales. \nSin embargo, este enfoque tiene varios posibles problemas: es bastante complicado para almacenar geometrías más complejas que los POINT y no almacena directamente información sobre los CRS.\n\n## Entrada de datos (I)\n\nLa ejecución de comandos como `sf::read_sf()` (la función principal que utilizamos para cargar datos vectoriales) o `terra::rast()` (la función principal utilizada para cargar datos raster) desencadena silenciosamente una cadena de eventos que lee datos de archivos.\nAdemás, existen muchos paquetes de R que contienen una amplia gama de datos geográficos o que proporcionan un acceso sencillo a distintas fuentes de datos.\nTodos ellos cargan los datos en R o, más exactamente, asignan objetos a su espacio de trabajo, almacenados en RAM accesible desde el [`.GlobalEnv`](http://adv-r.had.co.nz/Environments.html) de la sesión de R.\n\n### Vector data\n\nLos datos vectoriales espaciales vienen en una amplia variedad de formatos de archivo.\nLas representaciones más populares, como los archivos `.geojson` y `.gpkg` se pueden importar directamente en R con la función **sf** `read_sf()` (o la equivalente `st_read()`), que utiliza [los controladores vectoriales de GDAL](https://gdal.org/drivers/vector/index.html)\\index{GDAL} entre bastidores.\n`st_drivers()` devuelve un marco de datos que contiene `name` y `long_name` en las dos primeras columnas, y las características de cada controlador disponible para GDAL (y por lo tanto **sf**), incluyendo la capacidad de escribir datos y almacenar datos raster en las columnas siguientes, como se ilustra para los formatos de archivo clave en la Tabla \\ref(tab:drivers).    \nLos siguientes comandos muestran los tres primeros controladores de los que informa la instalación de GDAL del ordenador (los resultados pueden variar en función de la versión de GDAL instalada) y un resumen de sus características.\nNótese que la mayoría de los drivers pueden escribir datos (51 de 87) mientras que sólo 16 formatos pueden representar eficientemente datos raster además de datos vectoriales (ver `?st_drivers()` para más detalles):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsf_drivers = st_drivers()\nhead(sf_drivers, n = 3)\nsummary(sf_drivers[-c(1:2)])\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table>\n<caption>Popular drivers/formats for reading/writing vector data.</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> name </th>\n   <th style=\"text-align:left;\"> long_name </th>\n   <th style=\"text-align:left;\"> write </th>\n   <th style=\"text-align:left;\"> copy </th>\n   <th style=\"text-align:left;\"> is_raster </th>\n   <th style=\"text-align:left;\"> is_vector </th>\n   <th style=\"text-align:left;\"> vsi </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> ESRI Shapefile </td>\n   <td style=\"text-align:left;width: 7em; \"> ESRI Shapefile </td>\n   <td style=\"text-align:left;\"> TRUE </td>\n   <td style=\"text-align:left;\"> FALSE </td>\n   <td style=\"text-align:left;\"> FALSE </td>\n   <td style=\"text-align:left;\"> TRUE </td>\n   <td style=\"text-align:left;\"> TRUE </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> GPX </td>\n   <td style=\"text-align:left;width: 7em; \"> GPX </td>\n   <td style=\"text-align:left;\"> TRUE </td>\n   <td style=\"text-align:left;\"> FALSE </td>\n   <td style=\"text-align:left;\"> FALSE </td>\n   <td style=\"text-align:left;\"> TRUE </td>\n   <td style=\"text-align:left;\"> TRUE </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> KML </td>\n   <td style=\"text-align:left;width: 7em; \"> Keyhole Markup Language (KML) </td>\n   <td style=\"text-align:left;\"> TRUE </td>\n   <td style=\"text-align:left;\"> FALSE </td>\n   <td style=\"text-align:left;\"> FALSE </td>\n   <td style=\"text-align:left;\"> TRUE </td>\n   <td style=\"text-align:left;\"> TRUE </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> GeoJSON </td>\n   <td style=\"text-align:left;width: 7em; \"> GeoJSON </td>\n   <td style=\"text-align:left;\"> TRUE </td>\n   <td style=\"text-align:left;\"> FALSE </td>\n   <td style=\"text-align:left;\"> FALSE </td>\n   <td style=\"text-align:left;\"> TRUE </td>\n   <td style=\"text-align:left;\"> TRUE </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> GPKG </td>\n   <td style=\"text-align:left;width: 7em; \"> GeoPackage </td>\n   <td style=\"text-align:left;\"> TRUE </td>\n   <td style=\"text-align:left;\"> TRUE </td>\n   <td style=\"text-align:left;\"> TRUE </td>\n   <td style=\"text-align:left;\"> TRUE </td>\n   <td style=\"text-align:left;\"> TRUE </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> FlatGeobuf </td>\n   <td style=\"text-align:left;width: 7em; \"> FlatGeobuf </td>\n   <td style=\"text-align:left;\"> TRUE </td>\n   <td style=\"text-align:left;\"> FALSE </td>\n   <td style=\"text-align:left;\"> FALSE </td>\n   <td style=\"text-align:left;\"> TRUE </td>\n   <td style=\"text-align:left;\"> TRUE </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nEl primer argumento de `read_sf()` es `dsn`, que debe ser una cadena de texto o un objeto que contenga una única cadena de texto.\nEl contenido de una cadena de texto puede variar entre diferentes controladores.\nEn la mayoría de los casos, como con el ESRI Shapefile\\index{Shapefile} (`.shp`) o el formato `GeoPackage`index{GeoPackage} (`.gpkg`), el `dsn` sería un nombre de archivo.\n`read_sf()` adivina el controlador basado en la extensión del archivo, como se ilustra para un archivo `.gpkg` a continuación:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf = system.file(\"shapes/world.gpkg\", package = \"spData\")\nworld = read_sf(f, quiet = TRUE)\n```\n:::\n\n\nPara algunos controladores, `dsn` podría proporcionarse como un nombre de carpeta, credenciales de acceso a una base de datos, o una representación de cadena GeoJSON (ver los ejemplos de la página de ayuda `read_sf()` para más detalles).\n\nAlgunos formatos de controladores vectoriales pueden almacenar múltiples capas de datos.\nPor defecto, `read_sf()` lee automáticamente la primera capa del archivo especificado en `dsn`; sin embargo, utilizando el argumento `layer` se puede especificar cualquier otra capa.\n\nLa función `read_sf()` también permite leer sólo partes del fichero en la RAM con dos mecanismos posibles.\nEl primero está relacionado con el argumento `query`, que permite especificar qué parte de los datos leer con [el texto de consulta OGR SQL](https://gdal.org/user/ogr_sql_dialect.html).\nEn el ejemplo siguiente se extraen los datos de Tanzania únicamente.\nSe hace especificando que queremos obtener todas las columnas (`SELECT *`) de la capa `\"world\"` para las que el `name_long` es igual a `\"Tanzania\"`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntanzania = read_sf(f, query = 'SELECT * FROM world WHERE name_long = \"Tanzania\"')\n```\n:::\n\n\nSi no conoce los nombres de las columnas disponibles, un buen método consiste en leer simplemente una fila de los datos con `'SELECT * FROM world WHERE FID = 1'`.\nEl `FID` representa un *ID de característica* -- la mayoría de las veces, es un número de fila; sin embargo, sus valores dependen del formato de fichero utilizado. \nPor ejemplo, `FID` empieza por 0 en ESRI Shapefile, por 1 en algunos otros formatos de archivo, o incluso puede ser arbitrario.\n\n\n::: {.cell}\n\n:::\n\n\nEl segundo mecanismo utiliza el argumento `wkt_filter`.\nEste argumento espera un texto conocido que representa el área de estudio de la que queremos extraer los datos.\nIntentémoslo con un pequeño ejemplo: queremos leer los polígonos de nuestro archivo que se cruzan con el buffer de 50.000 metros de las fronteras de Tanzania.\nPara ello, tenemos que preparar nuestro \"filtro\" (a) creando el buffer, (b) convirtiendo el objeto buffer `sf` en un objeto geométrico `sfc` con `st_geometry()`, y (c) traduciendo las geometrías a su conocida representación de texto con `st_as_text()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntanzania_buf = st_buffer(tanzania, 50000)\ntanzania_buf_geom = st_geometry(tanzania_buf)\ntanzania_buf_wkt = st_as_text(tanzania_buf_geom)\n```\n:::\n\n\nAhora, podemos aplicar este \"filtro\" usando el argumento `wkt_filter`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntanzania_neigh = read_sf(f, wkt_filter = tanzania_buf_wkt)\n```\n:::\n\n\nNuestro resultado contiene Tanzania y todos los países que se encuentran dentro de su buffer de 50 km.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Reading a subset of the vector data using a query (A) and a wkt filter (B).](geo_input_output_files/figure-html/readsfquery-1.png){width=672}\n:::\n:::\n\n\nNaturalmente, algunas opciones son específicas de determinados controladores.^[\nPuede encontrar una lista de los formatos vectoriales y opciones compatibles en http://gdal.org/ogr_formats.html.\n]\nPor ejemplo, pensemos en coordenadas almacenadas en un formato de hoja de cálculo (`.csv`).\nPara leer estos archivos como objetos espaciales, naturalmente tenemos que especificar los nombres de las columnas (`X` y `Y` en nuestro ejemplo de abajo) que representan las coordenadas.\nPodemos hacerlo con la ayuda del parámetro `options`.\nPara conocer las posibles opciones, consulte la sección `Opciones abiertas` de la descripción del controlador GDAL correspondiente.\nPara el formato de valores separados por comas (csv), visite <http://www.gdal.org/drv_csv.html>.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncycle_hire_txt = system.file(\"misc/cycle_hire_xy.csv\", package = \"spData\")\ncycle_hire_xy = read_sf(cycle_hire_txt,\n  options = c(\"X_POSSIBLE_NAMES=X\", \"Y_POSSIBLE_NAMES=Y\"))\n```\n:::\n\n\nEn lugar de columnas que describan las coordenadas \"XY\", una sola columna puede contener también la información geométrica.\nLos formatos de texto conocido (WKT), binario conocido (WKB) y GeoJSON son ejemplos de ello.\nPor ejemplo, el archivo `world_wkt.csv` tiene una columna llamada `WKT` que representa polígonos de los países del mundo.\nUna vez más, utilizaremos el parámetro `options` para indicarlo.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld_txt = system.file(\"misc/world_wkt.csv\", package = \"spData\")\nworld_wkt = read_sf(world_txt, options = \"GEOM_POSSIBLE_NAMES=WKT\")\n# the same as\nworld_wkt2 = st_read(world_txt, options = \"GEOM_POSSIBLE_NAMES=WKT\", \n                    quiet = TRUE, stringsAsFactors = FALSE, as_tibble = TRUE)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n:::{.callout-note}\nNo todos los formatos de ficheros vectoriales soportados almacenan información sobre su sistema de referencia de coordenadas.\nEn estas situaciones, es posible añadir la información que falta utilizando la función `st_set_crs()`.\n:::\n\nComo ejemplo final, mostraremos cómo `read_sf()` también lee archivos KML.\nUn archivo KML almacena información geográfica en formato XML, un formato de datos para la creación de páginas web y la transferencia de datos de forma independiente de la aplicación.\nAquí, accedemos a un archivo KML desde la web.\nEste archivo contiene más de una capa.\n`st_layers()` lista todas las capas disponibles.\nElegimos la primera capa `Placemarks` y lo decimos con la ayuda del parámetro `layer` en `read_sf()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nu = \"https://developers.google.com/kml/documentation/KML_Samples.kml\"\ndownload.file(u, \"KML_Samples.kml\")\nst_layers(\"KML_Samples.kml\")\nkml = read_sf(\"KML_Samples.kml\", layer = \"Placemarks\")\n## Driver: LIBKML \n## Available layers:\n##               layer_name geometry_type features fields crs_name\n## 1             Placemarks                      3     11   WGS 84\n## 2      Styles and Markup                      1     11   WGS 84\n## 3       Highlighted Icon                      1     11   WGS 84\n## 4        Ground Overlays                      1     11   WGS 84\n## 5        Screen Overlays                      0     11   WGS 84\n## 6                  Paths                      6     11   WGS 84\n## 7               Polygons                      0     11   WGS 84\n## 8          Google Campus                      4     11   WGS 84\n## 9       Extruded Polygon                      1     11   WGS 84\n## 10 Absolute and Relative                      4     11   WGS 84\n```\n:::\n\n\nTodos los ejemplos presentados hasta ahora en esta sección han utilizado el paquete **sf** para la importación de datos geográficos.\nEs rápido y flexible, pero puede merecer la pena buscar otros paquetes para formatos de archivo específicos.\nUn ejemplo es el paquete **geojsonsf**.\nUn [benchmark](https://github.com/ATFutures/geobench) sugiere que es unas 10 veces más rápido que el paquete **sf** para leer `.geojson`.\n\n\n::: {.cell}\n\n:::\n\n\n### Datos raster\n\nAl igual que los datos vectoriales, los datos raster vienen en muchos formatos de archivo, algunos de los cuales soportan archivos multicapa.\nEl comando `rast()` de **terra** lee una sola capa cuando se proporciona un archivo con una sola capa.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nraster_filepath = system.file(\"raster/srtm.tif\", package = \"spDataLarge\")\nsingle_layer = rast(raster_filepath)\n```\n:::\n\n\nTambién funciona en caso de que quieras leer un fichero multicapa.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmultilayer_filepath = system.file(\"raster/landsat.tif\", package = \"spDataLarge\")\nmultilayer_rast = rast(multilayer_filepath)\n```\n:::\n\n\nTodos los ejemplos anteriores leen información espacial de archivos almacenados en su disco duro. \nSin embargo, GDAL también permite leer datos directamente de recursos en línea, como recursos web HTTP/HTTPS/FTP.\nLo único que tenemos que hacer es añadir un prefijo `/vsicurl/` antes de la ruta al fichero.\nVamos a probarlo conectándonos a la probabilidad de nieve mensual global a 500 m de resolución para el periodo 2000-2012.\nLa probabilidad de nieve para diciembre se almacena como archivo COG (Cloud Optimized GeoTIFF) en \\url{https://zenodo.org/record/5774954/files/clm_snow.prob_esacci.dec_p.90_500m_s0..0cm_2000..2012_v2.0.tif}.\nPara leer un archivo en línea, basta con proporcionar su URL junto con el prefijo `/vsicurl/`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyurl = \"/vsicurl/https://zenodo.org/record/5774954/files/clm_snow.prob_esacci.dec_p.90_500m_s0..0cm_2000..2012_v2.0.tif\"\nsnow = rast(myurl)\nsnow\n## class       : SpatRaster \n## dimensions  : 35849, 86400, 1  (nrow, ncol, nlyr)\n## resolution  : 0.004166667, 0.004166667  (x, y)\n## extent      : -180, 180, -62.00083, 87.37  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source      : clm_snow.prob_esacci.dec_p.90_500m_s0..0cm_2000..2012_v2.0.tif \n## name        : clm_snow.prob_esacci.dec_p.90_500m_s0..0cm_2000..2012_v2.0\n```\n:::\n\n\nDebido a que los datos de entrada son COG, en realidad no estamos leyendo este fichero en nuestra RAM, sino creando una conexión con él sin obtener ningún valor.\nSus valores serán leídos si aplicamos cualquier operación basada en valores (por ejemplo, `crop()` o `extract()`).\nEsto nos permite también leer sólo una pequeña porción de los datos sin descargar todo el fichero.\nPor ejemplo, podemos obtener la probabilidad de nieve para diciembre en Reikiavik (70%) especificando sus coordenadas y aplicando la función `extract()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrey = data.frame(lon = -21.94, lat = 64.15)\nsnow_rey = extract(snow, rey)\nsnow_rey\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n<table>\n <thead>\n  <tr>\n   <th style=\"text-align:right;\"> ID </th>\n   <th style=\"text-align:right;\"> clm_snow.prob_esacci.dec_p.90_500m_s0..0cm_2000..2012_v2.0 </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> 70 </td>\n  </tr>\n</tbody>\n</table>\n\n</div>\n:::\n:::\n\n\nDe esta forma, sólo descargamos un único valor en lugar de todo el archivo GeoTIFF de gran tamaño.\n\nEl ejemplo anterior sólo muestra un caso sencillo (pero útil), pero hay más por explorar.\nEl prefijo `/vsicurl/` también funciona no sólo para los formatos de archivo raster, sino también para los vectoriales.\nPermite leer vectores directamente desde el almacenamiento en línea con `read_sf()` simplemente añadiendo el prefijo antes de la URL del archivo vectorial.\n\nEs importante destacar que `/vsicurl/` no es el único prefijo proporcionado por GDAL; existen muchos más, como `/vsizip/` para leer archivos espaciales de archivos ZIP sin descomprimirlos previamente o `/vsis3/` para leer sobre la marcha archivos disponibles en cubos S3 de AWS.\nPuede obtener más información en <https://gdal.org/user/virtual_file_systems.html>.\n\n## Salida de datos (O) \n\nLa escritura de datos geográficos permite convertir de un formato a otro y guardar objetos recién creados.\nDependiendo del tipo de datos (vector o raster), clase de objeto (por ejemplo, `sf` o `SpatRaster`), y tipo y cantidad de información almacenada (por ejemplo, tamaño del objeto, rango de valores), es importante saber cómo almacenar archivos espaciales de la manera más eficiente.\nEn las dos secciones siguientes se muestra cómo hacerlo.\n\n### Vector data\n\n\n::: {.cell}\n\n:::\n\n\nLa contrapartida de `read_sf()` es `write_sf()`.\nPermite escribir objetos **sf** en una amplia gama de formatos de archivos vectoriales geográficos, incluidos los más comunes como `.geojson`, `.shp` y `.gpkg`.\nBasándose en el nombre del archivo, `write_sf()` decide automáticamente qué controlador utilizar. \nLa velocidad del proceso de escritura depende también del controlador.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_sf(obj = world, dsn = \"world.gpkg\")\n```\n:::\n\n\n**Nota**: si intentas escribir de nuevo en la misma fuente de datos, la función sobrescribirá el fichero:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_sf(obj = world, dsn = \"world.gpkg\")\n```\n:::\n\n\nEn lugar de sobrescribir el archivo, podríamos añadir una nueva capa al archivo con `append = TRUE`, que es soportado por varios formatos espaciales, incluyendo GeoPackage.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_sf(obj = world, dsn = \"world_many_layers.gpkg\", append = TRUE)\n```\n:::\n\n\nAlternativamente, puede usar `st_write()` ya que es equivalente a `write_sf()`.\nSin embargo, tiene diferentes valores por defecto -- no sobrescribe archivos (devuelve un error cuando intenta hacerlo) y muestra un breve resumen del formato del archivo escrito y el objeto.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_write(obj = world, dsn = \"world2.gpkg\")\n## Writing layer `world2' to data source `world2.gpkg' using driver `GPKG'\n## Writing 177 features with 10 fields and geometry type Multi Polygon.\n```\n:::\n\n\nEl argumento `layer_options` también se puede utilizar para muchos propósitos diferentes.\nUno de ellos es escribir datos espaciales en un fichero de texto.\nEsto puede hacerse especificando `GEOMETRY` dentro de `layer_options`. \nPuede ser `AS_XY` para conjuntos de datos de puntos simples (crea dos nuevas columnas para las coordenadas) o `AS_WKT` para datos espaciales más complejos (se crea una nueva columna que contiene la conocida representación textual de los objetos espaciales).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_sf(cycle_hire_xy, \"cycle_hire_xy.csv\", layer_options = \"GEOMETRY=AS_XY\")\nwrite_sf(world_wkt, \"world_wkt.csv\", layer_options = \"GEOMETRY=AS_WKT\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n### Datos Raster {#raster-data-write}\n\nLa función `writeRaster()` guarda objetos `SpatRaster` en archivos de disco. \nLa función espera información sobre el tipo de datos de salida y el formato de archivo, pero también acepta opciones de GDAL específicas para el formato de archivo seleccionado (véase `?writeRaster` para más detalles).\n\nEl paquete **terra** ofrece siete tipos de datos a la hora de guardar una trama: INT1U, INT2S, INT2U, INT4S, INT4U, FLT4S, y FLT8S.^[\nNo se recomienda usar INT4U ya que R no soporta enteros sin signo de 32 bits.\n]\nEl tipo de datos determina la representación en bits del objeto ráster escrito en el disco.\nEl tipo de datos a utilizar depende del rango de valores del objeto raster.\nCuantos más valores pueda representar un tipo de datos, más grande será el archivo en disco.\nLos enteros sin signo (INT1U, INT2U, INT4U) son adecuados para datos categóricos, mientras que los números flotantes (FLT4S y FLT8S) suelen representar datos continuos.\n`writeRaster()` utiliza FLT4S por defecto.\nAunque esto funciona en la mayoría de los casos, el tamaño del fichero de salida será innecesariamente grande si guarda datos binarios o categóricos.\nPor lo tanto, recomendamos utilizar el tipo de datos que necesite menos espacio de almacenamiento, pero que sea capaz de representar todos los valores (compruebe el rango de valores con la función `summary()`).\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table>\n<caption>Data types supported by the terra package.</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Data type </th>\n   <th style=\"text-align:left;\"> Minimum value </th>\n   <th style=\"text-align:left;\"> Maximum value </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> INT1U </td>\n   <td style=\"text-align:left;\"> 0 </td>\n   <td style=\"text-align:left;\"> 255 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> INT2S </td>\n   <td style=\"text-align:left;\"> -32,767 </td>\n   <td style=\"text-align:left;\"> 32,767 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> INT2U </td>\n   <td style=\"text-align:left;\"> 0 </td>\n   <td style=\"text-align:left;\"> 65,534 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> INT4S </td>\n   <td style=\"text-align:left;\"> -2,147,483,647 </td>\n   <td style=\"text-align:left;\"> 2,147,483,647 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> INT4U </td>\n   <td style=\"text-align:left;\"> 0 </td>\n   <td style=\"text-align:left;\"> 4,294,967,296 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> FLT4S </td>\n   <td style=\"text-align:left;\"> -3.4e+38 </td>\n   <td style=\"text-align:left;\"> 3.4e+38 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> FLT8S </td>\n   <td style=\"text-align:left;\"> -1.7e+308 </td>\n   <td style=\"text-align:left;\"> 1.7e+308 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nPor defecto, el formato del archivo de salida se deriva del nombre del archivo.\nAl nombrar un archivo `*.tif` se creará un archivo GeoTIFF, como se muestra a continuación:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwriteRaster(single_layer, filename = \"my_raster.tif\", datatype = \"INT2U\")\n```\n:::\n\n\nAlgunos formatos de archivo ráster tienen opciones adicionales, que pueden establecerse proporcionando [parámetros GDAL](http://www.gdal.org/formats_list.html) al argumento `options` de `writeRaster()`.\nLos archivos GeoTIFF se escriben en **terra**, por defecto, con la compresión LZW `gdal = c(\"COMPRESS=LZW\")`.\nPara cambiar o desactivar la compresión, necesitamos modificar este argumento.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwriteRaster(x = single_layer, filename = \"my_raster.tif\",\n            gdal = c(\"COMPRESS=NONE\"), overwrite = TRUE)\n```\n:::\n\n\nAdemás, podemos guardar nuestro objeto raster como COG (*Cloud Optimized GeoTIFF*) con las opciones `filetype = \"COG\"`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwriteRaster(x = single_layer, filename = \"my_raster.tif\",\n            filetype = \"COG\", overwrite = TRUE)\n```\n:::\n\n\n## Resultados visuales\n\nR soporta muchos formatos diferentes de gráficos estáticos e interactivos.\nEl método más general para guardar un gráfico estático es abrir un dispositivo gráfico, crear un gráfico y cerrarlo, por ejemplo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npng(filename = \"lifeExp.png\", width = 500, height = 350)\nplot( world[\"lifeExp\"])\ndev.off()\n```\n:::\n\n\nOtros dispositivos gráficos disponibles son `pdf()`, `bmp()`, `jpeg()` y `tiff()`. \nPuede especificar varias propiedades del gráfico de salida, como la anchura, la altura y la resolución.\n\nAdemás, varios paquetes gráficos proporcionan sus propias funciones para guardar una salida gráfica.\nPor ejemplo, el paquete **tmap** tiene la función `tmap_save()`.\nPuede guardar un objeto `tmap` en diferentes formatos gráficos o en un archivo HTML especificando el nombre del objeto y una ruta a un nuevo archivo.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tmap)\ntmap_obj = tm_shape(world) + tm_polygons(col = \"lifeExp\")\ntmap_save(tmap_obj, filename = \"lifeExp_tmap.png\")\n```\n:::\n\n\nPor otra parte, puede guardar los mapas interactivos creados en el paquete **mapview** como un archivo HTML o una imagen utilizando la función `mapshot()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mapview)\nmapview_obj = mapview(world, zcol = \"lifeExp\", legend = TRUE)\nmapshot(mapview_obj, file = \"my_interactive_map.html\")\n```\n:::\n",
    "supporting": [
      "geo_input_output_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}