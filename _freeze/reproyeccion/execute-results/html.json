{
  "hash": "1edef4989acef1f20b5056ce6d00d070",
  "result": {
    "markdown": "---\ntitle: \"Reproyeccion\"\nauthor: \"Modificado de <https://r.geocompx.org/>\"\nformat: \n  html:\n    toc: true\n    df-print: kable\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(terra)\nlibrary(dplyr)\nlibrary(spData)\nlibrary(spDataLarge)\n```\n:::\n\n\n## Introducción\n\nLos sistemas de referencia de coordenadas (SRC) pueden ser de dos tipos principales: sistemas de coordenadas *geográficas* ('lon/lat', con unidades en grados de longitud y latitud) y *proyectadas* (normalmente con unidades de metros desde un datum).\nEste capítulo demuestra cómo establecer y *transformar* datos geográficos de un CRS a otro y, además, destaca problemas específicos que pueden surgir debido a ignorar CRSs y que deberías tener en cuenta, especialmente si tus datos se almacenan con coordenadas lon/lat.\n\nEn muchos proyectos no hay necesidad de preocuparse por los diferentes CRS, y mucho menos de realizar conversiones entre ellos.\nSin embargo, si conoces el CRS de tus datos y las consecuencias para las operaciones geométricas (tratadas en la siguiente sección), los CRSs deberían *simplemente funcionar* entre bastidores: la gente a menudo necesita aprender de repente sobre los CRSs cuando las cosas van mal.\nTener un CRS claramente definido en el que estén todos los datos del proyecto, además de entender cómo y por qué usar diferentes CRSs, puede asegurar que las cosas no vayan mal.\n\nEste capítulo enseña los fundamentos de los CRS, demuestra las consecuencias de utilizar diferentes CRS (incluyendo lo que puede salir mal) y cómo \"reproyectar\" conjuntos de datos de un sistema de coordenadas a otro.\nEn las siguientes secciones introducimos los CRSs en R, cómo obtener y establecer CRSs asociados con objetos espaciales, cuándo reproyectar y qué CRS utilizar, entre otras cosas.\n\n## Sistemas de referencia de coordenadas\n\nLa mayoría de las herramientas geográficas modernas que requieren conversiones de CRS, incluidos los paquetes básicos de R-spatial y el software SIG de escritorio como QGIS, interactúan con [PROJ](https://proj.org), una biblioteca C++ de código abierto que \"transforma coordenadas de un sistema de referencia de coordenadas (CRS) a otro\".\nLos CRS pueden describirse de muchas maneras, entre las que se incluyen las siguientes.\n\n1. Enunciados simples pero potencialmente ambiguos como \"está en coordenadas lon/lat\".\n2. \"proj4 strings\" formalizadas, aunque ya obsoletas, como `+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs`.\n3. Con una cadena de texto identificativa \"authority:code\" como `EPSG:4326`.\n\nCada una de ellas hace referencia a lo mismo: el sistema de coordenadas \"WGS84\" que constituye la base de las coordenadas del Sistema de Posicionamiento Global (GPS) y de muchos otros conjuntos de datos.\nPero, ¿cuál es el correcto?\n\nLa respuesta corta es que la tercera forma de identificar los CRS es preferible: Los paquetes **sf** (y por extensión **stars**) y **terra**, además de muchos otros proyectos de software para trabajar con datos geográficos, entienden `EPSG:4326`.\nAdemás, es corto, fácil de recordar y muy 'localizable' en línea.\n**sf** entiende el identificador más conciso `4326`, pero **recomendamos la representación más explícita `AUTHORITY:CODE` para evitar ambigüedades y proporcionar contexto**.\n\nLa respuesta más larga es que ninguna de las tres descripciones es suficiente y se necesitan más detalles para manejar y transformar los CRS sin ambigüedades: debido a la complejidad de los SIR, no es posible capturar toda la información relevante sobre ellos en cadenas de texto tan cortas.\nPor este motivo, el Open Geospatial Consortium desarrolló un formato estándar abierto que se denomina WKT (Well-Known Text).\nEsto se detalla en un [documento de más de 100 páginas](https://portal.opengeospatial.org/files/18-010r7) que \"define la estructura y el contenido de una implementación de cadena de texto del modelo abstracto para sistemas de referencia de coordenadas descrito en ISO 19111:2019\".\nLa representación WKT del SIR WGS84, que tiene el **identificador** `EPSG:4326` es la siguiente:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(\"EPSG:4326\")\n## Coordinate Reference System:\n##   User input: EPSG:4326 \n##   wkt:\n## GEOGCRS[\"WGS 84\",\n##     ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n##         MEMBER[\"World Geodetic System 1984 (Transit)\"],\n##         MEMBER[\"World Geodetic System 1984 (G730)\"],\n##         MEMBER[\"World Geodetic System 1984 (G873)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1150)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1674)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1762)\"],\n##         MEMBER[\"World Geodetic System 1984 (G2139)\"],\n##         ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n##             LENGTHUNIT[\"metre\",1]],\n##         ENSEMBLEACCURACY[2.0]],\n##     PRIMEM[\"Greenwich\",0,\n##         ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     CS[ellipsoidal,2],\n##         AXIS[\"geodetic latitude (Lat)\",north,\n##             ORDER[1],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##         AXIS[\"geodetic longitude (Lon)\",east,\n##             ORDER[2],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     USAGE[\n##         SCOPE[\"Horizontal component of 3D system.\"],\n##         AREA[\"World.\"],\n##         BBOX[-90,-180,90,180]],\n##     ID[\"EPSG\",4326]]\n```\n:::\n\n\nLa convención de referirse a los identificadores CRSs de la forma `AUTORIDAD:CÓDIGO`, que también es utilizada por el software geográfico escrito en otros [lenguajes](https://jorisvandenbossche.github.io/blog/2020/02/11/geopandas-pyproj-crs/), permite referirse a una amplia gama de sistemas de coordenadas formalmente definidos.^[Se pueden utilizar otras formas de referirse a CRS únicos, con cinco tipos de identificadores (código EPSG, PostGIS SRID, INTERNAL SRID, proj-string y cadenas WKT) aceptados por [QGIS](https://docs.qgis.org/3.16/en/docs/pyqgis_developer_cookbook/crs.html?highlight=srid) y otros tipos de identificadores como una variante más verbosa del identificador `EPSG:4326`, `urn:ogc:def:crs:EPSG::4326`.]\nLa autoridad más utilizada en los identificadores CRS es *EPSG*, acrónimo de European Petroleum Survey Group, que publicó una lista normalizada de CRS (el EPSG fue [absorbido](http://wiki.gis.com/wiki/index.php/European_Petroleum_Survey_Group) por el organismo de petróleo y gas el [Comité de Geomática de la Asociación Internacional de Productores de Petróleo y Gas](https://www.iogp.org/our-committees/geomatics/) en 2005).\nPueden utilizarse otras autoridades en los identificadores SIR.\n`ESRI:54030`, por ejemplo, se refiere a la implementación de ESRI de la proyección Robinson, que tiene la siguiente cadena WKT (sólo se muestran las 8 primeras líneas):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(\"ESRI:54030\")\n#> Coordinate Reference System:\n#>   User input: ESRI:54030 \n#>   wkt:\n#> PROJCRS[\"World_Robinson\",\n#>     BASEGEOGCRS[\"WGS 84\",\n#>         DATUM[\"World Geodetic System 1984\",\n#>             ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n#>                 LENGTHUNIT[\"metre\",1]]],\n#> ...\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nLas cadenas WKT son exhaustivas, detalladas y precisas, y permiten almacenar y transformar los SIR sin ambigüedades.\nContienen toda la información relevante sobre cualquier SIR, incluido su datum y elipsoide, meridiano principal, proyección y unidades.\nAntes de la aparición de las definiciones WKT CRS, proj-string era la forma estándar de especificar operaciones de coordenadas y almacenar CRSs.\nEstas representaciones de cadena, construidas sobre una forma clave=valor (por ejemplo, `+proj=longlat +datum=WGS84 +no_defs`), ya han sido, o deberían ser en el futuro, sustituidas por representaciones WKT en la mayoría de los casos.\n\nLas versiones recientes de PROJ (6+) todavía permiten el uso de proj-strings para definir operaciones de coordenadas, pero algunas claves proj-string (`+nadgrids`, `+towgs84`, `+k`, `+init=epsg:`) ya no se soportan o se desaconsejan.\n\n## Consulta y establecimiento de sistemas de coordenadas {#crs-setting}\n\nVeamos cómo se almacenan los CRS en los objetos espaciales de R y cómo pueden consultarse y establecerse.\nPrimero veremos cómo obtener y establecer CRS en objetos geográficos **vector**, comenzando con el siguiente ejemplo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvector_filepath = system.file(\"shapes/world.gpkg\", package = \"spData\")\nnew_vector = read_sf(vector_filepath)\n```\n:::\n\n\nEl CRS puede recuperarse con la función **sf** `st_crs()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(new_vector) # get CRS\n#> Coordinate Reference System:\n#>   User input: WGS 84 \n#>   wkt:\n#>   ...\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nLa salida es una lista que contiene dos componentes principales:\n\n1. `User input` (en este caso `WGS 84`, un sinónimo de `EPSG:4326` que en este caso se tomó del fichero de entrada), correspondiente a los identificadores CRS descritos anteriormente\n2. `wkt`, que contiene la cadena WKT completa con toda la información pertinente sobre el CRS.\n\nEl elemento `input` es flexible, y dependiendo del fichero de entrada o de la entrada del usuario, puede contener la representación `AUTHORITY:CODE` (por ejemplo, `EPSG:4326`), el nombre del CRS (por ejemplo, `WGS 84`), o incluso la definición proj-string.\nEl elemento `wkt` almacena la representación WKT, que se utiliza al guardar el objeto en un archivo o al realizar cualquier operación de coordenadas.\nArriba, podemos ver que el objeto `new_vector` tiene el elipsoide WGS84, utiliza el meridiano de Greenwich, y el orden de los ejes de latitud y longitud.\nEn este caso, también tenemos algunos elementos adicionales, como `USAGE` que explica el área adecuada para el uso de este CRS, e `ID` que señala el identificador del CRS: `EPSG:4326`.\n\nLa función `st_crs` también tiene una característica útil: podemos recuperar información adicional sobre el CRS utilizado. \nPor ejemplo, intente ejecutar\n\n- `st_crs(new_vector)$IsGeographic` para comprobar si el CRS es geográfico o no\n- `st_crs(new_vector)$units_gdal` para averiguar las unidades del CRS\n- `st_crs(new_vector)$srid` extrae su identificador \"SRID\" (si está disponible)\n- `st_crs(new_vector)$proj4string` extrae la representación proj-string\n\nEn los casos en los que falta un sistema de referencia de coordenadas (CRS) o se establece un CRS incorrecto, se puede utilizar la función `st_set_crs()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_vector = st_set_crs(new_vector, \"EPSG:4326\") # set CRS\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nLa obtención y configuración de los CRS funciona de forma similar para los objetos ráster.\nLa función `crs()` del paquete `terra` accede a la información CRS de un objeto `SpatRaster` (nótese el uso de la función `cat()` para imprimirla correctamente): \n\n\n::: {.cell}\n\n```{.r .cell-code}\nraster_filepath = system.file(\"raster/srtm.tif\", package = \"spDataLarge\")\nmy_rast = rast(raster_filepath)\ncat(crs(my_rast)) # get CRS\n## GEOGCRS[\"WGS 84\",\n##     ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n##         MEMBER[\"World Geodetic System 1984 (Transit)\"],\n##         MEMBER[\"World Geodetic System 1984 (G730)\"],\n##         MEMBER[\"World Geodetic System 1984 (G873)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1150)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1674)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1762)\"],\n##         MEMBER[\"World Geodetic System 1984 (G2139)\"],\n##         ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n##             LENGTHUNIT[\"metre\",1]],\n##         ENSEMBLEACCURACY[2.0]],\n##     PRIMEM[\"Greenwich\",0,\n##         ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     CS[ellipsoidal,2],\n##         AXIS[\"geodetic latitude (Lat)\",north,\n##             ORDER[1],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##         AXIS[\"geodetic longitude (Lon)\",east,\n##             ORDER[2],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     USAGE[\n##         SCOPE[\"Horizontal component of 3D system.\"],\n##         AREA[\"World.\"],\n##         BBOX[-90,-180,90,180]],\n##     ID[\"EPSG\",4326]]\n```\n:::\n\n\nLa salida es la representación de cadena WKT de CRS. \nLa misma función, `crs()`, también se puede utilizar para establecer un CRS para objetos raster.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrs(my_rast) = \"EPSG:26912\" # set CRS\n```\n:::\n\n\nEs importante destacar que las funciones `st_crs()` y `crs()` no alteran los valores de las coordenadas ni las geometrías.\nSu función es únicamente establecer una información de metadatos sobre el CRS del objeto.\n\nEn algunos casos, el CRS de un objeto geográfico es desconocido, como es el caso del conjunto de datos `london` creado en el fragmento de código siguiente:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlondon = data.frame(lon = -0.1, lat = 51.5) |> \n  st_as_sf(coords = c(\"lon\", \"lat\"))\nst_is_longlat(london)\n## [1] NA\n```\n:::\n\n\nLa salida `NA` muestra que **sf** no sabe cuál es el CRS y no está dispuesto a adivinarlo (`NA` significa literalmente 'no disponible').\nA menos que un CRS se especifique manualmente o se cargue desde una fuente que tenga metadatos CRS, **sf** no hace ninguna suposición explícita sobre qué sistemas de coordenadas, aparte de decir \"no lo sé\".\nEste comportamiento tiene sentido dada la diversidad de CRS disponibles, pero difiere de algunos enfoques, como la especificación del formato de archivo GeoJSON, que hace la suposición simplificadora de que todas las coordenadas tienen un CRS lon/lat: `EPSG:4326`.\nLos conjuntos de datos sin un CRS especificado pueden causar problemas: todas las coordenadas geográficas tienen un sistema de coordenadas y el software sólo puede tomar decisiones correctas sobre el trazado y las operaciones geométricas si sabe con qué tipo de CRS está trabajando.\nPor lo tanto, de nuevo, es importante comprobar siempre el CRS de un conjunto de datos y establecerlo si falta.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlondon_geo = st_set_crs(london, \"EPSG:4326\")\nst_is_longlat(london_geo)\n## [1] TRUE\n```\n:::\n\n\n## Operaciones geométricas sobre datos proyectados y no proyectados {#geom-proj}\n\nDesde la versión 1.0.0 de **sf**, la capacidad de R para trabajar con conjuntos de datos vectoriales geográficos que tienen CRS lon/lat ha mejorado sustancialmente, gracias a su integración con el *motor de geometría esférica* S2. GEOS se utiliza siempre para datos proyectados y datos sin CRS; para datos geográficos se utiliza S2 por defecto, pero puede desactivarse con `sf::sf_use_s2(FALSE)`.\n\nPara demostrar la importancia de los SIR, crearemos un búfer de 100 km alrededor del objeto \"Londres\" de la sección anterior.\nTambién crearemos un búfer deliberadamente defectuoso con una \"distancia\" de 1 grado, que equivale aproximadamente a 100 km (1 grado son unos 111 km en el ecuador).\n\nLa primera etapa consiste en crear tres buffers alrededor de los objetos `london` y `london_geo` creados anteriormente con distancias límite de 1 grado y 100 km (o 100.000 m, que puede expresarse como `1e5` en notación científica) desde el centro de Londres:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlondon_buff_no_crs = st_buffer(london, dist = 1)   # incorrect: no CRS\nlondon_buff_s2 = st_buffer(london_geo, dist = 100000) # silent use of s2\nlondon_buff_s2_100_cells = st_buffer(london_geo, dist = 100000, max_cells = 100) \n```\n:::\n\n\nEn la primera línea de arriba, **sf** asume que la entrada es proyectada y genera un resultado que tiene un buffer en unidades de grados, lo cual es problemático, como veremos.\nEn la segunda línea, **sf** usa silenciosamente el motor de geometría esférica S2 para calcular la extensión del buffer usando el valor por defecto de `max_cells = 1000` --- fijado a `100` en la línea tres --- las consecuencias se harán evidentes en breve (ver `?s2::s2_buffer_cells` para más detalles).\n\nPara resaltar el impacto del uso del motor de geometría S2 por **sf** para sistemas de coordenadas (geográficas) no proyectadas, lo desactivaremos temporalmente con el comando `sf_use_s2()` (que está activado, `TRUE`, por defecto), en el trozo de código que sigue.\nAl igual que `london_buff_no_crs`, el nuevo objeto `london_geo` es una abominación geográfica: tiene unidades de grados, lo que no tiene sentido en la gran mayoría de los casos:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsf::sf_use_s2(FALSE)\nlondon_buff_lonlat = st_buffer(london_geo, dist = 1) # incorrect result\nsf::sf_use_s2(TRUE)\n```\n:::\n\n\nEl mensaje de advertencia anterior indica problemas al realizar operaciones geométricas planas en datos lon/lat. \nCuando las operaciones de geometría esférica están desactivadas, con el comando `sf::sf_use_s2(FALSE)`, los buffers (y otras operaciones geométricas) pueden dar como resultado salidas sin valor porque utilizan unidades de latitud y longitud, un mal sustituto de las unidades adecuadas de distancias como los metros.\n\n:::{.callout-note}\nLa distancia entre dos líneas de longitud, llamadas meridianos, es de unos 111 km en el ecuador (ejecute `geosphere::distGeo(c(0, 0), c(1, 0))` para encontrar la distancia exacta).\nEn los polos se reduce a cero.\nEn la latitud de Londres, por ejemplo, los meridianos están a menos de 70 km de distancia.\n\nLas líneas de latitud, por el contrario, son equidistantes entre sí independientemente de la latitud: siempre están separadas unos 111 km, incluso en el ecuador y cerca de los polos.\n:::\n\nPara las operaciones que implican distancias, como el buffering, la única forma de garantizar un buen resultado (sin utilizar motores de geometría esférica) es crear una copia proyectada de los datos y ejecutar la operación sobre ella.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlondon_proj = data.frame(x = 530000, y = 180000) |> \n  st_as_sf(coords = c(\"x\", \"y\"), crs = \"EPSG:27700\")\n```\n:::\n\n\nEl resultado es un nuevo objeto idéntico a `london`, pero reproyectado sobre un CRS adecuado (la British National Grid, que tiene un código EPSG de 27700 en este caso) que tiene unidades de metros.\nPodemos verificar que el CRS ha cambiado usando `st_crs()` como sigue (parte de la salida ha sido reemplazada por `...`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(london_proj)\n#> Coordinate Reference System:\n#>   User input: EPSG:27700 \n#>   wkt:\n#> PROJCRS[\"OSGB36 / British National Grid\",\n#>     BASEGEOGCRS[\"OSGB36\",\n#>         DATUM[\"Ordnance Survey of Great Britain 1936\",\n#>             ELLIPSOID[\"Airy 1830\",6377563.396,299.3249646,\n#>                 LENGTHUNIT[\"metre\",1]]],\n#> ...\n```\n:::\n\n\nEntre los componentes más destacados de esta descripción se incluyen el código EPSG (`EPSG: 27700`) y la cadena detallada `wkt` (de la que sólo se muestran las 5 primeras líneas).\nEl hecho de que las unidades del CRS, descritas en el campo LENGTHUNIT, sean metros (en lugar de grados) nos indica que se trata de un CRS proyectado: `st_is_longlat(london_proj)` devuelve ahora `FALSE` y las operaciones geométricas sobre `london_proj` funcionarán sin advertencia.\nLas operaciones de buffer sobre `london_proj` utilizarán GEOS y los resultados se devolverán con las unidades de distancia adecuadas.\nLa siguiente línea de código crea un buffer alrededor de datos *proyectados* de exactamente 100 km:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlondon_buff_projected = st_buffer(london_proj, 100000)\n```\n:::\n\n\nLas geometrías de los tres objetos `london_buff*` que *tienen* un CRS especificado creados anteriormente (`london_buff_s2`, `london_buff_lonlat` y `london_buff_projected`) creados en los trozos de código anteriores se ilustran en la Figura \\@ref(fig:crs-buf).\n\n\n\n\n::: {.cell fig.asp='0.39'}\n::: {.cell-output-display}\n![Buffers around London showing results created with the S2 spherical geometry engine on lon/lat data (left), projected data (middle) and lon/lat data without using spherical geometry (right). The left plot illustrates the result of buffering unprojected data with sf, which calls Google's S2 spherical geometry engine by default with max cells set to 1000 (thin line). The thick 'blocky' line illustrates the result of the same operation with max cells set to 100.](reproyeccion_files/figure-html/crs-buf-1.png){fig-scap='Buffers around London with a geographic and projected CRS.' width=768}\n:::\n:::\n\n\nSe ve claramente que los búferes basados en `s2` y CRS proyectados correctamente no están \"aplastados\", lo que significa que cada parte del límite del búfer es equidistante de Londres.\nLos resultados generados a partir de CRSs lon/lat cuando no se utiliza `s2`, ya sea porque la entrada carece de CRS o porque `sf_use_s2()` está desactivada, están muy distorsionados, con el resultado alargado en el eje norte-sur, lo que pone de manifiesto los peligros de utilizar algoritmos que asumen datos proyectados en entradas lon/lat (como hace GEOS).\nSin embargo, los resultados generados con S2 también están distorsionados, aunque de forma menos dramática.\nLos dos límites de los búferes de la figura izquierda están dentados, aunque esto sólo puede ser evidente o relevante en el caso del límite grueso que representa un búfer creado con el argumento `s2` `max_cells` fijado en 100. La lección es que los resultados obtenidos a partir de datos lon/lat con S2 también están distorsionados, aunque de forma menos dramática.\nLa lección es que los resultados obtenidos a partir de datos lon/lat mediante S2 serán diferentes de los resultados obtenidos utilizando datos proyectados.\nLa diferencia entre los buffers derivados de S2 y los buffers derivados de GEOS sobre datos proyectados se reducen a medida que aumenta el valor de `max_cells`: el valor \"correcto\" para este argumento puede depender de muchos factores y el valor por defecto 1000 es un valor por defecto razonable.\nAl elegir los valores de `max_cells`, la velocidad de cálculo debe equilibrarse con la resolución de los resultados.\nEn situaciones en las que los límites curvos son ventajosos, puede ser apropiado transformar a un CRS proyectado antes de almacenar (o realizar otras operaciones geométricas).\n\nLa importancia de los CRS (principalmente si son proyectados o geográficos) y los impactos de la configuración por defecto de **sf** de utilizar S2 para los buffers en los datos lon/lat quedan claros en el ejemplo anterior.\nEn las secciones siguientes se profundiza en qué CRS utilizar cuando se necesitan CRS proyectados y en los detalles de la reproyección de objetos vectoriales y ráster.\n\n## ¿Cuándo reproyectar?\n\nLa sección anterior mostraba cómo establecer el CRS manualmente, con `st_set_crs(london, \"EPSG:4326\")`.\nSin embargo, en las aplicaciones del mundo real, los CRS suelen establecerse automáticamente cuando se leen los datos.\nEn muchos proyectos, la principal tarea relacionada con los CRS es *transformar* objetos, de un CRS a otro.\nPero, ¿cuándo deben transformarse los datos? \n¿Y en qué CRS?\nNo hay respuestas claras a estas preguntas y la selección del CRS siempre implica compromisos.\nSin embargo, se ofrecen algunos principios generales que pueden ayudarle a decidir. \n\nEn primer lugar, merece la pena considerar *cuándo transformar*.\nEn algunos casos la transformación a un CRS geográfico es esencial, como cuando se publican datos en línea con el paquete **leaflet**.\nOtro caso es cuando hay que comparar o combinar dos objetos con diferentes CRS, como cuando intentamos encontrar la distancia entre dos objetos con diferentes CRS:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_distance(london_geo, london_proj)\n# > Error: st_crs(x) == st_crs(y) is not TRUE\n```\n:::\n\n\nPara que los objetos `london` y `london_proj` sean geográficamente comparables, uno de ellos debe transformarse en el CRS del otro.\nPero, ¿qué CRS utilizar?\nLa respuesta depende del contexto: muchos proyectos, especialmente los de cartografía web, requieren salidas en EPSG:4326, en cuyo caso merece la pena transformar el objeto proyectado.\nSi, por el contrario, el proyecto requiere operaciones de geometría plana en lugar del motor de operaciones de geometría esférica (por ejemplo, para crear buffers con bordes suaves), puede merecer la pena transformar los datos con un CRS geográfico en un objeto equivalente con un CRS proyectado, como la British National Grid (EPSG:27700).\n\n## ¿Qué CRS utilizar?\n\nLa cuestión de *qué CRS* es delicada, y rara vez hay una respuesta \"correcta\":\n\"No existen proyecciones que sirvan para todo, todas implican distorsión cuando se alejan del centro del marco especificado\".\n\nA la hora de seleccionar **CRS geográficos**, la respuesta suele ser [WGS84](https://en.wikipedia.org/wiki/World_Geodetic_System#A_new_World_Geodetic_System:_WGS_84).\nSe utiliza no sólo para la cartografía web, sino también porque los conjuntos de datos GPS y miles de conjuntos de datos ráster y vectoriales se proporcionan por defecto en este CRS.\nWGS84 es el CRS más común en el mundo, por lo que conviene conocer su código EPSG: 4326.\nEste \"número mágico\" puede utilizarse para convertir objetos con CRS proyectados inusuales en algo que se entienda ampliamente.\n\n¿Qué ocurre cuando se necesita un **CRS proyectado**?\nEn algunos casos, no es algo que podamos decidir libremente:\n\"a menudo, la elección de la proyección corre a cargo de un organismo cartográfico público\".\nEsto significa que, al trabajar con fuentes de datos locales, probablemente sea preferible trabajar con el CRS en el que se proporcionaron los datos, para garantizar la compatibilidad, aunque el CRS oficial no sea el más preciso.\n\nUna proyección utilizada habitualmente por defecto es la Universal Transverse Mercator ([UTM](https://en.wikipedia.org/wiki/Universal_Transverse_Mercator_coordinate_system)), un conjunto de CRS que divide la Tierra en 60 cuñas longitudinales y 20 segmentos latitudinales.\nLa proyección transversal de Mercator utilizada por los CRSs UTM es conforme pero distorsiona áreas y distancias con severidad creciente con la distancia desde el centro de la zona UTM.\nPor lo tanto, ¡recomendamos utilizar UTM sólo cuando su objetivo sea preservar los ángulos de un área relativamente pequeña!\n\nCasi todos los lugares de la Tierra tienen un código UTM, como \"60H\", que se refiere al norte de Nueva Zelanda, donde se inventó R.\nLos códigos EPSG de UTM van secuencialmente de 32601 a 32660 para los lugares del hemisferio norte y de 32701 a 32760 para los lugares del hemisferio sur.\n\n\n::: {.cell}\n\n:::\n\n\nPara mostrar cómo funciona el sistema, vamos a crear una función, `lonlat2UTM()` para calcular el código EPSG asociado a cualquier punto del planeta como [sigue](https://stackoverflow.com/a/9188972/): \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlonlat2UTM = function(lonlat) {\n  utm = (floor((lonlat[1] + 180) / 6) %% 60) + 1\n  if (lonlat[2] > 0) {\n    utm + 32600\n  } else{\n    utm + 32700\n  }\n}\n```\n:::\n\n\nEl siguiente comando utiliza esta función para identificar la zona UTM y el código EPSG asociado para Auckland y Londres:\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlonlat2UTM(c(174.7, -36.9))\nlonlat2UTM(st_coordinates(london))\n## [1] 32760\n## [1] 32630\n```\n:::\n\n\nActualmente, también disponemos de herramientas que nos ayudan a seleccionar un CRS adecuado, entre las que se incluye el paquete **crssuggest**.\nLa función principal de este paquete, `suggest_crs()`, toma un objeto espacial con CRS geográfico y devuelve una lista de posibles CRS proyectados que podrían utilizarse para el área dada.^[Este paquete también permite averiguar el verdadero CRS de los datos sin ninguna información CRS adjunta].\nOtra herramienta útil es una página web <https://jjimenezshaw.github.io/crs-explorer/> que enumera los CRS en función de la ubicación y el tipo seleccionados.\n\nEn los casos en los que no esté claro cuál es el CRS adecuado, la elección del CRS debe depender de las propiedades que sea más importante preservar en los mapas y análisis posteriores.\nTodos los CRS son de igual área, equidistantes, conformes (con formas que permanecen inalteradas), o alguna combinación de los mismos.\nPueden crearse CRS personalizados con parámetros locales para una región de interés y pueden utilizarse múltiples CRS en proyectos cuando ningún CRS se adapte a todas las tareas.\nLos \"cálculos geodésicos\" pueden proporcionar un recurso alternativo si no hay CRS adecuados.\nIndependientemente del CRS proyectado que se utilice, los resultados pueden no ser precisos para geometrías que abarquen cientos de kilómetros.\n\nA la hora de decidirse por un SRI personalizado, recomendamos lo siguiente:\n\n- Una proyección acimutal igual al área de Lambert ([LAEA](https://en.wikipedia.org/wiki/Lambert_azimuthal_equal-area_projection)) para una proyección local personalizada (establezca la latitud y la longitud del origen en el centro del área de estudio), que es una proyección igual al área en todas las ubicaciones pero distorsiona las formas más allá de miles de kilómetros.\n- Proyecciones acimutales equidistantes ([AEQD](https://en.wikipedia.org/wiki/Azimuthal_equidistant_projection)) para una distancia en línea recta específicamente precisa entre un punto y el punto central de la proyección local.\n- Proyecciones cónicas conformes de Lambert ([LCC](https://en.wikipedia.org/wiki/Lambert_conformal_conic_projection)) para regiones que abarcan miles de kilómetros, con el cono ajustado para mantener unas propiedades de distancia y área razonables entre las líneas secantes.\n- Proyecciones estereográficas ([STERE](https://en.wikipedia.org/wiki/Stereographic_projection)) para regiones polares, pero teniendo cuidado de no confiar en cálculos de área y distancia a miles de kilómetros del centro.\n\nUn posible enfoque para seleccionar automáticamente un CRS proyectado específico para un conjunto de datos local es crear una proyección equidistante azimutal ([AEQD](https://en.wikipedia.org/wiki/Azimuthal_equidistant_projection)) para el punto central del área de estudio.\nEsto implica crear un CRS personalizado (sin código EPSG) con unidades de metros basado en el punto central de un conjunto de datos.\nTenga en cuenta que este método debe utilizarse con precaución: ningún otro conjunto de datos será compatible con el CRS personalizado creado y es posible que los resultados no sean precisos cuando se utilicen en conjuntos de datos extensos que abarquen cientos de kilómetros.\n\nLos principios descritos en esta sección se aplican tanto a los conjuntos de datos vectoriales como a los ráster.\nSin embargo, algunas características de la transformación CRS son exclusivas de cada modelo de datos geográficos.\n\n## Reproyección de geometrías vectoriales\n\nLa reproyección de vectores consiste en transformar las coordenadas de los puntos que forman los vértices de las rectas y los polígonos.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlondon2 = st_transform(london_geo, \"EPSG:27700\")\n```\n:::\n\n\nAhora que se ha creado una versión transformada de `london`, utilizando la función **sf** `st_transform()`, se puede encontrar la distancia entre las dos representaciones de Londres.\nPuede sorprender que `londres` y `londres2` estén a poco más de 2 km de distancia.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_distance(london2, london_proj)\n## Units: [m]\n##         [,1]\n## [1,] 2017.95\n```\n:::\n\n\nLas funciones para consultar y reproyectar CRS se muestran a continuación con referencia a `cycle_hire_osm`, un objeto `sf` de **spData** que representa \"estaciones de carga\" donde se pueden alquilar bicicletas en Londres.\nLos CRS de los objetos `sf` pueden consultarse y establecerse con la función `st_crs()`.\nLa salida se imprime como múltiples líneas de texto que contienen información sobre el sistema de coordenadas:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(cycle_hire_osm)\n## Coordinate Reference System:\n##   User input: EPSG:4326 \n##   wkt:\n## GEOGCS[\"WGS 84\",\n##     DATUM[\"WGS_1984\",\n##         SPHEROID[\"WGS 84\",6378137,298.257223563,\n##             AUTHORITY[\"EPSG\",\"7030\"]],\n##         AUTHORITY[\"EPSG\",\"6326\"]],\n##     PRIMEM[\"Greenwich\",0,\n##         AUTHORITY[\"EPSG\",\"8901\"]],\n##     UNIT[\"degree\",0.0174532925199433,\n##         AUTHORITY[\"EPSG\",\"9122\"]],\n##     AUTHORITY[\"EPSG\",\"4326\"]]\n```\n:::\n\n\nLos componentes principales del CRS, `User input` y `wkt`, se imprimen como una sola entidad, la salida de `st_crs()` es de hecho una lista con nombre de la clase `crs` con dos elementos, cadenas de caracteres simples llamadas `input` y `wkt`, como se muestra en la salida del siguiente trozo de código:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrs_lnd = st_crs(london_geo)\nclass(crs_lnd)\nnames(crs_lnd)\n## [1] \"crs\"\n## [1] \"input\" \"wkt\"\n```\n:::\n\n\nSe pueden recuperar elementos adicionales con el operador `$`, incluyendo `Name`, `proj4string` y `epsg` (ver [`?st_crs`](https://r-spatial.github.io/sf/reference/st_crs.html) y el tutorial CRS y tranformación en el [sitio web](https://gdal.org/tutorials/osr_api_tut.html#querying-coordinate-reference-system) de GDAL para más detalles):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrs_lnd$Name\ncrs_lnd$proj4string\ncrs_lnd$epsg\n## [1] \"WGS 84\"\n## [1] \"+proj=longlat +datum=WGS84 +no_defs\"\n## [1] 4326\n```\n:::\n\n\nLa representación WKT almacenada en el elemento `$wkt` del objeto `crs_lnd` es la última fuente de verdad.\nEsto significa que las salidas del trozo de código anterior son consultas de la representación `wkt` proporcionada por PROJ, en lugar de atributos inherentes del objeto y su CRS.\n\nTanto los elementos `wkt` como `User Input` del CRS se modifican cuando se transforma el CRS del objeto.\nEn el siguiente fragmento de código, creamos una nueva versión de `cycle_hire_osm` con un CRS proyectado (sólo se muestran las 4 primeras líneas de la salida CRS por brevedad):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncycle_hire_osm_projected = st_transform(cycle_hire_osm, \"EPSG:27700\")\nst_crs(cycle_hire_osm_projected)\n#> Coordinate Reference System:\n#>   User input: EPSG:27700 \n#>   wkt:\n#> PROJCRS[\"OSGB36 / British National Grid\",\n#> ...\n```\n:::\n\n\nEl objeto resultante tiene un nuevo CRS con un código EPSG 27700.\nPero, ¿cómo averiguar más detalles sobre este código EPSG, o sobre cualquier código?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrs_lnd_new = st_crs(\"EPSG:27700\")\ncrs_lnd_new$Name\ncrs_lnd_new$proj4string\ncrs_lnd_new$epsg\n## [1] \"OSGB36 / British National Grid\"\n## [1] \"+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +units=m +no_defs\"\n## [1] 27700\n```\n:::\n\n\n:::{.callout-note}\nLa impresión de un objeto espacial en la consola devuelve automáticamente su sistema de referencia de coordenadas.\nPara acceder a él y modificarlo explícitamente, utilice la función `st_crs`, por ejemplo, `st_crs(ciclo_hire_osm)`.\n:::\n\n## Reproyección de geometrías raster {#reproj-ras}\n\nExisten diferencias importantes en la reproyección de vectores y rásters:\ntransformar un objeto vectorial implica cambiar las coordenadas de cada vértice, pero esto no se aplica a los datos raster.\nLos rásters se componen de celdas rectangulares del mismo tamaño (expresadas en unidades cartográficas, como grados o metros), por lo que suele ser impracticable transformar las coordenadas de los píxeles por separado.\nLa reproyección de rásters implica la creación de un nuevo objeto ráster, a menudo con un número de columnas y filas distinto del original.\nA continuación, hay que volver a estimar los atributos, lo que permite \"rellenar\" los nuevos píxeles con los valores adecuados.\nEn otras palabras, la reproyección ráster puede considerarse como dos operaciones espaciales separadas: una reproyección vectorial de la extensión ráster a otro CRS y el cálculo de nuevos valores de píxel mediante remuestreo.\nPor lo tanto, en la mayoría de los casos en que se utilizan datos ráster y vectoriales, es mejor evitar la reproyección de rásteres y reproyectar vectores en su lugar.\n\n:::{.callout-note}\nLa reproyección de los rásters regulares también se conoce como \"warping\". \nAdemás, existe una segunda operación similar denominada \"transformación\".\nEn lugar de remuestrear todos los valores, deja todos los valores intactos pero vuelve a calcular nuevas coordenadas para cada celda del raster, cambiando la geometría de la cuadrícula.\nPor ejemplo, podría convertir el ráster de entrada (una malla regular) en una malla curvilínea.\nLa operación de transformación puede realizarse en R utilizando [el paquete **stars**](https://r-spatial.github.io/stars/articles/stars5.html).\n:::\n\n\n\n\n\nEl proceso de reproyección raster se realiza con `project()` del paquete **terra**.\n`project()` toma un objeto geográfico (un conjunto de datos raster en este caso) y alguna representación CRS como segundo argumento.\nNota al margen: el segundo argumento también puede ser un objeto ráster existente con un CRS diferente.\n\nVeamos dos ejemplos de transformación ráster: el uso de datos categóricos y continuos.\nLos datos de cobertura del suelo suelen representarse mediante mapas categóricos.\nEl archivo `nlcd.tif` proporciona información para una pequeña área en Utah, EE.UU. obtenida de [National Land Cover Database 2011](https://www.mrlc.gov/data/nlcd-2011-land-cover-conus) en el CRS NAD83 / UTM zona 12N, como se muestra en la salida del fragmento de código a continuación:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat_raster = rast(system.file(\"raster/nlcd.tif\", package = \"spDataLarge\"))\ncrs(cat_raster)\n#> PROJCRS[\"NAD83 / UTM zone 12N\",\n#> ...\n```\n:::\n\n\nEn esta región se distinguieron 8 clases de ocupación del suelo (la lista completa de las clases de ocupación del suelo de la NLCD2011 puede consultarse en [mrlc.gov](https://www.mrlc.gov/data/legends/national-land-cover-database-2011-nlcd2011-legend)):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunique(cat_raster)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|levels     |\n|:----------|\n|Water      |\n|Developed  |\n|Barren     |\n|Forest     |\n|Shrubland  |\n|Herbaceous |\n|Cultivated |\n|Wetlands   |\n\n</div>\n:::\n:::\n\n\nAl reproyectar rásters categóricos, los valores estimados deben ser los mismos que los del original.\nPara ello se puede utilizar el método del vecino más cercano (`near`), que establece el valor de cada nueva celda en el valor de la celda más cercana (centro) del ráster de entrada.\nUn ejemplo es la reproyección de `cat_raster` a WGS84, un CRS geográfico muy adecuado para la cartografía web.\nEl primer paso es obtener la definición PROJ de este CRS, lo que puede hacerse, por ejemplo, utilizando la página web [http://spatialreference.org](http://spatialreference.org/ref/epsg/wgs-84/). \nEl último paso es reproyectar el ráster con la función `project()` que, en el caso de datos categóricos, utiliza el método del vecino más cercano (`near`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat_raster_wgs84 = project(cat_raster, \"EPSG:4326\", method = \"near\")\n```\n:::\n\n\nMuchas propiedades del nuevo objeto difieren del anterior, incluido el número de columnas y filas (y, por tanto, el número de celdas), la resolución (transformada de metros a grados) y la extensión.\n\n\n::: {.cell}\n::: {.cell-output-display}\nTable: Key attributes in the original ('cat\\_raster') and projected ('cat\\_raster\\_wgs84') categorical raster datasets.\n\n|CRS   | nrow| ncol|   ncell| resolution| unique_categories|\n|:-----|----:|----:|-------:|----------:|-----------------:|\n|NAD83 | 1359| 1073| 1458207|    31.5275|                 8|\n|WGS84 | 1246| 1244| 1550024|     0.0003|                 9|\n:::\n:::\n\n\nLa reproyección de rásters numéricos (con valores `numéricos` o en este caso `enteros`) sigue un procedimiento casi idéntico.\nEsto se demuestra a continuación con `srtm.tif` de [the Shuttle Radar Topography Mission (SRTM)](https://www2.jpl.nasa.gov/srtm/), que representa la altura en metros sobre el nivel del mar (elevación) con el WGS84 CRS:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncon_raster = rast(system.file(\"raster/srtm.tif\", package = \"spDataLarge\"))\ncrs(con_raster)\n## [1] \"GEOGCRS[\\\"WGS 84\\\",\\n    ENSEMBLE[\\\"World Geodetic System 1984 ensemble\\\",\\n        MEMBER[\\\"World Geodetic System 1984 (Transit)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G730)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G873)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G1150)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G1674)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G1762)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G2139)\\\"],\\n        ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n        ENSEMBLEACCURACY[2.0]],\\n    PRIMEM[\\\"Greenwich\\\",0,\\n        ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    CS[ellipsoidal,2],\\n        AXIS[\\\"geodetic latitude (Lat)\\\",north,\\n            ORDER[1],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        AXIS[\\\"geodetic longitude (Lon)\\\",east,\\n            ORDER[2],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    USAGE[\\n        SCOPE[\\\"Horizontal component of 3D system.\\\"],\\n        AREA[\\\"World.\\\"],\\n        BBOX[-90,-180,90,180]],\\n    ID[\\\"EPSG\\\",4326]]\"\n```\n:::\n\n\nReproyectaremos este conjunto de datos en un CRS proyectado, pero *no* con el método del vecino más próximo, que es apropiado para datos categóricos.\nEn su lugar, utilizaremos el método bilineal, que calcula el valor de la celda de salida basándose en las cuatro celdas más cercanas de la trama original.\nLos valores del conjunto de datos proyectado son la media ponderada por distancia de los valores de estas cuatro celdas:\ncuanto más cerca esté la celda de entrada del centro de la celda de salida, mayor será su peso.\nLos siguientes comandos crean una cadena de texto que representa WGS 84 / UTM zona 12N, y reproyectan el ráster en este CRS, utilizando el método `bilineal`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncon_raster_ea = project(con_raster, \"EPSG:32612\", method = \"bilinear\")\ncrs(con_raster_ea)\n## [1] \"PROJCRS[\\\"WGS 84 / UTM zone 12N\\\",\\n    BASEGEOGCRS[\\\"WGS 84\\\",\\n        ENSEMBLE[\\\"World Geodetic System 1984 ensemble\\\",\\n            MEMBER[\\\"World Geodetic System 1984 (Transit)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G730)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G873)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G1150)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G1674)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G1762)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G2139)\\\"],\\n            ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n                LENGTHUNIT[\\\"metre\\\",1]],\\n            ENSEMBLEACCURACY[2.0]],\\n        PRIMEM[\\\"Greenwich\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        ID[\\\"EPSG\\\",4326]],\\n    CONVERSION[\\\"UTM zone 12N\\\",\\n        METHOD[\\\"Transverse Mercator\\\",\\n            ID[\\\"EPSG\\\",9807]],\\n        PARAMETER[\\\"Latitude of natural origin\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8801]],\\n        PARAMETER[\\\"Longitude of natural origin\\\",-111,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8802]],\\n        PARAMETER[\\\"Scale factor at natural origin\\\",0.9996,\\n            SCALEUNIT[\\\"unity\\\",1],\\n            ID[\\\"EPSG\\\",8805]],\\n        PARAMETER[\\\"False easting\\\",500000,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8806]],\\n        PARAMETER[\\\"False northing\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8807]]],\\n    CS[Cartesian,2],\\n        AXIS[\\\"(E)\\\",east,\\n            ORDER[1],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n        AXIS[\\\"(N)\\\",north,\\n            ORDER[2],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n    USAGE[\\n        SCOPE[\\\"Navigation and medium accuracy spatial referencing.\\\"],\\n        AREA[\\\"Between 114°W and 108°W, northern hemisphere between equator and 84°N, onshore and offshore. Canada - Alberta; Northwest Territories (NWT); Nunavut; Saskatchewan. Mexico. United States (USA).\\\"],\\n        BBOX[0,-114,84,-108]],\\n    ID[\\\"EPSG\\\",32612]]\"\n```\n:::\n\n\nLa reproyección raster sobre variables numéricas también provoca pequeños cambios en los valores y propiedades espaciales, como el número de celdas, la resolución y la extensión.\nEstos cambios se muestran en la Tabla \\@ref(tab:rastercrs)^[\nOtro cambio menor es que la clase de los valores en el nuevo conjunto de datos ráster proyectado es `numérico`.\nEsto se debe a que el método `bilineal` trabaja con datos continuos y los resultados raramente se convierten en valores enteros.\nEsto puede tener implicaciones en el tamaño de los archivos cuando se guardan los conjuntos de datos ráster.\n]:\n\n\n::: {.cell}\n::: {.cell-output-display}\nTable: Key attributes in the original ('con\\_raster') and projected ('con\\_raster\\_ea') continuous raster datasets.\n\n|CRS          | nrow| ncol|  ncell| resolution|     mean|\n|:------------|----:|----:|------:|----------:|--------:|\n|WGS84        |  457|  465| 212505|     0.0008| 1842.548|\n|UTM zone 12N |  515|  422| 217330|    83.5334| 1842.083|\n:::\n:::\n\n\n:::{.callout-note}\nPor supuesto, las limitaciones de las proyecciones de la Tierra en 2D se aplican tanto a los datos vectoriales como a los ráster.\nEn el mejor de los casos, podemos cumplir dos de las tres propiedades espaciales (distancia, área, dirección).\nPor lo tanto, la tarea a realizar determina qué proyección elegir. \nPor ejemplo, si estamos interesados en una densidad (puntos por celda de cuadrícula o habitantes por celda de cuadrícula) deberíamos utilizar una proyección de igual área.\n:::\n",
    "supporting": [
      "reproyeccion_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}