{
  "hash": "47b37702bc8c7f9e448f3258cbae680b",
  "result": {
    "markdown": "---\ntitle: \"Operaciones con atributos\"\nauthor: \"Modificado de <https://r.geocompx.org/>\"\nformat: \n  html:\n    toc: true\n    df-print: kable\n---\n\n::: {.cell}\n\n:::\n\n\nLos atributos son la información no espacial asociada a la información geográfica o geometría.\n\n## Vectores\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmethods(class = \"sf\") # methods for sf objects\n##   [1] [                            [[<-                        \n##   [3] $<-                          aggregate                   \n##   [5] anti_join                    arrange                     \n##   [7] as.data.frame                cbind                       \n##   [9] coerce                       crs                         \n##  [11] dbDataType                   dbWriteTable                \n##  [13] distance                     distinct                    \n##  [15] dplyr_reconstruct            duplicated                  \n##  [17] ext                          extract                     \n##  [19] filter                       full_join                   \n##  [21] group_by                     group_split                 \n##  [23] identify                     initialize                  \n##  [25] inner_join                   left_join                   \n##  [27] lines                        mask                        \n##  [29] merge                        mutate                      \n##  [31] plot                         points                      \n##  [33] polys                        print                       \n##  [35] rasterize                    rbind                       \n##  [37] rename_with                  rename                      \n##  [39] right_join                   rowwise                     \n##  [41] sample_frac                  sample_n                    \n##  [43] select                       semi_join                   \n##  [45] show                         slice                       \n##  [47] slotsFromS3                  st_agr                      \n##  [49] st_agr<-                     st_area                     \n##  [51] st_as_s2                     st_as_sf                    \n##  [53] st_as_sfc                    st_bbox                     \n##  [55] st_boundary                  st_break_antimeridian       \n##  [57] st_buffer                    st_cast                     \n##  [59] st_centroid                  st_collection_extract       \n##  [61] st_concave_hull              st_convex_hull              \n##  [63] st_coordinates               st_crop                     \n##  [65] st_crs                       st_crs<-                    \n##  [67] st_difference                st_drop_geometry            \n##  [69] st_filter                    st_geometry                 \n##  [71] st_geometry<-                st_inscribed_circle         \n##  [73] st_interpolate_aw            st_intersection             \n##  [75] st_intersects                st_is_valid                 \n##  [77] st_is                        st_join                     \n##  [79] st_line_merge                st_m_range                  \n##  [81] st_make_valid                st_minimum_rotated_rectangle\n##  [83] st_nearest_points            st_node                     \n##  [85] st_normalize                 st_point_on_surface         \n##  [87] st_polygonize                st_precision                \n##  [89] st_reverse                   st_sample                   \n##  [91] st_segmentize                st_set_precision            \n##  [93] st_shift_longitude           st_simplify                 \n##  [95] st_snap                      st_sym_difference           \n##  [97] st_transform                 st_triangulate_constrained  \n##  [99] st_triangulate               st_union                    \n## [101] st_voronoi                   st_wrap_dateline            \n## [103] st_write                     st_z_range                  \n## [105] st_zm                        summarise                   \n## [107] svc                          tmapGetShapeMeta1           \n## [109] tmapGetShapeMeta2            tmapShape                   \n## [111] tmapSubsetShp                transform                   \n## [113] transmute                    ungroup                     \n## [115] vect                        \n## see '?methods' for accessing help and source code\n```\n:::\n\n\nCon los objetos sf también se pueden utilizar los métodos de tidyverse para data.frame, tbl_df y tbl. De este modo, sf permite explotar las capacidades de análisis de datos de R en los datos geográficos, tanto si se utilizan las funciones básicas de R como las de tidyverse para el análisis de datos.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(world) \ndim(world)\n## [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n## [1] 177  11\n```\n:::\n\n\nLa función `st_drop_geometry()` conserva únicamente los atributos de un objeto sf, es decir, elimina su geometría.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld_df = st_drop_geometry(world)\nclass(world_df)\nncol(world_df)\n## [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n## [1] 10\n```\n:::\n\n\nPara muchas aplicaciones, el paquete tidyverse `dplyr` ofrece un enfoque eficaz para trabajar con los data frames. La compatibilidad con tidyverse es una ventaja de sf.\n\n### Subdivisión de vectores vía sus atributos\n\nLos métodos de subdivisión básicos de R incluyen el operador `[` y la función `subset()`, mientras que en el paquete dplyr, éstas son son `filter()` y `slice()` para filas, y `select()` para columnas. Ambos métodos conservan los componentes espaciales de los datos en los objetos sf, mientras que si se utiliza el operador `$` o la función dplyr `pull()` para devolver una única columna de atributos como vector, se perderán los datos geométricos.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld[1:6, ]    # subset rows by position\nworld[, 1:3]    # subset columns by position\nworld[1:6, 1:3] # subset rows and columns by position\nworld[, c(\"name_long\", \"pop\")] # columns by name\nworld[, c(T, T, F, F, F, F, F, T, T, F, F)] # by logical indices\nworld[, 888] # an index representing a non-existent column\n```\n:::\n\n\nPodemos usar vectores lógicos para seleccionar subconjuntos de datos:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni_small = world$area_km2 < 10000\nsummary(i_small) # a logical vector\nsmall_countries = world[i_small, ]\n##    Mode   FALSE    TRUE \n## logical     170       7\n```\n:::\n\n\no más sencillamente:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsmall_countries = world[world$area_km2 < 10000, ]\n```\n:::\n\n\nLa función `subset()` nos permite realizar la misma operación:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsmall_countries = subset(world, area_km2 < 10000)\n```\n:::\n\n\nLas funciones de R base son maduras, estables y ampliamente utilizadas, lo que las convierte en una opción sólida, especialmente en contextos en los que la reproducibilidad y la fiabilidad son fundamentales. Las funciones de dplyr por su parte permiten flujos de trabajo \"ordenados\" o tidy que algunas personas consideran intuitivos y productivos para el análisis interactivo de datos.\nA continuación se muestran las funciones clave para hacer subset de data.frames con funciones dplyr.\n\n- `select()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld1 = select(world, name_long, pop)\nnames(world1)\n## [1] \"name_long\" \"pop\"       \"geom\"\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# all columns between name_long and pop (inclusive)\nworld2 = select(world, name_long:pop)\n```\n:::\n\n\n- `-` operator\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# all columns except subregion and area_km2 (inclusive)\nworld3 = select(world, -subregion, -area_km2)\n```\n:::\n\n\n- `select()`: subset and rename\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld4 = select(world, name_long, population = pop)\n```\n:::\n\n\nselect() también funciona con \"funciones de ayuda\" para operaciones de subset más avanzadas, como `contains()`, `starts_with()` y `num_range()`.\n\nLa mayoría de los verbos dplyr devuelven un data.frame, pero también se puede extraer una sola columna como un vector con `pull()`. Se puede obtener el mismo resultado en R base con los operadores `$` y `[[`, los tres comandos siguientes devuelven el mismo vector numérico:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npull(world, pop)\nworld$pop\nworld[[\"pop\"]]\n```\n:::\n\n\n- `slice()` es el equivalente en filas de select(). El siguiente fragmento de código, por ejemplo, selecciona las filas 1 a 6:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nslice(world, 1:6)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|iso_a2 |name_long      |continent     |region_un |subregion        |type              |    area_km2|       pop|  lifeExp| gdpPercap|geom                           |\n|:------|:--------------|:-------------|:---------|:----------------|:-----------------|-----------:|---------:|--------:|---------:|:------------------------------|\n|FJ     |Fiji           |Oceania       |Oceania   |Melanesia        |Sovereign country |    19289.97|    885806| 69.96000|  8222.254|MULTIPOLYGON (((-180 -16.55... |\n|TZ     |Tanzania       |Africa        |Africa    |Eastern Africa   |Sovereign country |   932745.79|  52234869| 64.16300|  2402.099|MULTIPOLYGON (((33.90371 -0... |\n|EH     |Western Sahara |Africa        |Africa    |Northern Africa  |Indeterminate     |    96270.60|        NA|       NA|        NA|MULTIPOLYGON (((-8.66559 27... |\n|CA     |Canada         |North America |Americas  |Northern America |Sovereign country | 10036042.98|  35535348| 81.95305| 43079.143|MULTIPOLYGON (((-132.71 54.... |\n|US     |United States  |North America |Americas  |Northern America |Country           |  9510743.74| 318622525| 78.84146| 51921.985|MULTIPOLYGON (((-171.7317 6... |\n|KZ     |Kazakhstan     |Asia          |Asia      |Central Asia     |Sovereign country |  2729810.51|  17288285| 71.62000| 23587.338|MULTIPOLYGON (((87.35997 49... |\n\n</div>\n:::\n:::\n\n\n- `filter()` es el equivalente de dplyr a la función subset() de R base. Mantiene sólo las filas que coinciden con los criterios dados, por ejemplo, sólo los países con un área por debajo de un cierto umbral, o con un alto promedio de esperanza de vida:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld7 = filter(world, area_km2 < 10000)  # countries with a small area\nworld7 = filter(world, lifeExp > 82)      # with high life expectancy\n```\n:::\n\n\nLa clave de los flujos de trabajo que utilizan funciones **dplyr** es el operador ['pipe'](http://r4ds.had.co.nz/pipes.html) `%>%` (o desde R `4.1.0` la tubería nativa `|>`), que toma su nombre del pipe de Unix `|`.\nLos pipes permiten un código expresivo: la salida de una función se convierte en el primer argumento de la siguiente función, permitiendo el *encadenamiento*.\nEsto se ilustra a continuación donde sólo se filtran los países de Asia del conjunto de datos `world`, a continuación el objeto se subdivide por columnas (`nombre_largo` y `continente`) y se extraen las cinco primeras filas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld7 = world |>\n  filter(continent == \"Asia\") |>\n  select(name_long, continent) |>\n  slice(1:5)\n```\n:::\n\n\nLo de arriba puede también expresarse como funciones anidadas, aunque es más \ndifícil de leer:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld8 = slice(\n  select(\n    filter(world, continent == \"Asia\"),\n    name_long, continent),\n  1:5)\n```\n:::\n\n\n### Agregación de atributos vectoriales\n\nLa agregación consiste en resumir los datos con una o varias \"variables de agrupación\", normalmente a partir de columnas de la tabla de datos que se desea agregar.\nUn ejemplo de agregación de atributos es calcular el número de personas por continente a partir de datos a nivel de país (una fila por país).\nEl conjunto de datos `world` contiene los ingredientes necesarios: las columnas `pop` y `continent`, la población y la variable de agrupación, respectivamente.\nEl objetivo es hallar la `sum()` de las poblaciones de los países para cada continente, lo que da como resultado un data.frame más pequeño.\nEsto se puede hacer con la función base de R `aggregate()` de la siguiente manera:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld_agg1 = aggregate(pop ~ continent, FUN = sum, data = world, na.rm = TRUE)\nclass(world_agg1)\nhead(world_agg1)\n## [1] \"data.frame\"\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|continent     |        pop|\n|:-------------|----------:|\n|Africa        | 1154946633|\n|Asia          | 4311408059|\n|Europe        |  669036256|\n|North America |  565028684|\n|Oceania       |   37757833|\n|South America |  412060811|\n\n</div>\n:::\n:::\n\n\n`aggregate()` es una [función genérica](https://adv-r.hadley.nz/s3.html#s3-methods) lo que significa que se comporta de forma diferente dependiendo de sus entradas. \n**sf** proporciona el método `aggregate.sf()` que se activa automáticamente cuando `x` es un objeto `sf` y se proporciona un argumento `by`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld_agg2 = aggregate(world[\"pop\"], list(world$continent), \n                       FUN = sum, \n                       na.rm = TRUE)\nclass(world_agg2)\nnrow(world_agg2)\n## [1] \"sf\"         \"data.frame\"\n## [1] 8\n```\n:::\n\n\nEl objeto resultante `world_agg2` es un objeto espacial que contiene 8 características que representan los continentes del mundo.\n\nLa función `group_by() |> summarize()` es el equivalente **dplyr** de `aggregate()`, con el nombre de la variable proporcionada en la función `group_by()` especificando la variable de agrupación y la información sobre lo que se va a resumir pasada a la función `summarize()`, como se muestra a continuación:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld_agg3 = world |>\n  group_by(continent) |>\n  summarize(pop = sum(pop, na.rm = TRUE))\n```\n:::\n\n\nEste enfoque puede parecer más complejo, pero tiene ventajas: flexibilidad, legibilidad y control sobre los nuevos nombres de las columnas.\nEsta flexibilidad se ilustra en el comando siguiente, que calcula no sólo la población, sino también la superficie y el número de países de cada continente:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld_agg4  = world |> \n  group_by(continent) |> \n  summarize(Pop = sum(pop, na.rm = TRUE), Area = sum(area_km2), N = n())\n```\n:::\n\n\nEn el trozo de código anterior `Pop`, `Area` y `N` son nombres de columnas en el resultado, y `sum()` y `n()` las funciones de agregación.\nEstas funciones de agregación devuelven objetos `sf` con filas que representan continentes y geometrías que contienen los múltiples polígonos que representan cada masa de tierra y las islas asociadas (esto funciona gracias a la operación geométrica `union`, como se explica más abajo.\n\nCombinemos lo que hemos aprendido hasta ahora sobre las funciones **dplyr**, encadenando múltiples comandos para resumir datos de atributos sobre países de todo el mundo por continentes.\nEl siguiente comando calcula la densidad de población (con `mutate()`), ordena los continentes por el número de países que contienen (con `dplyr::arrange()`), y mantiene sólo los 3 continentes más poblados (con `dplyr::slice_max()`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld_agg5 = world |> \n  st_drop_geometry() |>                      # drop the geometry for speed\n  select(pop, continent, area_km2) |> # subset the columns of interest  \n  group_by(continent) |>                     # group by continent and summarize:\n  summarize(Pop = sum(pop, na.rm = TRUE), Area = sum(area_km2), N = n()) |>\n  mutate(Density = round(Pop / Area)) |>     # calculate population density\n  slice_max(Pop, n = 3) |>                   # keep only the top 3\n  arrange(desc(N))                           # arrange in order of n. countries\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(scipen = 999)\nknitr::kable(\n  world_agg5,\n  caption = \"The top 3 most populous continents ordered by number of countries.\",\n  caption.short = \"Top 3 most populous continents.\",\n  booktabs = TRUE\n)\n```\n\n::: {.cell-output-display}\nTable: The top 3 most populous continents ordered by number of countries.\n\n|continent |        Pop|     Area|  N| Density|\n|:---------|----------:|--------:|--:|-------:|\n|Africa    | 1154946633| 29946198| 51|      39|\n|Asia      | 4311408059| 31252459| 47|     138|\n|Europe    |  669036256| 23065219| 39|      29|\n:::\n:::\n\n\n### Unión de atributos vectoriales\n\nCombinar datos de distintas fuentes es una tarea habitual en la preparación de datos. \nLas uniones lo hacen combinando tablas basadas en una variable \"clave\" o key compartida.\n**dplyr** tiene múltiples funciones de unión, incluyendo `left_join()` y `inner_join()` --- ver `vignette(\"two-table\")` para una lista completa.\nLos nombres de estas funciones siguen las convenciones utilizadas en el lenguaje de bases de datos [SQL](http://r4ds.had.co.nz/relational-data.html); su uso para unir conjuntos de datos no espaciales a objetos `sf` es el objetivo de esta sección.\nLas funciones join de **dplyr** funcionan igual en data.frames y objetos `sf`, la única diferencia importante es la columna `geometry`.\nEl resultado de las uniones de datos puede ser un objeto `sf` o un `data.frame`.\nEl tipo más común de unión de atributos en datos espaciales toma un objeto `sf` como primer argumento y le añade columnas de un `data.frame` especificado como segundo argumento.\n\nPara demostrar las uniones, combinaremos datos sobre la producción de café con el conjunto de datos `world`.\nLos datos sobre el café se encuentran en un data.frame denominado `coffee_data` del paquete **spData**.\nTiene 3 columnas:\n`name_long` nombra las principales naciones productoras de café y `coffee_production_2016` y `coffee_production_2017` contienen valores estimados para la producción de café en bolsas de 60 kg \nen cada año.\nUn \"left join\", que conserva el primer conjunto de datos, combina \"world\" con \"coffee_data\":\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld_coffee = left_join(world, coffee_data)\nclass(world_coffee)\n## [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n:::\n\n\nDado que los conjuntos de datos de entrada comparten una \"key\" (`name_long`), la unión funcionó sin utilizar el argumento `by` (véase `?left_join` para más detalles).\nEl resultado es un objeto `sf` idéntico al objeto `world` original, pero con dos nuevas variables (con índices de columna 11 y 12) sobre la producción de café.\nEsto puede representarse como un mapa, tal y como se ilustra en la Figura \\ref(fig:coffeemap), generada con la función `plot()` que se muestra a continuación:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(world_coffee)\nplot(world_coffee[\"coffee_production_2017\"])\n```\n\n::: {.cell-output-display}\n![World coffee production (thousand 60-kg bags) by country, 2017. Source: International Coffee Organization.](operaciones_con_atributos_files/figure-html/coffeemap-1.png){fig-scap='World coffee production by country.' width=672}\n:::\n\n```\n##  [1] \"iso_a2\"                 \"name_long\"              \"continent\"             \n##  [4] \"region_un\"              \"subregion\"              \"type\"                  \n##  [7] \"area_km2\"               \"pop\"                    \"lifeExp\"               \n## [10] \"gdpPercap\"              \"geom\"                   \"coffee_production_2016\"\n## [13] \"coffee_production_2017\"\n```\n:::\n\n\nPara que la unión funcione, se debe proporcionar una columna \"key\" en ambos conjuntos de datos.\nPor defecto, **dplyr** utiliza todas las variables con nombres coincidentes.\nEn este caso, los objetos `world_coffee` y `world` contienen una variable llamada `name_long`, lo que explica el mensaje `Joining with `by = join_by(name_long)``.\nEn la mayoría de los casos en los que los nombres de las variables no coinciden, hay dos opciones:\n\n1. Cambiar el nombre de la variable clave en uno de los objetos para que coincidan.\n2. Utilizar el argumento `by` para especificar las variables de unión.\n\nEste último enfoque se demuestra a continuación en una versión renombrada de `coffee_data`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoffee_renamed = rename(coffee_data, nm = name_long)\nworld_coffee2 = left_join(world, coffee_renamed, by = join_by(name_long == nm))\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nObserve que se mantiene el nombre en el objeto original, lo que significa que `world_coffee` y el nuevo objeto `world_coffee2` son idénticos.\nOtra característica del resultado es que tiene el mismo número de filas que el conjunto de datos original.\nAunque sólo hay 47 filas de datos en `coffee_data`, los 177 registros de países se mantienen intactos en `world_coffee` y `world_coffee2`:\nA las filas del conjunto de datos original que no coinciden se les asignan valores `NA` para las nuevas variables de producción de café.\n¿Qué ocurre si sólo queremos conservar los países que tienen una coincidencia en la variable key?\n\nEn ese caso, se puede utilizar una unión interna:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld_coffee_inner = inner_join(world, coffee_data)\nnrow(world_coffee_inner)\n## [1] 45\n```\n:::\n\n\nObserve que el resultado de `inner_join()` sólo tiene 45 filas frente a las 47 de `coffee_data`.\n¿Qué ha pasado con las filas restantes?\nPodemos identificar las filas que no coinciden utilizando la función `setdiff()` de la siguiente manera:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetdiff(coffee_data$name_long, world$name_long)\n## [1] \"Congo, Dem. Rep. of\" \"Others\"\n```\n:::\n\n\nEl resultado muestra que `Otros` representa una fila que no está presente en el conjunto de datos `world` y que el nombre de la `Democratic Republic of the Congo` representa la otra: se ha abreviado, lo que hace que la unión no lo encuentre.\nEl siguiente comando utiliza una función de concordancia de cadenas (*regex*) del paquete **stringr** para confirmar cuál debería ser `Congo, Rep. Dem. of` debería ser:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrc = stringr::str_subset(world$name_long, \"Dem*.+Congo\")\ndrc\n## [1] \"Democratic Republic of the Congo\"\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# aim: test names in coffee_data and world objects\nstringr::str_subset(coffee_data$name_long, \"Ivo|Congo,\")\n.Last.value %in% stringr::str_subset(world$name_long, \"Ivo|Dem*.+Congo\")\n## [1] \"Congo, Dem. Rep. of\" \"Côte d'Ivoire\"      \n## logical(0)\n```\n:::\n\n\nPara solucionar este problema, crearemos una nueva versión de `coffee_data` y actualizaremos el nombre.\nSi unimos el data.frame actualizado con `inner_join()`, obtendremos un resultado con las 46 naciones productoras de café:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoffee_data$name_long[grepl(\"Congo,\", coffee_data$name_long)] = drc\nworld_coffee_match = inner_join(world, coffee_data)\nnrow(world_coffee_match)\n## [1] 46\n```\n:::\n\n\nTambién es posible unir en la otra dirección: empezar con un conjunto de datos no espaciales y añadir variables de un objeto sf.\nEsto se demuestra a continuación, se comienza con el objeto `coffee_data` y se añaden variables del conjunto de datos `world`.\nEn contraste con las uniones anteriores, el resultado *no* es un sf, sino un data.frame en forma de **tidyverse** tibble: el resultado de una unión tiende a coincidir con su primer argumento:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoffee_world = left_join(coffee_data, world)\nclass(coffee_world)\n## [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n:::\n\n\n:::{.callout-note}\nEn la mayoría de los casos, la columna de geometría sólo es útil en un objeto `sf`.\nLa columna de geometría sólo se puede utilizar para crear mapas y operaciones espaciales si R \"sabe\" que es un objeto espacial, definido por un paquete espacial como **sf**.\nAfortunadamente, los marcos de datos no espaciales con una columna de lista de geometría (como `coffee_world`) pueden coaccionarse en un objeto `sf` de la siguiente manera: `st_as_sf(coffee_world)`. \n:::\n\n### Creación de atributos y eliminación de información espacial\n\nA menudo, nos gustaría crear una nueva columna basada en columnas ya existentes.\nPor ejemplo, queremos calcular la densidad de población de cada país.\nPara ello necesitamos dividir una columna de población, aquí `pop`, por una columna de área, aquí `area_km2` con unidad de área en kilómetros cuadrados.\nUsando R base, podemos escribir:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld_new = world # do not overwrite our original data\nworld_new$pop_dens = world_new$pop / world_new$area_km2\n```\n:::\n\n\nAlternativamente, podemos utilizar una de las funciones de **dplyr** - `mutate()` o `transmute()`.\nLa función `mutate()` añade nuevas columnas en la penúltima posición del objeto `sf` (la última se reserva para la geometría):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld_new2 = world |> \n  mutate(pop_dens = pop / area_km2)\n```\n:::\n\n\nLa diferencia entre `mutate()` y `transmute()` es que esta última elimina todas las demás columnas existentes (excepto la columna de geometría).\n\nLa función `unite()` del paquete **tidyr** (que proporciona muchas funciones útiles para remodelar conjuntos de datos, incluida `pivot_longer()`) pega las columnas existentes.\nPor ejemplo, queremos combinar las columnas `continent` y `region_un` en una nueva columna llamada `con_reg`.\nAdemás, podemos definir un separador (aquí: dos puntos `:`) que define cómo deben unirse los valores de las columnas de entrada, y si deben eliminarse las columnas originales (aquí: `TRUE`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld_unite = world |>\n  tidyr::unite(\"con_reg\", continent:region_un, sep = \":\", remove = TRUE)\n```\n:::\n\n\nEl objeto `sf` resultante tiene una nueva columna llamada `con_reg` que representa el continente y la región de cada país, por ejemplo `South America:Americas` para Argentina y otros países de Sudamérica.\n\nLa función `separate()` de **tidyr** hace lo contrario que `unite()`: divide una columna en varias columnas utilizando una expresión regular o posiciones de caracteres.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld_separate = world_unite |>\n  tidyr::separate(con_reg, c(\"continent\", \"region_un\"), sep = \":\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nCada una de estas operaciones de datos de atributos conserva la geometría de las características simples.\nA veces tiene sentido eliminar la geometría, por ejemplo para acelerar la agregación.\nHágalo con `st_drop_geometry()`, **no** manualmente con comandos como `select(world, -geom)`, como se muestra a continuación.^[\n`st_geometry(world_st) = NULL` también funciona para eliminar la geometría de `world`, pero sobrescribe el objeto original.\n]\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld_data = world |> st_drop_geometry()\nclass(world_data)\n## [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n:::\n\n\n\n## Raster\n\nA diferencia del modelo de datos vectoriales subyacente a sf (que representa puntos, líneas y polígonos como entidades discretas en el espacio), los datos ráster representan superficies continuas.\nEsta sección muestra cómo funcionan los objetos ráster creándolos *desde cero* con el paquete terra.\nDebido a su estructura única, la subdivisión o subset y otras operaciones en conjuntos de datos ráster funcionan de una manera diferente.\n\nEl siguiente código recrea el conjunto de datos ráster utilizado en el apartado anterior. Esto demuestra cómo funciona la función `rast()` para crear un raster de ejemplo llamado `elev`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelev = rast(nrows = 6, ncols = 6,\n            xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n            vals = 1:36)\n```\n:::\n\n\nEl resultado es un objeto raster con 6 filas y 6 columnas (especificadas por los argumentos `nrow` y `ncol`), y una extensión espacial mínima y máxima en dirección x e y (`xmin`, `xmax`, `ymin`, `ymax`).\nEl argumento `vals` establece los valores que contiene cada celda.\n\nLos objetos raster también pueden contener valores categóricos de la clase `logical` o variables `factor`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrain_order = c(\"clay\", \"silt\", \"sand\")\ngrain_char = sample(grain_order, 36, replace = TRUE)\ngrain_fact = factor(grain_char, levels = grain_order)\ngrain = rast(nrows = 6, ncols = 6, \n             xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n             vals = grain_fact)\n```\n:::\n\n\n\n\nEl objeto ráster almacena la correspondiente tabla de consulta o \"Raster Attribute Table\" (RAT) como una lista de data.frames, que pueden visualizarse con `cats(grain)` (véase `?cats()` para más información).\nCada elemento de esta lista es una capa del raster.\nTambién es posible utilizar la función `levels()` para recuperar y añadir nuevos niveles de factor o sustituir los existentes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlevels(grain) = data.frame(value = c(0, 1, 2), wetness = c(\"wet\", \"moist\", \"dry\"))\nlevels(grain)\n## [[1]]\n##   value wetness\n## 1     0     wet\n## 2     1   moist\n## 3     2     dry\n```\n:::\n\n::: {.cell fig.asp='0.5'}\n::: {.cell-output-display}\n![Raster datasets with numeric (left) and categorical values (right).](operaciones_con_atributos_files/figure-html/cont-raster-1.png){fig-scap='Raster datasets with numeric and categorical values.' width=672}\n:::\n:::\n\n\n:::{.callout-note}\nLos objetos ráster categóricos también pueden almacenar información sobre los colores asociados a cada valor utilizando una tabla de colores.\nLa tabla de colores es un marco de datos con tres (rojo, verde, azul) o cuatro (alfa) columnas, donde cada fila se refiere a un valor.\nLas tablas de color en **terra** pueden verse o establecerse con la función `coltab()` (ver `?coltab`).\nEs importante destacar que, al guardar un objeto ráster con una tabla de colores en un archivo (por ejemplo, GeoTIFF), también se guardará la información de color.\n:::\n\n### Raster subsetting\n\nEl subconjunto raster se realiza con el operador base de R `[`, que acepta una variedad de entradas:\n\n- Indexación fila-columna\n- ID de celda\n- Coordenadas \n- Otro objeto espacial\n\nAquí sólo mostramos las dos primeras opciones, ya que pueden considerarse operaciones no espaciales. Si necesitamos un objeto espacial para subdividir otro o la salida es un objeto espacial, nos referiremos a esto como subset espacial. Por lo tanto, estas dos últimas opciones se mostrarán en el próximo capítulo.\n\nLas dos primeras opciones de subconjunto se muestran en los siguientes comandos ---\nambos devuelven el valor del píxel superior izquierdo en el objeto ráster `elev`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# row 1, column 1\nelev[1, 1]\n# cell ID 1\nelev[1]\n```\n:::\n\n\nSubdividir objetos ráster multicapa devolverá los valores de las celdas de cada capa.\nPor ejemplo, `two_layers = c(grain, elev); two_layers[1]` devuelve un marco de datos con una fila y dos columnas --- una para cada capa.\nPara extraer todos los valores o filas completas, también puede utilizar `values()`.\n\nLos valores de las celdas pueden modificarse sobrescribiendo los valores existentes junto con una operación de subconjunto. El siguiente fragmento de código, por ejemplo, establece la celda superior izquierda de `elev` a 0:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelev[1, 1] = 0\nelev[]\n```\n:::\n\n\nDejar los corchetes vacíos es una versión abreviada de `values()` para recuperar todos los valores de una capa. También se pueden modificar múltiples celdas de esta forma:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelev[1, c(1, 2)] = 0\n```\n:::\n\n\n\n### Resumen de objetos raster\n\n**terra** contiene funciones para extraer estadísticas descriptivas de rásters enteros.\nAl imprimir un objeto raster en la consola escribiendo su nombre, se obtienen los valores mínimo y máximo de un raster.\n\n`summary()` proporciona estadísticas descriptivas comunesindex{statistics} -- mínimo, máximo, cuartiles y número de `NA`s para rásters continuos y un número de celdas de cada clase para rásters categóricos.\n\nOtras operaciones de resumen, como la desviación estándar (véase más adelante) o estadísticas de resumen personalizadas, pueden calcularse con `global()`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nglobal(elev, sd)\n```\n:::\n\n\n:::{.callout-note}\nIf you provide the `summary()` and `global()` functions with a multi-layered raster object, they will summarize each layer separately, as can be illustrated by running: `summary(c(elev, grain))`.\n:::\n\nAdemás, la función `freq()` permite obtener la tabla de frecuencias de valores categóricos.\n\nLas estadísticas de valores raster pueden visualizarse de varias formas.\nFunciones específicas como `boxplot()`, `density()`, `hist()` y `pairs()` funcionan también con objetos raster, como se demuestra en el histograma creado con el comando siguiente (no mostrado):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(elev, breaks=2)\n```\n\n::: {.cell-output-display}\n![](operaciones_con_atributos_files/figure-html/unnamed-chunk-48-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "operaciones_con_atributos_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}