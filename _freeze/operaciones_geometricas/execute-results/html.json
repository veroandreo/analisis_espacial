{
  "hash": "fdc70d5a054f5423ff9c220f1edde2b9",
  "result": {
    "markdown": "---\ntitle: \"Operaciones geométricas\"\nauthor: \"Modificado de <https://r.geocompx.org/>\"\nformat: \n  html:\n    toc: true\n    df-print: kable\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(terra)\nlibrary(dplyr)\nlibrary(spData)\nlibrary(spDataLarge)\n```\n:::\n\n\n## Introducción\n\nHasta ahora, hemos visto la estructura de los conjuntos de datos geográficos, y cómo manipularlos basándose en sus atributos no geográficos y relaciones espaciales.\nEste capítulo se centra en la manipulación de los elementos geográficos de los objetos geográficos, por ejemplo simplificando y convirtiendo geometrías vectoriales, recortando conjuntos de datos ráster y convirtiendo objetos vectoriales en rásteres y rásteres en vectores.\n\n## Operaciones geométricas sobre datos vectoriales\n\nEsta sección trata de las operaciones que de alguna manera cambian la geometría de los objetos vectoriales (`sf`).\nEs más avanzada que las operaciones con datos espaciales presentadas anteriormente, porque aquí profundizamos en la geometría: las funciones discutidas en esta sección trabajan sobre objetos de clase `sfc` además de sobre objetos de clase `sf`.\n\n### Simplificación\n\nLa simplificación es un proceso de generalización de objetos vectoriales (líneas y polígonos) que suele utilizarse en mapas de menor escala.\nOtra razón para simplificar objetos es reducir la cantidad de memoria, espacio en disco y ancho de banda de red que consumen: puede ser conveniente simplificar geometrías complejas antes de publicarlas como mapas interactivos. \nEl paquete **sf** proporciona `st_simplify()`, que utiliza la implementación GEOS del algoritmo Douglas-Peucker para reducir el número de vértices.\n`st_simplify()` utiliza `dTolerance` para controlar el nivel de generalización en las unidades del mapa.\nLa figura de abajo ilustra la simplificación de una geometría `LINESTRING` que representa el río Sena y sus afluentes.\nLa geometría simplificada se creó mediante el siguiente comando:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseine_simp = st_simplify(seine, dTolerance = 2000)  # 2000 m\n```\n:::\n\n::: {.cell fig.asp='0.5'}\n::: {.cell-output-display}\n![Comparison of the original and simplified geometry of the seine object.](operaciones_geometricas_files/figure-html/seine-simp-1.png){fig-scap='Simplification in action.' width=672}\n:::\n:::\n\n\nEl objeto `seine_simp` resultante es una copia del `seine` original pero con menos vértices.\n\nLa simplificación también es aplicable a los polígonos.\nEsto se ilustra utilizando `us_states`, que representa los Estados Unidos contiguos.\nGEOS asume que los datos están en un CRS proyectado y esto podría llevar a resultados inesperados cuando se utiliza un CRS geográfico.\nPor lo tanto, el primer paso es proyectar los datos en algún CRS proyectado adecuado, como US National Atlas Equal Area (EPSG = 2163):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nus_states2163 = st_transform(us_states, \"EPSG:2163\")\n```\n:::\n\n\n`st_simplify()` funciona igualmente bien con polígonos proyectados:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nus_states_simp1 = st_simplify(us_states2163, dTolerance = 100000)  # 100 km\n```\n:::\n\n\nUna limitación de `st_simplify()` es que simplifica los objetos por geometría.\nEsto significa que se pierde la \"topología\", lo que da lugar a la superposición y unidades areales con huecos.\n`ms_simplify()` de **rmapshaper** proporciona una alternativa que supera este problema.\nPor defecto utiliza el algoritmo Visvalingam, que supera algunas limitaciones del algoritmo Douglas-Peucker.\nEl siguiente trozo de código utiliza esta función para simplificar `us_states2163`.\nEl resultado tiene sólo el 1% de los vértices de la entrada (fijados usando el argumento `keep`) pero su número de objetos permanece intacto porque fijamos `keep_shapes = TRUE`:^[\nLa simplificación de objetos multipoligonales puede eliminar pequeños polígonos internos, incluso si el argumento `keep_shapes` está ajustado a TRUE. Para evitar esto, es necesario establecer `explode = TRUE`. Esta opción convierte todos los mutlipolígonos en polígonos separados antes de su simplificación.\n]\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# proportion of points to retain (0-1; default 0.05)\nus_states_simp2 = rmapshaper::ms_simplify(us_states2163, keep = 0.01,\n                                          keep_shapes = TRUE)\n```\n:::\n\n\nUna alternativa a la simplificación es el suavizado de los límites de las geometrías poligonales y lineales, que se implementa en el paquete **smoothr**. \nEl suavizado interpola los bordes de las geometrías y no conduce necesariamente a un menor número de vértices, pero puede ser especialmente útil cuando se trabaja con geometrías que surgen de vectorizar espacialmente un raster.\n**smoothr** implementa tres técnicas de suavizado: una regresión kernel gaussiana, el algoritmo de corte de esquinas de Chaikin y la interpolación spline. \nLos algoritmos de suavizado tampoco conservan la \"topología\".\nLa función principal de **smoothr** es `smooth()`, donde el argumento `method` especifica qué técnica de suavizado utilizar.\nA continuación se muestra un ejemplo de uso de la regresión kernel gaussiana para suavizar las fronteras de los estados de EE.UU. utilizando `method=ksmooth`.\nEl argumento `smoothness` controla el ancho de banda de la gaussiana que se utiliza para suavizar la geometría y tiene un valor por defecto de 1.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nus_states_simp3 = smoothr::smooth(us_states2163, \n                                  method = \"ksmooth\", smoothness = 6)\n```\n:::\n\n\nLa comparación visual del conjunto de datos original con las versiones simplificada y suavizada se muestra abajo. \nPueden observarse diferencias entre los resultados de los algoritmos Douglas-Peucker (`st_simplify`), Visvalingam (`ms_simplify`) y regresión kernel gaussiana (`smooth(method=ksmooth`).\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Polygon simplification in action, comparing the original geometry of the contiguous United States with simplified versions, generated with functions from sf (top-right), rmapshaper (bottom-left), and smoothr (bottom-right) packages.](operaciones_geometricas_files/figure-html/us-simp-1.png){fig-scap='Polygon simplification in action.' width=672}\n:::\n:::\n\n\n### Centroides\n\nLas operaciones de centroide identifican el centro de los objetos geográficos.\nAl igual que las medidas estadísticas de tendencia central, existen muchas formas de definir el centro geográfico de un objeto.\nTodas ellas crean representaciones de punto único de objetos vectoriales más complejos.\n\nLa operación de centroide más utilizada es el *centroide geográfico*.\nEste tipo de operación centroide representa el centro de masa de un objeto espacial. \nLos centroides geográficos tienen muchos usos, por ejemplo para crear una representación simple de puntos de geometrías complejas, o para estimar distancias entre polígonos.\nPueden calcularse con la función **sf** `st_centroid()`, como se demuestra en el código siguiente, que genera los centroides geográficos de regiones de Nueva Zelanda y afluentes del río Sena, ilustrados con puntos negros.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnz_centroid = st_centroid(nz)\nseine_centroid = st_centroid(seine)\n```\n:::\n\n\nA veces, el centroide geográfico cae fuera de los límites de sus objetos padre (piense en un donut).\nEn tales casos, las operaciones *punto sobre superficie* pueden utilizarse para garantizar que el punto se encuentra en el objeto padre (por ejemplo, para etiquetar objetos multipoligonales irregulares como los estados insulares), como ilustran los puntos rojos de la figura abajo.\nObserve que estos puntos rojos siempre se encuentran en sus objetos padre.\nSe crearon con `st_point_on_surface()` de la siguiente manera:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnz_pos = st_point_on_surface(nz)\nseine_pos = st_point_on_surface(seine)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Centroids (black points) and 'points on surface' (red points) of New Zealand's regions (left) and the Seine (right) datasets.](operaciones_geometricas_files/figure-html/centr-1.png){fig-scap='Centroid vs point on surface operations.' width=672}\n:::\n:::\n\n\n### Buffers\n\nLos buffers son polígonos que representan el área dentro de una distancia determinada de un elemento geométrico:\nindependientemente de si la entrada es un punto, una línea o un polígono, la salida es un polígono.\nEl buffering suele utilizarse para el análisis de datos geográficos.\n¿Cuántos puntos se encuentran a una distancia determinada de esta línea?\n¿Qué grupos demográficos se encuentran a una distancia de viaje de esta nueva tienda?\nEste tipo de preguntas pueden responderse y visualizarse creando buffers alrededor de las entidades geográficas de interés.\n\nLa próxima figura ilustra los buffers de diferentes tamaños (5 y 50 km) que rodean el río Sena y sus afluentes.\nEstos buffers se crearon con los comandos que se indican a continuación, que muestran que el comando `st_buffer()` requiere al menos dos argumentos: una geometría de entrada y una distancia, proporcionada en las unidades del CRS (en este caso metros):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseine_buff_5km = st_buffer(seine, dist = 5000)\nseine_buff_50km = st_buffer(seine, dist = 50000)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Buffers around the Seine dataset of 5 km (left) and 50 km (right). Note the colors, which reflect the fact that one buffer is created per geometry feature.](operaciones_geometricas_files/figure-html/buffs-1.png){fig-scap='Buffers around the seine dataset.' width=75%}\n:::\n:::\n\n\n\n### Transformaciones afines\n\nUna transformación afín es cualquier transformación que conserva las líneas y el paralelismo.\nSin embargo, los ángulos o la longitud no se conservan necesariamente.\nLas transformaciones afines incluyen, entre otras, el desplazamiento (traslación), la escala y la rotación.\nAdemás, es posible utilizar cualquier combinación de ellas.\nLas transformaciones afines son una parte esencial de la geocomputación.\nPor ejemplo, el desplazamiento es necesario para la colocación de etiquetas, el escalado se utiliza en cartogramas de áreas no contiguas, y muchas transformaciones afines se aplican al reproyectar o mejorar la geometría que se creó basándose en un mapa distorsionado o mal proyectado.\nEl paquete **sf** implementa transformaciones afines para objetos de las clases `sfg` y `sfc`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnz_sfc = st_geometry(nz)\n```\n:::\n\n\nEl desplazamiento mueve cada punto la misma distancia en unidades de mapa.\nPuede hacerse añadiendo un vector numérico a un objeto vectorial.\nPor ejemplo, el código siguiente desplaza todas las coordenadas y 100.000 metros hacia el norte, pero deja intactas las coordenadas x. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnz_shift = nz_sfc + c(0, 100000)\n```\n:::\n\n\nLa escala amplía o reduce los objetos en un factor dado. Puede aplicarse global o localmente.\nEl escalado global aumenta o disminuye todos los valores de las coordenadas en relación con las coordenadas de origen, manteniendo intactas todas las relaciones topológicas de las geometrías.\nPuede realizarse por sustracción o multiplicación de un objeto `sfg` o `sfc`.\n\n\n::: {.cell}\n\n:::\n\n\nEl escalado local trata las geometrías de forma independiente y requiere puntos alrededor de los cuales se van a escalar las geometrías, por ejemplo, los centroides.\nEn el ejemplo siguiente, cada geometría se reduce en un factor de dos alrededor de los centroides.\nPara ello, primero se desplaza cada objeto de modo que su centro tenga coordenadas `0, 0` (`(nz_sfc - nz_centroid_sfc)`). \nA continuación, los tamaños de las geometrías se reducen a la mitad (`* 0,5`).\nPor último, el centroide de cada objeto se desplaza a las coordenadas de los datos de entrada (`+ nz_centroid_sfc`). \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnz_centroid_sfc = st_centroid(nz_sfc)\nnz_scale = (nz_sfc - nz_centroid_sfc) * 0.5 + nz_centroid_sfc\n```\n:::\n\n\nLa rotación de coordenadas bidimensionales requiere una matriz de rotación:\n\n$$\nR =\n\\begin{bmatrix}\n\\cos \\theta & -\\sin \\theta \\\\  \n\\sin \\theta & \\cos \\theta \\\\\n\\end{bmatrix}\n$$\n\nÉsta gira los puntos en el sentido de las agujas del reloj. La matriz de rotación se puede implementar en R como:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrotation = function(a){\n  r = a * pi / 180 #degrees to radians\n  matrix(c(cos(r), sin(r), -sin(r), cos(r)), nrow = 2, ncol = 2)\n} \n```\n:::\n\n\nLa función `rotation` acepta un argumento `a` - un ángulo de rotación en grados.\nLa rotación puede realizarse alrededor de puntos seleccionados, como los centroides.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnz_rotate = (nz_sfc - nz_centroid_sfc) * rotation(30) + nz_centroid_sfc\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Illustrations of affine transformations: shift, scale and rotate.](operaciones_geometricas_files/figure-html/affine-trans-1.png){fig-scap='Illustrations of affine transformations.' width=672}\n:::\n:::\n\n\nPor último, las geometrías recién creadas pueden sustituir a las antiguas con la función `st_set_geometry()`: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnz_scale_sf = st_set_geometry(nz, nz_scale)\n```\n:::\n\n\n### Clipping\n\nEl recorte espacial es una forma de subset espacial que implica cambios en las columnas `geometry` de al menos algunas de las características afectadas.\n\nEl recorte sólo puede aplicarse a características más complejas que los puntos: \nlíneas, polígonos y sus equivalentes \"multi\".\nPara ilustrar el concepto, empezaremos con un ejemplo sencillo:\ndos círculos superpuestos con un punto central a una unidad de distancia el uno del otro y un radio de uno.\n\n\n::: {.cell fig.asp='0.4' crop='true'}\n\n```{.r .cell-code}\nb = st_sfc(st_point(c(0, 1)), st_point(c(1, 1))) # create 2 points\nb = st_buffer(b, dist = 1) # convert points to circles\nplot(b, border = \"grey\")\ntext(x = c(-0.5, 1.5), y = 1, labels = c(\"x\", \"y\"), cex = 3) # add text\n```\n\n::: {.cell-output-display}\n![Overlapping circles.](operaciones_geometricas_files/figure-html/points-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\nImagina que quieres seleccionar no un círculo u otro, sino el espacio cubierto por `x` *y* `y`.\nPara ello se utiliza la función `st_intersection()`, ilustrada con objetos denominados `x` e `y`, que representan los círculos izquierdo y derecho.\n\n\n::: {.cell fig.asp='0.4' crop='true'}\n\n```{.r .cell-code}\nx = b[1]\ny = b[2]\nx_and_y = st_intersection(x, y)\nplot(b, border = \"grey\")\nplot(x_and_y, col = \"lightgrey\", border = \"grey\", add = TRUE) # intersecting area\n```\n\n::: {.cell-output-display}\n![Overlapping circles with a gray color indicating intersection between them.](operaciones_geometricas_files/figure-html/circle-intersection-1.png){fig-scap='Overlapping circles showing intersection types.' width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\nEl siguiente fragmento de código demuestra cómo funciona esto para todas las combinaciones del diagrama de Venn que representan `x` e `y`, inspirado en la [Figura 5.1](http://r4ds.had.co.nz/transform.html#logical-operators) del libro *R for Data Science*.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Spatial equivalents of logical operators.](operaciones_geometricas_files/figure-html/venn-clip-1.png){width=672}\n:::\n:::\n\n\n### Subsetting y clipping\n\nRecortar objetos puede cambiar su geometría, pero también puede subdividir objetos, devolviendo sólo las características que se cruzan (o se cruzan parcialmente) con un objeto de recorte/subconjunto.\nPara ilustrar este punto, vamos a subdividir puntos que cubren el cuadro delimitador de los círculos `x` e `y` en la figura anterior.\nAlgunos puntos estarán dentro de un solo círculo, otros dentro de los dos y otros dentro de ninguno.\nA continuación se utiliza `st_sample()` para generar una distribución *aleatoria* de puntos dentro de la extensión de los círculos `x` e `y`, planteando la siguiente pregunta: ¿cómo subconjuntar los puntos para devolver sólo el punto que se cruza con *ambos* `x` e `y`?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbb = st_bbox(st_union(x, y))\nbox = st_as_sfc(bb)\nset.seed(2017)\np = st_sample(x = box, size = 10)\np_xy1 = p[x_and_y]\nplot(box, border = \"grey\", lty = 2)\nplot(x, add = TRUE, border = \"grey\")\nplot(y, add = TRUE, border = \"grey\")\nplot(p, add = TRUE)\nplot(p_xy1, cex = 3, col = \"red\", add = TRUE)\ntext(x = c(-0.5, 1.5), y = 1, labels = c(\"x\", \"y\"), cex = 2)\n```\n\n::: {.cell-output-display}\n![Randomly distributed points within the bounding box enclosing circles x and y. The point that intersects with both objects x and y is highlighted.](operaciones_geometricas_files/figure-html/venn-subset-1.png){fig-scap='Randomly distributed points within the bounding box. Note that only one point intersects with both x and y, highlighted with a red circle.' width=864}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbb = st_bbox(st_union(x, y))\nbox = st_as_sfc(bb)\nset.seed(2017)\np = st_sample(x = box, size = 10)\nx_and_y = st_intersection(x, y)\n```\n:::\n\n\nEl siguiente fragmento de código muestra tres formas de conseguir el mismo resultado.\nPodemos utilizar la intersección de `x` y `y` (representados por `x_and_y` en el fragmento de código anterior) como un objeto de subconjunto directamente, como se muestra en la primera línea en el fragmento de código a continuación.\nTambién podemos encontrar la *intersección* entre los puntos de entrada representados por `p` y el objeto de subconjunto/recorte `x_and_y`, como se muestra en la segunda línea del fragmento de código siguiente.\nEste segundo enfoque devolverá características que se intersecan parcialmente con `x_and_y` pero con geometrías modificadas para características espacialmente extensas que cruzan la frontera del objeto de subconjunto.\nEl tercer enfoque consiste en crear un objeto de subconjunto utilizando el predicado espacial binario `st_intersects()`.\nLos resultados son idénticos (salvo diferencias superficiales en los nombres de los atributos), pero la implementación difiere sustancialmente:\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_xy1 = p[x_and_y] # way #1\np_xy2 = st_intersection(p, x_and_y) # way #2\nsel_p_xy = st_intersects(p, x, sparse = FALSE)[, 1] & \n  st_intersects(p, y, sparse = FALSE)[, 1] # way #3\np_xy3 = p[sel_p_xy]\n```\n:::\n\n\n### Uniones geométricas\n\nLa agregación espacial puede disolver silenciosamente las geometrías de los polígonos que se tocan en el mismo grupo.\nEsto se demuestra en el fragmento de código siguiente, en el que 49 `us_states` se agregan en cuatro regiones utilizando las funciones base y **dplyr**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nregions = aggregate(x = us_states[, \"total_pop_15\"], by = list(us_states$REGION),\n                    FUN = sum, na.rm = TRUE)\nregions2 = us_states |> \n  group_by(REGION) |>\n  summarize(pop = sum(total_pop_15, na.rm = TRUE))\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Spatial aggregation on contiguous polygons, illustrated by aggregating the population of US states into regions, with population represented by color. Note the operation automatically dissolves boundaries between states.](operaciones_geometricas_files/figure-html/us-regions-1.png){fig-scap='Spatial aggregation on contiguous polygons.' width=100%}\n:::\n:::\n\n\n¿Qué ocurre con las geometrías?\nEntre bastidores, tanto `aggregate()` como `summarize()` combinan las geometrías y disuelven los límites entre ellas utilizando `st_union()`.\nEsto se demuestra en el fragmento de código siguiente, que crea un oeste de EE.UU. unido: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nus_west = us_states[us_states$REGION == \"West\", ]\nus_west_union = st_union(us_west)\n```\n:::\n\n\nLa función puede tomar dos geometrías y unirlas, como se demuestra en el siguiente fragmento de código que crea un bloque occidental unido que incorpora Texas:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntexas = us_states[us_states$NAME == \"Texas\", ]\ntexas_union = st_union(us_west_union, texas)\n```\n:::\n\n\n### Transformaciones de tipo\n\nGeometry casting es una potente operación que permite transformar el tipo de geometría.\nEstá implementada en la función `st_cast()` del paquete **sf**.\nEs importante destacar que `st_cast()` se comporta de forma diferente en objetos de geometría simple (`sfg`) y  objetos de geometría simple en columna (`sfc`).\n\nVamos a crear un multipunto para ilustrar cómo funciona el cambio de geometría en objetos de geometría simple (`sfg`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmultipoint = st_multipoint(matrix(c(1, 3, 5, 1, 3, 1), ncol = 2))\n```\n:::\n\n\nEn este caso, `st_cast()` puede ser útil para transformar el nuevo objeto en una cadena de líneas o un polígono:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlinestring = st_cast(multipoint, \"LINESTRING\")\npolyg = st_cast(multipoint, \"POLYGON\")\n```\n:::\n\n::: {.cell fig.asp='0.3'}\n::: {.cell-output-display}\n![Examples of a linestring and a polygon casted from a multipoint geometry.](operaciones_geometricas_files/figure-html/single-cast-1.png){fig-scap='Examples of casting operations.' width=672}\n:::\n:::\n\n\nLa conversión de multipunto a cadena de líneas es una operación habitual que crea un objeto de línea a partir de observaciones de puntos ordenados, como mediciones GPS o medios geoetiquetados.\nEsto, a su vez, permite realizar operaciones espaciales como el cálculo de la longitud del camino recorrido.\nLa conversión de multipunto o cadena de líneas a polígono se utiliza a menudo para calcular un área, por ejemplo a partir del conjunto de mediciones GPS tomadas alrededor de un lago o de las esquinas de un solar.\n\nEl proceso de transformación también puede invertirse utilizando `st_cast()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmultipoint_2 = st_cast(linestring, \"MULTIPOINT\")\nmultipoint_3 = st_cast(polyg, \"MULTIPOINT\")\nall.equal(multipoint, multipoint_2)\nall.equal(multipoint, multipoint_3)\n## [1] TRUE\n## [1] TRUE\n```\n:::\n\n\n:::{.callout-note}\nPara geometrías simples (`sfg`), `st_cast()` también permite pasar geometrías de no multitipos a multitipos (por ejemplo, de `POINT` a `MULTIPOINT`) y de multitipos a no multitipos.\nSin embargo, al pasar de multitipos a no multitipos, sólo el primer elemento del objeto antiguo permanecerá en el objeto de salida.\n:::\n\n\n\n\n\nLa conversión geométrica de la columna geométrica de características simples (`sfc`) y los objetos de características simples funciona igual que para `sfg` en la mayoría de los casos. \nUna diferencia importante es la conversión de multitipos a no multitipos.\nComo resultado de este proceso, los objetos múltiples de `sfc` o `sf` se dividen en muchos objetos no múltiples.\n\nLa tabla de abajo muestra las posibles transformaciones del tipo de geometría en objetos sf.\nLas geometrías de sf (representadas por la primera columna de la tabla) pueden transformarse en múltiples tipos de geometría, representados por las columnas de la tabla abajo.\nAlgunas transformaciones no son posibles: no se puede convertir un único punto en una multilínea o un polígono, por ejemplo, lo que explica por qué las celdas `[1, 4:5]` de la tabla contienen NA.\nAlgunas transformaciones dividen la entrada de una única característica en múltiples subcaracterísticas, \"expandiendo\" objetos `sf` (añadiendo nuevas filas con valores de atributos duplicados).\nCuando una geometría multipunto que consta de cinco pares de coordenadas se transforma en una geometría \"PUNTO\", por ejemplo, la salida contendrá cinco características.\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table>\n<caption>Geometry casting on simple feature geometries (see Section 2.1) with input type by row and output type by column</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">  </th>\n   <th style=\"text-align:right;\"> POI </th>\n   <th style=\"text-align:right;\"> MPOI </th>\n   <th style=\"text-align:right;\"> LIN </th>\n   <th style=\"text-align:right;\"> MLIN </th>\n   <th style=\"text-align:right;\"> POL </th>\n   <th style=\"text-align:right;\"> MPOL </th>\n   <th style=\"text-align:right;\"> GC </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> POI(1) </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> NA </td>\n   <td style=\"text-align:right;\"> NA </td>\n   <td style=\"text-align:right;\"> NA </td>\n   <td style=\"text-align:right;\"> NA </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> MPOI(1) </td>\n   <td style=\"text-align:right;\"> 4 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> NA </td>\n   <td style=\"text-align:right;\"> NA </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> LIN(1) </td>\n   <td style=\"text-align:right;\"> 5 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> NA </td>\n   <td style=\"text-align:right;\"> NA </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> MLIN(1) </td>\n   <td style=\"text-align:right;\"> 7 </td>\n   <td style=\"text-align:right;\"> 2 </td>\n   <td style=\"text-align:right;\"> 2 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> NA </td>\n   <td style=\"text-align:right;\"> NA </td>\n   <td style=\"text-align:right;\"> NA </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> POL(1) </td>\n   <td style=\"text-align:right;\"> 5 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> NA </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> MPOL(1) </td>\n   <td style=\"text-align:right;\"> 10 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> NA </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> 2 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> GC(1) </td>\n   <td style=\"text-align:right;\"> 9 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> NA </td>\n   <td style=\"text-align:right;\"> NA </td>\n   <td style=\"text-align:right;\"> NA </td>\n   <td style=\"text-align:right;\"> NA </td>\n   <td style=\"text-align:right;\"> 1 </td>\n  </tr>\n</tbody>\n<tfoot>\n<tr>\n<td style = 'padding: 0; border:0;' colspan='100%'><sup></sup> Note: Values like (1) represent the number of features; NA means the operation is not possible. Abbreviations: POI, LIN, POL and GC refer to POINT, LINESTRING, POLYGON and GEOMETRYCOLLECTION. The MULTI version of these geometry types is indicated by a preceding M, e.g., MPOI is the acronym for MULTIPOINT.</td>\n</tr>\n</tfoot>\n</table>\n\n`````\n:::\n:::\n\n\nIntentemos aplicar transformaciones de tipo geométrico sobre un nuevo objeto, `multilinestring_sf`, como ejemplo :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmultilinestring_list = list(matrix(c(1, 4, 5, 3), ncol = 2), \n                            matrix(c(4, 4, 4, 1), ncol = 2),\n                            matrix(c(2, 4, 2, 2), ncol = 2))\nmultilinestring = st_multilinestring(multilinestring_list)\nmultilinestring_sf = st_sf(geom = st_sfc(multilinestring))\nmultilinestring_sf\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n<table>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> geom </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> MULTILINESTRING ((1 5, 4 3)... </td>\n  </tr>\n</tbody>\n</table>\n\n</div>\n:::\n:::\n\n\nPuede imaginárselo como una red de carreteras o ríos. \nEl nuevo objeto sólo tiene una fila que define todas las líneas.\nEsto restringe el número de operaciones que se pueden realizar, por ejemplo impide añadir nombres a cada segmento de línea o calcular longitudes de líneas individuales.\nLa función `st_cast()` puede utilizarse en esta situación, ya que separa una mutlilínea en tres líneas:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlinestring_sf2 = st_cast(multilinestring_sf, \"LINESTRING\")\nlinestring_sf2\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n<table>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> geom </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> LINESTRING (1 5, 4 3) </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> LINESTRING (4 4, 4 1) </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> LINESTRING (2 2, 4 2) </td>\n  </tr>\n</tbody>\n</table>\n\n</div>\n:::\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Examples of type casting between MULTILINESTRING (left) and LINESTRING (right).](operaciones_geometricas_files/figure-html/line-cast-1.png){fig-scap='Examples of type casting.' width=672}\n:::\n:::\n\n\nEl objeto recién creado permite la creación de atributos y mediciones de longitud:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlinestring_sf2$name = c(\"Riddle Rd\", \"Marshall Ave\", \"Foulke St\")\nlinestring_sf2$length = st_length(linestring_sf2)\nlinestring_sf2\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n<table>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> geom </th>\n   <th style=\"text-align:left;\"> name </th>\n   <th style=\"text-align:right;\"> length </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> LINESTRING (1 5, 4 3) </td>\n   <td style=\"text-align:left;\"> Riddle Rd </td>\n   <td style=\"text-align:right;\"> 3.605551 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> LINESTRING (4 4, 4 1) </td>\n   <td style=\"text-align:left;\"> Marshall Ave </td>\n   <td style=\"text-align:right;\"> 3.000000 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> LINESTRING (2 2, 4 2) </td>\n   <td style=\"text-align:left;\"> Foulke St </td>\n   <td style=\"text-align:right;\"> 2.000000 </td>\n  </tr>\n</tbody>\n</table>\n\n</div>\n:::\n:::\n\n\n## Operaciones geométricas sobre datos raster\n\nLas operaciones geométricas ráster incluyen el desplazamiento, la inversión, el reflejo, la escala, la rotación o la deformación de imágenes.\nEstas operaciones son necesarias para diversas aplicaciones, como la georreferenciación, que permite superponer imágenes en un mapa con un CRS conocido.\nExisten diversas técnicas de georreferenciación, entre las que se incluyen:\n\n- Georrectificación basada en [puntos de control terrestre  conocidos](https://www.qgistutorials.com/en/docs/3/georeferencing_basics.html)\n- Ortorectificación, que también tiene en cuenta la topografía local\n- El [co-registro de imágenes](https://en.wikipedia.org/wiki/Image_registration) se utiliza para combinar imágenes del mismo objeto pero tomadas con sensores diferentes, alineando una imagen con otra (en términos de sistema de coordenadas y resolución).\n\nR es bastante inadecuado para los dos primeros puntos, ya que a menudo requieren una intervención manual, por lo que suelen realizarse con la ayuda de software SIG específico.\nPor otro lado, alinear varias imágenes es posible en R y esta sección muestra, entre otras cosas, cómo hacerlo.\nEsto incluye a menudo cambiar la extensión, la resolución y el origen de una imagen.\nPor supuesto, también se requiere una proyección que coincida.\n\n### Intersecciones geométricas\n \nHemos mostrado cómo extraer valores de un ráster superpuesto por otros objetos espaciales.\nPara recuperar una salida espacial, podemos utilizar casi la misma sintaxis de subset.\nLa única diferencia es que tenemos que dejar claro que queremos mantener la estructura matricial estableciendo el argumento `drop` en `FALSE`.\nEsto devolverá un objeto raster que contiene las celdas cuyos puntos medios se solapan con `clip`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelev = rast(system.file(\"raster/elev.tif\", package = \"spData\"))\nclip = rast(xmin = 0.9, xmax = 1.8, ymin = -0.45, ymax = 0.45,\n            resolution = 0.3, vals = rep(1, 9))\nelev[clip, drop = FALSE]\n## class       : SpatRaster \n## dimensions  : 2, 1, 1  (nrow, ncol, nlyr)\n## resolution  : 0.5, 0.5  (x, y)\n## extent      : 1, 1.5, -0.5, 0.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## varname     : elev \n## name        : elev \n## min value   :   18 \n## max value   :   24\n```\n:::\n\n\nPara la misma operación también podemos utilizar el comando `intersect()` y `crop()`.\n\n### Extensión y origen\n\nCuando fusionamos o realizamos álgebra de mapas sobre rásters, su resolución, proyección, origen y/o extensión tienen que coincidir. De lo contrario, ¿cómo podríamos sumar los valores de un ráster con una resolución de 0.2 grados decimales a un segundo ráster con una resolución de 1 grado decimal?\nEl mismo problema se plantea cuando queremos fusionar imágenes de satélite procedentes de distintos sensores con proyecciones y resoluciones diferentes. Los desajustes pueden resolverse alineando los rásters.\n\nEn el caso más sencillo, dos imágenes sólo difieren en su extensión.\nEl código siguiente añade una fila y dos columnas a cada lado del ráster y establece todos los valores nuevos en `NA`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelev = rast(system.file(\"raster/elev.tif\", package = \"spData\"))\nelev_2 = extend(elev, c(1, 2))\n```\n:::\n\n::: {.cell fig.asp='0.5'}\n::: {.cell-output-display}\n![Original raster (left) and the same raster (right) extended by one row on the top and bottom and two columns on the left and right.](operaciones_geometricas_files/figure-html/extend-example-1.png){fig-scap='Extending rasters.' width=672}\n:::\n:::\n\n\nAl realizar una operación algebraica sobre dos objetos con extensiones diferentes en R, el paquete **terra** devuelve un error.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelev_3 = elev + elev_2\n## Error: [+] extents do not match\n```\n:::\n\n\nSin embargo, podemos alinear la extensión de dos rásters con `extend()`. \nEn lugar de decirle a la función cuántas filas o columnas deben añadirse (como se ha hecho antes), le permitimos que lo averigüe utilizando otro objeto raster.\nEn este caso, ampliamos el objeto `elev` hasta la extensión `elev_2`. \nLos valores de las filas y columnas recién añadidas se fijan en `NA`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelev_4 = extend(elev, elev_2)\n```\n:::\n\n\nEl origen de un raster es la esquina de la celda más cercana a las coordenadas (0, 0).\nLa función `origin()` devuelve las coordenadas del origen.\nEn el siguiente ejemplo existe una esquina de celda con coordenadas (0, 0), pero no es necesariamente el caso.\n\n\n::: {.cell}\n\n```{.r .cell-code}\norigin(elev_4)\n## [1] 0 0\n```\n:::\n\n\nSi dos rásters tienen orígenes diferentes, sus celdas no se solapan completamente, lo que haría imposible el álgebra de mapas.\nPara cambiar el origen, utilice `origin()`.^[\nSi los orígenes de dos conjuntos de datos ráster están sólo marginalmente separados, a veces es suficiente simplemente aumentar el argumento `tolerance` de `terra::terraOptions()`.\n]\nLa próxima figura muestra el efecto de cambiar el origen de esta forma.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# change the origin\norigin(elev_4) = c(0.25, 0.25)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Rasters with identical values but different origins.](operaciones_geometricas_files/figure-html/origin-example-1.png){width=672}\n:::\n:::\n\n\nTenga en cuenta que al cambiar la resolución (apartado siguiente) también cambia con frecuencia el origen.\n\n### Agregación y desagregación\n\nLos conjuntos de datos ráster también pueden diferir en cuanto a su resolución. \nPara igualar las resoluciones, se puede disminuir (`aggregate()`) o aumentar (`disagg()`) la resolución de un raster.^[\nAquí nos referimos a la resolución espacial.\nEn teledetección también son importantes la resolución espectral (bandas espectrales), temporal (observaciones a lo largo del tiempo de la misma zona) y radiométrica (profundidad de color).\nConsulte el ejemplo `tapp()` de la documentación para hacerse una idea de cómo realizar la agregación temporal de rásters.\n]\nComo ejemplo, aquí cambiamos la resolución espacial de `dem` (que se encuentra en el paquete **spDataLarge**) por un factor de 5.\nAdemás, el valor de la celda de salida debe corresponder a la media de las celdas de entrada (tenga en cuenta que también se podrían utilizar otras funciones, como `median()`, `sum()`, etc.):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndem = rast(system.file(\"raster/dem.tif\", package = \"spDataLarge\"))\ndem_agg = aggregate(dem, fact = 5, fun = mean)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Original raster (left). Aggregated raster (right).](operaciones_geometricas_files/figure-html/aggregate-example-1.png){width=672}\n:::\n:::\n\n\nLa función `disagg()` aumenta la resolución de los objetos raster. \nDispone de dos métodos para calcular los valores de las celdas recién creadas: el método por defecto (`method = \"near\"`) simplemente da a todas las celdas de salida el valor de la celda de entrada y, por tanto, duplica los valores, lo que se traduce en una salida \"en bloque\".\nEl método `bilineal` utiliza los cuatro centros de píxel más cercanos de la imagen de entrada para calcular un promedio ponderado por la distancia.\nEl valor de la celda de salida está representado por un cuadrado en la esquina superior izquierda.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndem_disagg = disagg(dem_agg, fact = 5, method = \"bilinear\")\nidentical(dem, dem_disagg)\n## [1] FALSE\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![The distance-weighted average of the four closest input cells determine the output when using the bilinear method for disaggregation.](operaciones_geometricas_files/figure-html/bilinear-1.png){fig-scap='Bilinear disaggregation in action.' width=768}\n:::\n:::\n\n\nLa comparación de los valores de `dem` y `dem_disagg` nos indica que no son idénticos (también puede utilizar `compareGeom()` o `all.equal()`).\nSin embargo, esto no era de esperar, ya que la desagregación es una simple técnica de interpolación.\nEs importante tener en cuenta que la desagregación da como resultado una resolución más fina; los valores correspondientes, sin embargo, sólo son tan precisos como su fuente de menor resolución.\n\n### Remuestreo\n\nLos métodos anteriores de agregación y desagregación sólo son adecuados cuando queremos cambiar la resolución de nuestro ráster mediante el factor de agregación/desagregación. \nSin embargo, ¿qué hacer cuando tenemos dos o más rásters con resoluciones y orígenes diferentes?\nEsta es la función del remuestreo, un proceso de cálculo de valores para las nuevas ubicaciones de los píxeles.\nEn resumen, este proceso toma los valores de nuestro ráster original y recalcula nuevos valores para un ráster de destino con resolución y origen personalizados.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Resampling of an original (input) raster into a target raster with custom resolution and origin.](operaciones_geometricas_files/figure-html/resampl0-1.png){width=672}\n:::\n:::\n\n\nExisten varios métodos para estimar los valores de un ráster con diferentes resoluciones/orígenes. \nLos principales métodos de remuestreo son\n\n- Vecino más cercano: asigna el valor de la celda más cercana del ráster original a la celda del objetivo. Se trata de una técnica rápida y sencilla que suele ser adecuada para el remuestreo de rásters categóricos.\n- Interpolación bilineal: asigna una media ponderada de las cuatro celdas más cercanas del raster original a la celda del raster de destino. Es el método más rápido y apropiado para rásters continuos.\n- Interpolación cúbica: utiliza los valores de las 16 celdas más cercanas del ráster original para determinar el valor de la celda de salida, aplicando funciones polinómicas de tercer orden. Se utiliza para rásters continuos y da como resultado una superficie más suave en comparación con la interpolación bilineal, pero es computacionalmente más exigente.\n- Interpolación spline cúbica: también utiliza los valores de las 16 celdas más cercanas del ráster original para determinar el valor de la celda de salida, pero aplica splines cúbicos (funciones polinómicas de tercer orden a trozos). Se utiliza para raster continuos.\n- Remuestreo sinc con ventana de Lanczos: utiliza los valores de las 36 celdas más cercanas del raster original para determinar el valor de la celda de salida. Se utiliza para los raster continuos.\n\nLa explicación anterior pone de relieve que sólo el remuestreo de *vecino más próximo* es adecuado para los rásteres categóricos, mientras que todos los métodos pueden utilizarse (con diferentes resultados) para los rásteres continuos.\nTenga en cuenta también que los métodos ganan en complejidad y tiempo de procesamiento de arriba a abajo.\n\nPara aplicar el remuestreo, el paquete **terra** proporciona una función `resample()`.\nAcepta un ráster de entrada (`x`), un ráster objetivo (`y`) y un método de remuestreo (`method`).\n\nNecesitamos un ráster objetivo para ver cómo funciona la función `resample()`.\nPara este ejemplo, creamos `target_rast`, pero a menudo se utiliza un objeto raster ya existente.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntarget_rast = rast(xmin = 794650, xmax = 798250, \n                   ymin = 8931750, ymax = 8935350,\n                   resolution = 300, crs = \"EPSG:32717\")\n```\n:::\n\n\nA continuación, tenemos que proporcionar nuestros dos objetos raster como los dos primeros argumentos y uno de los métodos de remuestreo descritos anteriormente.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndem_resampl = resample(dem, y = target_rast, method = \"bilinear\")\n```\n:::\n\n\nLa próxima figura muestra una comparación de diferentes métodos de remuestreo en el objeto `dem`.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Visual comparison of the original raster and five different resampling methods.](operaciones_geometricas_files/figure-html/resampl-1.png){width=672}\n:::\n:::\n\n\nLa función `resample()` también tiene algunos métodos de remuestreo adicionales, como `sum`, `min`, `q1`, `med`, `q3`, `max`, `average`, `mode` y `rms`.\nTodos ellos calculan una estadística determinada basándose en los valores de todas las celdas de la cuadrícula que no son NA.\nPor ejemplo, `sum` es útil cuando cada celda raster representa una variable espacialmente extensa (por ejemplo, el número de personas).\nComo consecuencia del uso de `sum`, el ráster remuestreado debería tener el mismo número total de personas que el original.\n\nLa reproyección de raster es un caso especial de remuestreo cuando nuestro raster de destino tiene un CRS diferente al del raster original.\n",
    "supporting": [
      "operaciones_geometricas_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}