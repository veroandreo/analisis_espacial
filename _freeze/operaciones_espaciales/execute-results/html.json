{
  "hash": "8a9c237114b4bdb6447d6c3b9dea0946",
  "result": {
    "markdown": "---\ntitle: \"Operaciones espaciales\"\nauthor: \"Modificado de <https://r.geocompx.org/>\"\nformat: \n  html:\n    toc: true\n    df-print: kable\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(terra)\nlibrary(dplyr)\nlibrary(spData)\n```\n:::\n\n\nLas operaciones espaciales, incluidas las uniones espaciales entre conjuntos de datos vectoriales y las operaciones locales y focales en datos ráster, son una parte vital de la geocomputación.\nLos objetos espaciales pueden modificarse de múltiples maneras en función de su ubicación y forma.\nMuchas operaciones espaciales tienen un equivalente no espacial (atributo), por lo que conceptos como el subset y la unión de conjuntos de datos demostrados anteriormente son aplicables aquí.\n\nSin embargo, las operaciones espaciales difieren de las no espaciales en varios aspectos. Las uniones espaciales, por ejemplo, pueden realizarse de varias formas, incluida la coincidencia de entidades que se cruzan o se encuentran a una cierta distancia del conjunto de datos de destino, mientras que las uniones por atributos sólo pueden realizarse de una forma.\n\nOtro aspecto único de los objetos espaciales es la distancia: todos los objetos espaciales se relacionan a través del espacio, y los cálculos de distancia se pueden utilizar para explorar la fuerza de esta relación (Sección \\@ref(relaciones-distancia)).\n\nLas operaciones espaciales sobre objetos ráster incluyen el subset o subdivisión y la fusión de varios \"mosaicos\" ráster en un único objeto.\nEl álgebra de mapas abarca una serie de operaciones que modifican los valores de las celdas ráster, con o sin referencia a los valores de las celdas circundantes.\nAsí, se muestran operaciones de álgebra de mapas locales, focales, zonales y globales.\n\n:::{.callout-note}\nEs importante tener en cuenta que las operaciones espaciales que utilizan dos objetos espaciales dependen de que ambos objetos tengan el mismo sistema de  coordenadas.\n:::\n\n## Operaciones espaciales sobre datos vectoriales\n\nEsta sección proporciona una visión general de las operaciones espaciales sobre datos geográficos vectoriales **sf**.\n\n### Subdivisión espacial\n\nEl subset espacial es el proceso de tomar un objeto espacial y devolver un nuevo objeto que contenga sólo las características que se *relacionan* en el espacio con otro objeto.\nDe forma análoga al *sudset de atributos*, pueden crearse subconjuntos de data.frames `sf` con el operador corchete (`[`) utilizando la sintaxis `x[y, , op = st_intersects]`, donde `x` es un objeto `sf` del que se obtendrá un subconjunto de filas, `y` es el `objeto de subconjunto` y `, op = st_intersects` es un argumento opcional que especifica la relación topológica (también conocida como predicado binario) utilizada para realizar el subconjunto.\n\nLa relación topológica por defecto utilizada cuando no se proporciona un argumento `op` es `st_intersects()`: el comando `x[y, ]` es idéntico a `x[y, , op = st_intersects]` mostrado anteriormente pero no a `x[y, , op = st_disjoint]` (el significado de estas y otras relaciones topológicas se describe en la siguiente sección).\n\nPara demostrar el subset espacial, utilizaremos los conjuntos de datos `nz` y `nz_height` del paquete **spData**, que contienen datos geográficos sobre las 16 regiones principales y los 101 puntos más altos de Nueva Zelanda, respectivamente (Figura \\@ref(fig:nz-subset)), en un sistema de coordenadas proyectado.\nEl siguiente fragmento de código crea un objeto que representa Canterbury y, a continuación, utiliza el subset espacial para devolver todos los puntos altos de la región:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncanterbury = nz |> filter(Name == \"Canterbury\")\ncanterbury_height = nz_height[canterbury, ]\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Illustration of spatial subsetting with red triangles representing 101 high points in New Zealand, clustered near the central Canterbuy region (left). The points in Canterbury were created with the `[` subsetting operator (highlighted in gray, right).](operaciones_espaciales_files/figure-html/nz-subset-1.png){fig-scap='Illustration of spatial subsetting.' width=672}\n:::\n:::\n\n\nAl igual que el subset de atributos, el comando `x[y, ]` (equivalente a `nz_height[canterbury, ]`) selecciona características de un objeto *objetivo* `x` utilizando el contenido de un objeto *fuente* `y`.\nSin embargo, en lugar de que `y` sea un vector de clase `lógica` o `entera`, para el subset espacial tanto `x` como `y` deben ser objetos geográficos, en este caso `sf`.\n\nSe pueden utilizar varias *relaciones topológicas* que determinan el tipo de relación espacial pueden ser: *toques*, *cruces* o *dentro de*. \nEl parámetro por defecto `st_intersects` es una relación topológica tipo 'catch all' que devolverá características en el objetivo que *toquen*, *crucen* o estén *dentro* del objeto fuente.\nComo se ha indicado anteriormente, se pueden especificar operadores espaciales alternativos con el argumento `op =`, como se demuestra en el siguiente comando que devuelve lo contrario de `st_intersects()`, puntos que no se intersecan con Canterbury:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnz_height[canterbury, , op = st_disjoint]\n```\n:::\n\n\n:::{.callout-note}\nObserve que el argumento vacío --- denotado con `, ,` --- en el trozo de código anterior se incluye para resaltar `op`, el tercer argumento en `[` para objetos `sf`.\nSe puede utilizar para cambiar la operación de subset de muchas maneras.\n`nz_height[canterbury, 2, op = st_disjoint]`, por ejemplo, devuelve las mismas filas pero sólo incluye la segunda columna de atributos (véase `` sf:::`[.sf` `` y el `?sf` para más detalles).\n:::\n\n### Unión espacial \n\nLa unión de dos conjuntos de datos no espaciales se basa en una variable \"clave\" compartida o *key*.\nLa unión de datos espaciales aplica el mismo concepto, pero se basa en las relaciones espaciales.\nAl igual que con los atributos, la unión añade nuevas columnas al objeto de destino (el argumento `x` en las funciones de unión), a partir de un objeto de origen (`y`).\n\nEl proceso se ilustra con el siguiente ejemplo: imagine que tiene diez puntos distribuidos aleatoriamente por la superficie de la Tierra y pregunta, para los puntos que están en tierra, ¿en qué países se encuentran?\n\nEl punto de partida es crear puntos dispersos aleatoriamente por la superficie terrestre:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2018) # set seed for reproducibility\n(bb = st_bbox(world)) # the world's bounds\nrandom_df = data.frame(\n  x = runif(n = 10, min = bb[1], max = bb[3]),\n  y = runif(n = 10, min = bb[2], max = bb[4])\n)\nrandom_points = random_df |> \n  st_as_sf(coords = c(\"x\", \"y\"), crs = \"EPSG:4326\") # set coordinates and CRS\n##       xmin       ymin       xmax       ymax \n## -180.00000  -89.90000  179.99999   83.64513\n```\n:::\n\n\nEl escenario ilustrado abajo muestra que el objeto `random_points` (arriba a la izquierda) carece de datos de atributos, mientras que el `world` (arriba a la derecha) tiene atributos, incluidos los nombres de los países mostrados para una muestra de países en la leyenda.\nLas uniones espaciales se implementan con `st_join()`, como se ilustra en el siguiente fragmento de código.\nEl resultado es el objeto `random_joined` que se ilustra abajo a la izquierda.\n\n![](https://r.geocompx.org/04-spatial-operations_files/figure-html/spatial-join-1.png)\n\nAntes de crear el conjunto de datos unido, utilizamos el subconjunto espacial para crear `world_random`, que contiene sólo países que contienen puntos aleatorios, para verificar que el número de nombres de países devueltos en el conjunto de datos unido debe ser cuatro.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld_random = world[random_points, ]\nnrow(world_random)\nrandom_joined = st_join(random_points, world[\"name_long\"])\n## [1] 4\n```\n:::\n\n\nPor defecto, `st_join()` realiza una unión a la izquierda, lo que significa que el resultado es un objeto que contiene todas las filas de `x` incluyendo las filas que no coinciden con `y`, pero también puede realizar uniones internas estableciendo el argumento `left = FALSE`.\nAl igual que el subset espacial, el operador topológico por defecto utilizado por `st_join()` es `st_intersects()`, que puede cambiarse estableciendo el argumento `join` (véase `?st_join` para más detalles).\nEl ejemplo anterior muestra la adición de una columna de una capa de polígonos a una capa de puntos, pero el método funciona independientemente del tipo de geometría.\nEn tales casos, por ejemplo cuando `x` contiene polígonos, cada uno de los cuales coincide con múltiples objetos en `y`, las uniones espaciales darán lugar a características duplicadas al crear una nueva fila por cada coincidencia en `y`.\n\n### Uniones no solapadas\n\nA veces, dos conjuntos de datos geográficos no se tocan, pero mantienen una estrecha relación geográfica.\nLos conjuntos de datos `cycle_hire` y `cycle_hire_osm`, ya adjuntos en el paquete **spData**, constituyen un buen ejemplo.\nSu representación gráfica muestra que a menudo están estrechamente relacionados pero no se tocan, como se muestra abajo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(st_geometry(cycle_hire), col = \"blue\")\nplot(st_geometry(cycle_hire_osm), add = TRUE, pch = 3, col = \"red\")\n```\n:::\n\n\nPodemos comprobar si algún punto coincide con `st_intersects()` como se muestra a continuación:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nany(st_touches(cycle_hire, cycle_hire_osm, sparse = FALSE))\n## [1] FALSE\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nImaginemos que necesitamos unir la variable `capacity` de `cycle_hire_osm` a los datos oficiales `target` contenidos en `cycle_hire`.\nEn este caso se necesita una unión no solapada.\nEl método más sencillo es utilizar el predicado binario `st_is_within_distance()`, como se muestra a continuación utilizando una distancia umbral de 20 m.\nSe puede establecer la distancia umbral en unidades métricas también para datos no proyectados (por ejemplo, lon/lat CRSs como WGS84), si el motor de geometría esférica (s2) está habilitado, como lo está en **sf** por defecto.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsel = st_is_within_distance(cycle_hire, cycle_hire_osm, \n                            dist = units::set_units(20, \"m\"))\nsummary(lengths(sel) > 0)\n##    Mode   FALSE    TRUE \n## logical     304     438\n```\n:::\n\n\nEsto muestra que hay 438 puntos en el objeto de destino `cycle_hire` dentro de la distancia umbral de `cycle_hire_osm`.\n¿Cómo recuperar los *valores* asociados a los respectivos puntos de `cycle_hire_osm`?\nLa solución es de nuevo con `st_join()`, pero añadiendo el argumento `dist` (fijado en 20 m más abajo):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz = st_join(cycle_hire, cycle_hire_osm, st_is_within_distance, \n            dist = units::set_units(20, \"m\"))\nnrow(cycle_hire)\nnrow(z)\n## [1] 742\n## [1] 762\n```\n:::\n\n\nObserve que el número de filas del resultado unido es mayor que el objetivo.\nEsto se debe a que algunas estaciones de alquiler de bicicletas en `cycle_hire` tienen múltiples coincidencias en `cycle_hire_osm`.\nPara agregar los valores de los puntos solapados y devolver la media, podemos utilizar los métodos de agregación aprendidos ates, dando como resultado un objeto con el mismo número de filas que el objetivo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz = z |> \n  group_by(id) |> \n  summarize(capacity = mean(capacity))\nnrow(z) == nrow(cycle_hire)\n## [1] TRUE\n```\n:::\n\n\nLa capacidad de las estaciones cercanas puede verificarse comparando un gráfico de la capacidad de los datos de la fuente `cycle_hire_osm` con los resultados de este nuevo objeto (gráficos no mostrados):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(cycle_hire_osm[\"capacity\"])\n```\n\n::: {.cell-output-display}\n![](operaciones_espaciales_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(z[\"capacity\"])\n```\n\n::: {.cell-output-display}\n![](operaciones_espaciales_files/figure-html/unnamed-chunk-3-2.png){width=672}\n:::\n:::\n\n\nEl resultado de esta unión ha utilizado una operación espacial para cambiar los datos de atributos asociados a sf; la geometría asociada a cada característica ha permanecido inalterada.\n\n### Agregación espacial\n\nAl igual que la agregación de datos de atributos, la agregación de datos espaciales *condensa* los datos: las salidas agregadas tienen menos filas que las entradas no agregadas.\nLas funciones de *agregación estadística*, como la media o la suma, resumen múltiples valores de una variable, y devuelven un único valor por *variable de agrupación*.\nYa se demostró cómo `aggregate()` y `group_by() |> summarize()` condensan datos basados en variables de atributo, esta sección muestra cómo funcionan las mismas funciones con objetos espaciales.\n\nVolviendo al ejemplo de Nueva Zelanda, imagine que desea averiguar la altura media de los puntos altos de cada región: es la geometría de la fuente (`y` o `nz` en este caso) la que define cómo se agrupan los valores en el objeto de destino (`x` o `nz_height`).\nEsto se puede hacer en una sola línea de código con el método `aggregate()` de R base:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnz_agg = aggregate(x = nz_height, by = nz, FUN = mean)\n```\n:::\n\n\nEl resultado del comando anterior es un objeto `sf` con la misma geometría que el objeto de agregación (espacial) (`nz`), lo que puede comprobar con el comando `identical(st_geometry(nz), st_geometry(nz_agg))`.\nEl resultado de la operación anterior se ilustra en la figura @ref(fig:spatial-aggregation), que muestra el valor medio de las características en `nz_height` dentro de cada una de las 16 regiones de Nueva Zelanda.\nEl mismo resultado también puede generarse canalizando la salida de `st_join()` a las funciones `group_by()` y `summarize()` de la siguiente forma:\n\n\n::: {.cell fig.asp='1'}\n::: {.cell-output-display}\n![Average height of the top 101 high points across the regions of New Zealand.](operaciones_espaciales_files/figure-html/spatial-aggregation-1.png){width=50%}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnz_agg2 = st_join(x = nz, y = nz_height) |>\n  group_by(Name) |>\n  summarize(elevation = mean(elevation, na.rm = TRUE))\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nLos objetos `nz_agg` resultantes tienen la misma geometría que el objeto agregador `nz` pero con una nueva columna que resume los valores de `x` en cada región utilizando la función `mean()`.\nSe pueden utilizar otras funciones en lugar de `mean()`, incluyendo `median()`, `sd()` y otras funciones que devuelven un único valor por grupo.\n\n\n### Relaciones de distancia \n\nMientras que las relaciones topológicas son binarias (una característica se cruza con otra o no), las relaciones de distancia son continuas.\nLa distancia entre dos objetos se calcula con la función `st_distance()`.\nEsto se ilustra en el siguiente fragmento de código, que encuentra la distancia entre el punto más alto de Nueva Zelanda y el centroide geográfico de la región de Canterbury:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnz_highest = nz_height |> slice_max(n = 1, order_by = elevation)\ncanterbury_centroid = st_centroid(canterbury)\nst_distance(nz_highest, canterbury_centroid)\n## Units: [m]\n##        [,1]\n## [1,] 115540\n```\n:::\n\n\nHay dos cosas potencialmente sorprendentes en el resultado:\n\n- Tiene \"unidades\", lo que nos indica que la distancia es de 100.000 metros, no de 100.000 pulgadas ni de ninguna otra medida de distancia.\n- Se devuelve como una matriz, aunque el resultado sólo contenga un valor.\n\nEsta segunda característica indica otra característica útil de `st_distance()`, su capacidad para devolver *matrices de distancia* entre todas las combinaciones de características en los objetos `x` e `y`.\nEsto se ilustra en el siguiente comando, que encuentra las distancias entre las tres primeras características de `nz_height` y las regiones de Otago y Canterbury de Nueva Zelanda representadas por el objeto `co`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nco = filter(nz, grepl(\"Canter|Otag\", Name))\nst_distance(nz_height[1:3, ], co)\n## Units: [m]\n##           [,1]     [,2]\n## [1,] 123537.16 15497.72\n## [2,]  94282.77     0.00\n## [3,]  93018.56     0.00\n```\n:::\n\n\nObserve que la distancia entre la segunda y tercera características de `nz_height` y la segunda característica de `co` es cero.\nEsto demuestra el hecho de que las distancias entre puntos y polígonos se refieren a la distancia a *cualquier parte del polígono*:\nLos puntos segundo y tercero de `nz_height` están *en* Otago, lo que puede comprobarse trazándolos:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(st_geometry(co)[2])\nplot(st_geometry(nz_height)[2:3], add = TRUE)\n```\n\n::: {.cell-output-display}\n![](operaciones_espaciales_files/figure-html/04-spatial-operations-33-1.png){width=672}\n:::\n:::\n\n\n## Operaciones espaciales sobre datos ráster\n\nEsta sección demuestra operaciones ráster más avanzadas y explícitamente espaciales con los objetos `elev` y `grain` del paquete **spData**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelev = rast(system.file(\"raster/elev.tif\", package = \"spData\"))\ngrain = rast(system.file(\"raster/grain.tif\", package = \"spData\"))\n```\n:::\n\n\n### Subdivisión espacial\n\nYa se vio cómo recuperar valores asociados con IDs de celdas específicas o combinaciones de filas y columnas.\nLos objetos ráster también pueden subdividirse por ubicación (coordenadas) y con otros objetos espaciales.\nPara utilizar coordenadas para realizar el subset, se pueden \"traducir\" las coordenadas a un ID de celda con la función **terra** `cellFromXY()`.\nUna alternativa es utilizar `terra::extract()` para extraer valores.\nAmbos métodos se demuestran a continuación para encontrar el valor de la celda que cubre un punto situado en las coordenadas (0.1, 0.1).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nid = cellFromXY(elev, xy = matrix(c(0.1, 0.1), ncol = 2))\nelev[id]\n# the same as\nterra::extract(elev, matrix(c(0.1, 0.1), ncol = 2))\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| elev|\n|----:|\n|   16|\n\n</div><div class=\"kable-table\">\n\n| elev|\n|----:|\n|   16|\n\n</div>\n:::\n:::\n\n\nLos objetos ráster también se pueden subdividir con otro objeto ráster, como se demuestra en el fragmento de código siguiente:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclip = rast(xmin = 0.9, xmax = 1.8, ymin = -0.45, ymax = 0.45,\n            resolution = 0.3, vals = rep(1, 9))\nelev[clip]\n# we can also use extract\n# terra::extract(elev, ext(clip))\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| elev|\n|----:|\n|   18|\n|   24|\n\n</div>\n:::\n:::\n\n\nSe trata de recuperar los valores del primer objeto raster (en este caso, `elev`) que se encuentran dentro de la extensión de un segundo raster.\n\nEl ejemplo anterior devolvía los valores de celdas específicas, pero en muchos casos se necesitan salidas espaciales.\nEsto puede hacerse estableciendo el argumento `drop` del operador `[` en `FALSE`.\nEl siguiente código devuelve las dos primeras celdas de `elev`, es decir, las dos primeras celdas de la fila superior, como un objeto raster:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelev[1:2, drop = FALSE]    # spatial subsetting with cell IDs\n## class       : SpatRaster \n## dimensions  : 1, 2, 1  (nrow, ncol, nlyr)\n## resolution  : 0.5, 0.5  (x, y)\n## extent      : -1.5, -0.5, 1, 1.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## varname     : elev \n## name        : elev \n## min value   :    1 \n## max value   :    2\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](operaciones_espaciales_files/figure-html/04-spatial-operations-37-1.png){width=672}\n:::\n:::\n\n\nOtro caso de uso común del subset espacial es cuando un ráster con valores `lógicos` (o `NA`) se utiliza para enmascarar otro ráster con la misma extensión y resolución.\nEn este caso, pueden utilizarse las funciones `[` y `mask()` (resultados no mostrados):\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create raster mask\nrmask = elev\nvalues(rmask) = sample(c(NA, TRUE), 36, replace = TRUE)\n```\n:::\n\n\nEn el fragmento de código anterior, hemos creado un objeto máscara llamado `rmask` con valores asignados aleatoriamente a `NA` y `TRUE`.\nA continuación, queremos mantener los valores de `elev` que son `TRUE` en `rmask`.\nEn otras palabras, queremos enmascarar `elev` con `rmask`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# spatial subsetting\nelev[rmask, drop = FALSE]           # with [ operator\nmask(elev, rmask)                   # with mask()\n```\n:::\n\n\nEl enfoque anterior también se puede utilizar para sustituir algunos valores (por ejemplo, los que se espera que sean erróneos) por NA. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nelev[elev < 20] = NA\n```\n:::\n\n\nEstas operaciones son, de hecho, operaciones locales booleanas, ya que comparamos celda por celda dos rásters.\nEn la siguiente subsección se analizan con más detalle estas operaciones y otras relacionadas.\n\n### Álgebra de mapas\n\nEl término 'álgebra de mapas' se acuñó a finales de la década de 1970 para describir un \"conjunto de convenciones, capacidades y técnicas\" para el análisis de datos geográficos ráster *y* (aunque con menos prominencia) vectoriales.\nEn este contexto, definimos el álgebra de mapas de forma más restringida, como operaciones que modifican o resumen valores de celdas ráster, con referencia a celdas circundantes, zonas o funciones estadísticas que se aplican a cada celda.\n\nLas operaciones de álgebra de mapas suelen ser rápidas, porque los conjuntos de datos ráster sólo almacenan implícitamente coordenadas.\nLa ubicación de las celdas en los conjuntos de datos ráster puede calcularse utilizando su posición matricial y la resolución y origen del conjunto de datos (almacenados en la cabecera).\nPara el procesamiento, sin embargo, la posición geográfica de una celda apenas es relevante, siempre y cuando nos aseguremos de que la posición de la celda sigue siendo la misma después del procesamiento.\nAdemás, si dos o más conjuntos de datos ráster comparten la misma extensión, proyección y resolución, se podrían tratar como matrices.\n\nAsí funciona el álgebra de mapas con el paquete **terra**.\nEn primer lugar, se consultan las cabeceras de los conjuntos de datos ráster y se comprueba que los conjuntos de datos sean compatibles.\nEn segundo lugar, el álgebra de mapas mantiene la llamada correspondencia de localización uno a uno, lo que significa que las celdas no pueden moverse.\nEsto difiere del álgebra matricial, en la que los valores cambian de posición, por ejemplo al multiplicar o dividir matrices.\n\nEl álgebra de mapas divide las operaciones ráster en cuatro subclases:\n\n1. *Operaciones locales o por celda*\n2. *Operaciones focales* o de vecindad. Lo más frecuente es que el valor de la celda de salida sea el resultado de un bloque de celdas de entrada de 3 x 3\n3. *Las operaciones zonales* son similares a las operaciones focales, pero la cuadrícula de píxeles circundante sobre la que se calculan los nuevos valores puede tener tamaños y formas irregulares\n4. *Operaciones globales* o per-raster. Esto significa que la celda de salida puede derivar su valor de uno o varios rásters completos.\n\n\n### Operaciones locales\n\nLas operaciones locales comprenden todas las operaciones celda por celda en una o varias capas.\nEl álgebra ráster es un caso de uso clásico de las operaciones locales, que incluye la suma o resta de valores de un ráster, el cuadrado y la multiplicación de rásters.\nEl álgebra raster también permite realizar operaciones lógicas, como encontrar todas las celdas que superen un valor determinado.\nEl paquete **terra** admite todas estas operaciones y más, como se muestra a continuación:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelev + elev\nelev^2\nlog(elev)\nelev > 5\n```\n:::\n\n\nOtro buen ejemplo de operaciones locales es la clasificación de intervalos de valores numéricos en grupos, como la agrupación de un modelo digital de elevación en elevaciones bajas (clase 1), medias (clase 2) y altas (clase 3).\nPara utilizar el comando `classify()`, necesitamos primero construir una matriz de reclasificación, donde la primera columna corresponde al extremo inferior y la segunda columna al extremo superior de la clase.\nLa tercera columna representa el nuevo valor para los rangos especificados en las columnas uno y dos.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrcl = matrix(c(0, 12, 1, 12, 24, 2, 24, 36, 3), ncol = 3, byrow = TRUE)\nrcl\n##      [,1] [,2] [,3]\n## [1,]    0   12    1\n## [2,]   12   24    2\n## [3,]   24   36    3\n```\n:::\n\n\nAquí, los valores ráster en los rangos 0--12, 12--24 y 24--36 se *reclasifican* para tomar los valores 1, 2 y 3, respectivamente.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrecl = classify(elev, rcl = rcl)\n```\n:::\n\n\nLa función `classify()` también puede utilizarse cuando queremos reducir el número de clases en nuestros rásters categóricos.\n\nAdemás de los operadores aritméticos, también se pueden utilizar las funciones `app()`, `tapp()` y `lapp()`.\nSon más eficientes, por lo que son preferibles en presencia de grandes conjuntos de datos ráster. \nAdemás, permiten guardar directamente un archivo de salida.\nLa función `app()` aplica una función a cada celda de un raster y se utiliza para resumir (por ejemplo, calculando la suma) los valores de múltiples capas en una sola capa.\nLa función `tapp()` es una extensión de `app()` que nos permite seleccionar un subconjunto de capas (véase el argumento `index`) para las que queremos realizar una determinada operación.\nPor último, la función `lapp()` permite aplicar una función a cada celda utilizando las capas como argumentos -- a continuación se presenta una aplicación de `lapp()`.\n\nEl cálculo del índice de vegetación de diferencia normalizada (NDVI) es una conocida operación de raster local (píxel a píxel).\nDevuelve un raster con valores entre -1 y 1; los valores positivos indican la presencia de plantas vivas (en su mayoría > 0.2).\nEl NDVI se calcula a partir de las bandas roja e infrarroja cercana (NIR) de imágenes satelitales.\n\n$$\n\\begin{split}\nNDVI&= \\frac{\\text{NIR} - \\text{Red}}{\\text{NIR} + \\text{Red}}\\\\\n\\end{split}\n$$\n\nCalculemos el NDVI para el archivo de satélite multiespectral del Parque Nacional de Zion.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmulti_raster_file = system.file(\"raster/landsat.tif\", package = \"spDataLarge\")\nmulti_rast = rast(multi_raster_file)\n```\n:::\n\n\nEl objeto raster tiene cuatro bandas de satélite: azul, verde, rojo e infrarrojo cercano (NIR).\nNuestro siguiente paso será implementar la fórmula NDVI en una función de R:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nndvi_fun = function(nir, red){\n  (nir - red) / (nir + red)\n}\n```\n:::\n\n\nEsta función acepta dos argumentos numéricos, `nir` y `red`, y devuelve un vector numérico con valores NDVI.\nPuede utilizarse como argumento `fun` de `lapp()`.\nSólo tenemos que recordar que nuestra función sólo necesita dos bandas (no cuatro de la trama original), y tienen que estar en el orden NIR, rojo.\nPor eso, antes de hacer los cálculos, se hace un subconjunto del raster de entrada con `multi_rast[[c(4, 3)]]`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nndvi_rast = lapp(multi_rast[[c(4, 3)]], fun = ndvi_fun)\nplot(ndvi_rast)\n```\n\n::: {.cell-output-display}\n![](operaciones_espaciales_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\nLa cartografía predictiva es otra aplicación interesante de las operaciones raster locales.\nLa variable de respuesta corresponde a puntos medidos u observados en el espacio, por ejemplo, la riqueza de especies, la presencia de corrimientos de tierras, la enfermedad de los árboles o el rendimiento de los cultivos.\nPor consiguiente, podemos recuperar fácilmente variables predictoras espaciales o aéreas a partir de diversos rásters (elevación, pH, precipitaciones, temperatura, cubierta vegetal, clase de suelo, etc.).\nA continuación, modelizamos nuestra respuesta en función de nuestros predictores mediante `lm()`, `glm()`, `gam()` o una técnica de aprendizaje automático. \nPor tanto, las predicciones espaciales sobre objetos ráster pueden realizarse aplicando coeficientes estimados a los valores ráster predictores y sumando los valores ráster de salida.\n\n### Operaciones focales\n\nMientras que las funciones locales operan sobre una celda, aunque posiblemente de varias capas, las operaciones **focales** tienen en cuenta una celda central (focal) y sus vecinas.\nEl vecindario (también denominado núcleo, filtro o ventana móvil) considerado suele tener un tamaño de 3 por 3 celdas (es decir, la celda central y sus ocho vecinas circundantes), pero puede adoptar cualquier otra forma (no necesariamente rectangular) definida por el usuario.\nUna operación focal aplica una función de agregación a todas las celdas dentro del vecindario especificado, utiliza el resultado correspondiente como nuevo valor para la celda central y pasa a la siguiente celda central.\nOtros nombres para esta operación son filtrado espacial y convolución.\n\n![](https://r.geocompx.org/figures/04_focal_example.png)\n\nEn R, podemos utilizar la función `focal()` para realizar el filtrado espacial. \nDefinimos la forma de la ventana móvil con una \"matriz\" cuyos valores corresponden a los pesos (véase el parámetro \"w\" en el fragmento de código siguiente).\nEn segundo lugar, el parámetro `fun` nos permite especificar la función que deseamos aplicar a este vecindario.\nAquí, elegimos el mínimo, pero cualquier otra función de resumen, incluyendo `sum()`, `mean()`, o `var()` se puede utilizar.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr_focal = focal(elev, w = matrix(1, nrow = 3, ncol = 3), fun = min)\n```\n:::\n\n\nEsta función también acepta argumentos adicionales, por ejemplo, si debe eliminar los NA en el proceso (`na.rm = TRUE`) o no (`na.rm = FALSE`).\n\n### Operaciones zonales\n\nAl igual que las operaciones focales, las operaciones *zonales* aplican una función de agregación a múltiples celdas de trama.\nSin embargo, un segundo ráster, normalmente con valores categóricos, define los *filtros zonales* (o \"zonas\"), a diferencia de una ventana de vecindad predefinida en el caso de la operación focal presentada en la sección anterior.\nPor consiguiente, las celdas del ráster que definen el filtro zonal no tienen por qué ser necesariamente vecinas.\nNuestro ráster de tamaño de grano es un buen ejemplo: los diferentes tamaños de grano están repartidos irregularmente por todo el ráster.\nPor último, el resultado de una operación zonal es una tabla resumen agrupada por zonas, razón por la cual esta operación también se conoce como *estadística zonal* en el mundo SIG. \nEsto contrasta con las operaciones focales que devuelven un objeto raster.\n\nEl siguiente fragmento de código utiliza la función `zonal()` para calcular la elevación media asociada a cada clase de tamaño de grano, por ejemplo.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz = zonal(elev, grain, fun = \"mean\")\nz\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|grain |     elev|\n|:-----|--------:|\n|clay  | 14.80000|\n|silt  | 21.15385|\n|sand  | 18.69231|\n\n</div>\n:::\n:::\n\n\nNota: también es posible obtener un raster con estadísticas calculadas para cada zona estableciendo el argumento `as.raster` a `TRUE`.\n\n### Operaciones globales\n\nLas operaciones globales son un caso especial de las operaciones zonales, en las que todo el conjunto de datos ráster representa una única zona.\nLas operaciones globales más comunes son las estadísticas descriptivas para todo el conjunto de datos ráster.\n\n### Fusión de rásters\n\nSupongamos que queremos calcular el NDVI, y además queremos calcular atributos del terreno a partir de datos de elevación para observaciones dentro de un área de estudio.\nEstos cálculos se basan en información obtenida por teledetección. \nLas imágenes correspondientes suelen dividirse en escenas que cubren una extensión espacial específica y, con frecuencia, un área de estudio abarca más de una escena.\nEntonces, tendríamos que fusionar las escenas cubiertas por nuestra zona de estudio. \nEn el caso más sencillo, basta con fusionar las escenas, es decir, ponerlas una al lado de la otra.\nEsto es posible, por ejemplo, con datos digitales de elevación (SRTM, ASTER).\nEn el siguiente fragmento de código descargamos primero los datos de elevación SRTM de Austria y Suiza (para los códigos de país, véase la función **geodata** `country_codes()`).\nEn un segundo paso, fusionamos los dos rásters en uno.\n\n\n::: {.cell}\n\n```{.r .cell-code}\naut = geodata::elevation_30s(country = \"AUT\", path = tempdir())\nch = geodata::elevation_30s(country = \"CHE\", path = tempdir())\naut_ch = merge(aut, ch)\n```\n:::\n\n\nEl comando `merge()` de **terra** combina dos imágenes y, en caso de que se solapen, utiliza el valor de la primera trama.\n",
    "supporting": [
      "operaciones_espaciales_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}